contract main {




// =====================  Runtime code  =====================


#
#  - pantherCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4)
#
address stor0;

function _fallback() payable {
    revert
}

function startArbitrage(address arg1, address arg2, uint256 arg3, uint256 arg4) {
    require calldata.size - 4 >= 128
    require ext_code.size(0x9ad6c38be94206ca50bb0d90783181662f0cfa10)
    staticcall 0x9ad6c38be94206ca50bb0d90783181662f0cfa10.getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args address(arg1), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[12 len 20]:
        revert with 0, 'This pool does not exist'
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
         gas gas_remaining wei
        args arg3, arg4, address(this.address), 'not empty'
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function cafeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function wardenCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function BiswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function swapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function jetswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function pancakeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function waultSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not arg2:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1829 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1925 = mem[_1829 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1829 + 192])] = mem[_1829 + 224 len floor32(mem[_1829 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3237 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1925) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1925) + ceil32(return_data.size) + 260] = _3237
                        mem[(32 * _1925) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1925) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1925) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1925) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1925) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3237, Array(len=2, data=mem[(32 * _1925) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1925) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1925) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4485 = mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1925) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1925) + ceil32(return_data.size) + 224]
                        mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])] = mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 256 len floor32(mem[_4485 + (32 * _1925) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] <= _3237:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3237
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3237 > mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1925) + (2 * ceil32(return_data.size)) + 288] - _3237
                    else:
                        _1831 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1926 = mem[_1831 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1831 + 192])] = mem[_1831 + 224 len floor32(mem[_1831 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3241 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1926) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1926) + ceil32(return_data.size) + 260] = _3241
                        mem[(32 * _1926) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1926) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1926) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1926) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1926) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3241, Array(len=2, data=mem[(32 * _1926) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1926) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1926) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4487 = mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1926) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1926) + ceil32(return_data.size) + 224]
                        mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])] = mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 256 len floor32(mem[_4487 + (32 * _1926) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] <= _3241:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3241
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3241 > mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1926) + (2 * ceil32(return_data.size)) + 288] - _3241
                else:
                    if not arg2:
                        _1833 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1927 = mem[_1833 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1833 + 192])] = mem[_1833 + 224 len floor32(mem[_1833 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3245 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1927) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1927) + ceil32(return_data.size) + 260] = _3245
                        mem[(32 * _1927) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1927) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1927) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1927) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1927) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3245, Array(len=2, data=mem[(32 * _1927) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1927) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1927) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4489 = mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1927) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1927) + ceil32(return_data.size) + 224]
                        mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])] = mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 256 len floor32(mem[_4489 + (32 * _1927) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] <= _3245:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3245
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3245 > mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1927) + (2 * ceil32(return_data.size)) + 288] - _3245
                    else:
                        _1835 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1928 = mem[_1835 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1835 + 192])] = mem[_1835 + 224 len floor32(mem[_1835 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3249 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1928) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1928) + ceil32(return_data.size) + 260] = _3249
                        mem[(32 * _1928) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1928) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1928) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1928) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1928) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3249, Array(len=2, data=mem[(32 * _1928) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1928) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1928) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4491 = mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1928) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1928) + ceil32(return_data.size) + 224]
                        mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])] = mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 256 len floor32(mem[_4491 + (32 * _1928) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] <= _3249:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3249
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3249 > mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1928) + (2 * ceil32(return_data.size)) + 288] - _3249
            else:
                if not arg2:
                    if not arg2:
                        _1837 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1929 = mem[_1837 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1837 + 192])] = mem[_1837 + 224 len floor32(mem[_1837 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3253 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1929) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1929) + ceil32(return_data.size) + 260] = _3253
                        mem[(32 * _1929) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1929) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1929) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1929) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1929) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3253, Array(len=2, data=mem[(32 * _1929) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1929) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1929) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4493 = mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1929) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1929) + ceil32(return_data.size) + 224]
                        mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])] = mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 256 len floor32(mem[_4493 + (32 * _1929) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] <= _3253:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3253
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3253 > mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1929) + (2 * ceil32(return_data.size)) + 288] - _3253
                    else:
                        _1839 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1930 = mem[_1839 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1839 + 192])] = mem[_1839 + 224 len floor32(mem[_1839 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3257 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1930) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1930) + ceil32(return_data.size) + 260] = _3257
                        mem[(32 * _1930) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1930) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1930) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1930) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1930) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3257, Array(len=2, data=mem[(32 * _1930) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1930) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1930) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4495 = mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1930) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1930) + ceil32(return_data.size) + 224]
                        mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])] = mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 256 len floor32(mem[_4495 + (32 * _1930) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] <= _3257:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3257
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3257 > mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1930) + (2 * ceil32(return_data.size)) + 288] - _3257
                else:
                    if not arg2:
                        _1841 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1931 = mem[_1841 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1841 + 192])] = mem[_1841 + 224 len floor32(mem[_1841 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3261 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1931) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1931) + ceil32(return_data.size) + 260] = _3261
                        mem[(32 * _1931) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1931) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1931) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1931) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1931) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3261, Array(len=2, data=mem[(32 * _1931) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1931) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1931) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4497 = mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1931) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1931) + ceil32(return_data.size) + 224]
                        mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])] = mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 256 len floor32(mem[_4497 + (32 * _1931) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] <= _3261:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3261
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3261 > mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1931) + (2 * ceil32(return_data.size)) + 288] - _3261
                    else:
                        _1843 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1932 = mem[_1843 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1843 + 192])] = mem[_1843 + 224 len floor32(mem[_1843 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3265 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1932) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1932) + ceil32(return_data.size) + 260] = _3265
                        mem[(32 * _1932) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1932) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1932) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1932) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1932) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3265, Array(len=2, data=mem[(32 * _1932) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1932) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1932) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4499 = mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1932) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1932) + ceil32(return_data.size) + 224]
                        mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])] = mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 256 len floor32(mem[_4499 + (32 * _1932) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] <= _3265:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3265
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3265 > mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1932) + (2 * ceil32(return_data.size)) + 288] - _3265
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg3
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1845 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1933 = mem[_1845 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1845 + 192])] = mem[_1845 + 224 len floor32(mem[_1845 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3269 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1933) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1933) + ceil32(return_data.size) + 260] = _3269
                        mem[(32 * _1933) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1933) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1933) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1933) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1933) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3269, Array(len=2, data=mem[(32 * _1933) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1933) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1933) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4501 = mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1933) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1933) + ceil32(return_data.size) + 224]
                        mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])] = mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 256 len floor32(mem[_4501 + (32 * _1933) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] <= _3269:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3269
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3269 > mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1933) + (2 * ceil32(return_data.size)) + 288] - _3269
                    else:
                        _1847 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1934 = mem[_1847 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1847 + 192])] = mem[_1847 + 224 len floor32(mem[_1847 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3273 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1934) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1934) + ceil32(return_data.size) + 260] = _3273
                        mem[(32 * _1934) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1934) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1934) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1934) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1934) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3273, Array(len=2, data=mem[(32 * _1934) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1934) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1934) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4503 = mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1934) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1934) + ceil32(return_data.size) + 224]
                        mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])] = mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 256 len floor32(mem[_4503 + (32 * _1934) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] <= _3273:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3273
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3273 > mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1934) + (2 * ceil32(return_data.size)) + 288] - _3273
                else:
                    if not arg2:
                        _1849 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1935 = mem[_1849 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1849 + 192])] = mem[_1849 + 224 len floor32(mem[_1849 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3277 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1935) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1935) + ceil32(return_data.size) + 260] = _3277
                        mem[(32 * _1935) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1935) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1935) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1935) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1935) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3277, Array(len=2, data=mem[(32 * _1935) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1935) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1935) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4505 = mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1935) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1935) + ceil32(return_data.size) + 224]
                        mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])] = mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 256 len floor32(mem[_4505 + (32 * _1935) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] <= _3277:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3277
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3277 > mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1935) + (2 * ceil32(return_data.size)) + 288] - _3277
                    else:
                        _1851 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1936 = mem[_1851 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1851 + 192])] = mem[_1851 + 224 len floor32(mem[_1851 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3281 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1936) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1936) + ceil32(return_data.size) + 260] = _3281
                        mem[(32 * _1936) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1936) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1936) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1936) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1936) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3281, Array(len=2, data=mem[(32 * _1936) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1936) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1936) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4507 = mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1936) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1936) + ceil32(return_data.size) + 224]
                        mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])] = mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 256 len floor32(mem[_4507 + (32 * _1936) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] <= _3281:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3281
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3281 > mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1936) + (2 * ceil32(return_data.size)) + 288] - _3281
            else:
                if not arg2:
                    if not arg2:
                        _1853 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1937 = mem[_1853 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1853 + 192])] = mem[_1853 + 224 len floor32(mem[_1853 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3285 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1937) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1937) + ceil32(return_data.size) + 260] = _3285
                        mem[(32 * _1937) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1937) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1937) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1937) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1937) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3285, Array(len=2, data=mem[(32 * _1937) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1937) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1937) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4509 = mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1937) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1937) + ceil32(return_data.size) + 224]
                        mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])] = mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 256 len floor32(mem[_4509 + (32 * _1937) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] <= _3285:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3285
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3285 > mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1937) + (2 * ceil32(return_data.size)) + 288] - _3285
                    else:
                        _1855 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1938 = mem[_1855 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1855 + 192])] = mem[_1855 + 224 len floor32(mem[_1855 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3289 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1938) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1938) + ceil32(return_data.size) + 260] = _3289
                        mem[(32 * _1938) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1938) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1938) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1938) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1938) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3289, Array(len=2, data=mem[(32 * _1938) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1938) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1938) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4511 = mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1938) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1938) + ceil32(return_data.size) + 224]
                        mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])] = mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 256 len floor32(mem[_4511 + (32 * _1938) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] <= _3289:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3289
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3289 > mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1938) + (2 * ceil32(return_data.size)) + 288] - _3289
                else:
                    if not arg2:
                        _1857 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1939 = mem[_1857 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1857 + 192])] = mem[_1857 + 224 len floor32(mem[_1857 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3293 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1939) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1939) + ceil32(return_data.size) + 260] = _3293
                        mem[(32 * _1939) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1939) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1939) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1939) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1939) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3293, Array(len=2, data=mem[(32 * _1939) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1939) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1939) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4513 = mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1939) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1939) + ceil32(return_data.size) + 224]
                        mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])] = mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 256 len floor32(mem[_4513 + (32 * _1939) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] <= _3293:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3293
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3293 > mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1939) + (2 * ceil32(return_data.size)) + 288] - _3293
                    else:
                        _1859 = mem[192 len 4], Mask(224, 32, arg3) >> 32
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                        _1940 = mem[_1859 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1859 + 192])] = mem[_1859 + 224 len floor32(mem[_1859 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3297 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1940) + ceil32(return_data.size) + 228] = arg3
                        mem[(32 * _1940) + ceil32(return_data.size) + 260] = _3297
                        mem[(32 * _1940) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1940) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1940) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1940) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1940) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, _3297, Array(len=2, data=mem[(32 * _1940) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1940) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1940) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4515 = mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= 4294967296
                        require mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1940) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + (32 * _1940) + ceil32(return_data.size) + 224]
                        mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])] = mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 256 len floor32(mem[_4515 + (32 * _1940) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] <= _3297:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3297
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3297 > mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1940) + (2 * ceil32(return_data.size)) + 288] - _3297
    else:
        if not arg2:
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1861 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1941 = mem[_1861 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1861 + 192])] = mem[_1861 + 224 len floor32(mem[_1861 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3301 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1941) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1941) + ceil32(return_data.size) + 260] = _3301
                        mem[(32 * _1941) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1941) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1941) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1941) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1941) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3301, Array(len=2, data=mem[(32 * _1941) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1941) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1941) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4517 = mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1941) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1941) + ceil32(return_data.size) + 224]
                        mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])] = mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 256 len floor32(mem[_4517 + (32 * _1941) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] <= _3301:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3301
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3301 > mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1941) + (2 * ceil32(return_data.size)) + 288] - _3301
                    else:
                        _1863 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1942 = mem[_1863 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1863 + 192])] = mem[_1863 + 224 len floor32(mem[_1863 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3305 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1942) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1942) + ceil32(return_data.size) + 260] = _3305
                        mem[(32 * _1942) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1942) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1942) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1942) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1942) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3305, Array(len=2, data=mem[(32 * _1942) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1942) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1942) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4519 = mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1942) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1942) + ceil32(return_data.size) + 224]
                        mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])] = mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 256 len floor32(mem[_4519 + (32 * _1942) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] <= _3305:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3305
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3305 > mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1942) + (2 * ceil32(return_data.size)) + 288] - _3305
                else:
                    if not arg2:
                        _1865 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1943 = mem[_1865 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1865 + 192])] = mem[_1865 + 224 len floor32(mem[_1865 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3309 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1943) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1943) + ceil32(return_data.size) + 260] = _3309
                        mem[(32 * _1943) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1943) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1943) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1943) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1943) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3309, Array(len=2, data=mem[(32 * _1943) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1943) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1943) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4521 = mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1943) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1943) + ceil32(return_data.size) + 224]
                        mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])] = mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 256 len floor32(mem[_4521 + (32 * _1943) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] <= _3309:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3309
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3309 > mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1943) + (2 * ceil32(return_data.size)) + 288] - _3309
                    else:
                        _1867 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1944 = mem[_1867 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1867 + 192])] = mem[_1867 + 224 len floor32(mem[_1867 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3313 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1944) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1944) + ceil32(return_data.size) + 260] = _3313
                        mem[(32 * _1944) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1944) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1944) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1944) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1944) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3313, Array(len=2, data=mem[(32 * _1944) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1944) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1944) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4523 = mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1944) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1944) + ceil32(return_data.size) + 224]
                        mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])] = mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 256 len floor32(mem[_4523 + (32 * _1944) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] <= _3313:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3313
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3313 > mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1944) + (2 * ceil32(return_data.size)) + 288] - _3313
            else:
                if not arg2:
                    if not arg2:
                        _1869 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1945 = mem[_1869 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1869 + 192])] = mem[_1869 + 224 len floor32(mem[_1869 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3317 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1945) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1945) + ceil32(return_data.size) + 260] = _3317
                        mem[(32 * _1945) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1945) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1945) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1945) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1945) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3317, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1945) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4525 = mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1945) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1945) + ceil32(return_data.size) + 224]
                        mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])] = mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 256 len floor32(mem[_4525 + (32 * _1945) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] <= _3317:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3317
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3317 > mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1945) + (2 * ceil32(return_data.size)) + 288] - _3317
                    else:
                        _1871 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1946 = mem[_1871 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1871 + 192])] = mem[_1871 + 224 len floor32(mem[_1871 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3321 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1946) + ceil32(return_data.size) + 260] = _3321
                        mem[(32 * _1946) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1946) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3321, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4527 = mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1946) + ceil32(return_data.size) + 224]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])] = mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 256 len floor32(mem[_4527 + (32 * _1946) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] <= _3321:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3321
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3321 > mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 288] - _3321
                else:
                    if not arg2:
                        _1873 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1947 = mem[_1873 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1873 + 192])] = mem[_1873 + 224 len floor32(mem[_1873 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3325 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1947) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1947) + ceil32(return_data.size) + 260] = _3325
                        mem[(32 * _1947) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1947) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1947) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1947) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1947) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3325, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1947) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4529 = mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1947) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1947) + ceil32(return_data.size) + 224]
                        mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])] = mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 256 len floor32(mem[_4529 + (32 * _1947) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] <= _3325:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3325
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3325 > mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1947) + (2 * ceil32(return_data.size)) + 288] - _3325
                    else:
                        _1875 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1948 = mem[_1875 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1875 + 192])] = mem[_1875 + 224 len floor32(mem[_1875 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3329 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1948) + ceil32(return_data.size) + 260] = _3329
                        mem[(32 * _1948) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1948) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3329, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4531 = mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1948) + ceil32(return_data.size) + 224]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])] = mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 256 len floor32(mem[_4531 + (32 * _1948) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] <= _3329:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3329
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3329 > mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 288] - _3329
        else:
            require not arg3
            if arg1 != this.address:
                revert with 0, '!sender'
            require arg4.length >= 64
            if address(cd[(arg4 + 36)]) == this.address:
                revert with 0, 'Gek adres!'
            if cd[(arg4 + 68)]:
                revert with 0, 'Geen Amount!'
            mem[96] = 2
            mem[128] = address(ext_call.return_data[0])
            mem[160] = address(ext_call.return_data[0])
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args 0x6f8ed60393ac6a4b16900273c9313222dfe9940, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[196] = arg2
            mem[228] = 64
            mem[260] = 2
            mem[292 len 0] = None
            require ext_code.size(0x60ae616a2155ee3d9a68541ba4544862310933d4)
            staticcall 0x60ae616a2155ee3d9a68541ba4544862310933d4.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg2, Array(len=2, data=mem[292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 192
            require return_data.size >= 32
            if not arg2:
                if not arg2:
                    if not arg2:
                        _1877 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1949 = mem[_1877 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1877 + 192])] = mem[_1877 + 224 len floor32(mem[_1877 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3333 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1949) + ceil32(return_data.size) + 260] = _3333
                        mem[(32 * _1949) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1949) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3333, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4533 = mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1949) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1949) + ceil32(return_data.size) + 224]
                        mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])] = mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 256 len floor32(mem[_4533 + (32 * _1949) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] <= _3333:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3333
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3333 > mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1949) + (2 * ceil32(return_data.size)) + 288] - _3333
                    else:
                        _1879 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1950 = mem[_1879 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1879 + 192])] = mem[_1879 + 224 len floor32(mem[_1879 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3337 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1950) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1950) + ceil32(return_data.size) + 260] = _3337
                        mem[(32 * _1950) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1950) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1950) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1950) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1950) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3337, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1950) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4535 = mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1950) + ceil32(return_data.size) + 224]
                        mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])] = mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 256 len floor32(mem[_4535 + (32 * _1950) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] <= _3337:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3337
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3337 > mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 288] - _3337
                else:
                    if not arg2:
                        _1881 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1951 = mem[_1881 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1881 + 192])] = mem[_1881 + 224 len floor32(mem[_1881 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3341 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1951) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1951) + ceil32(return_data.size) + 260] = _3341
                        mem[(32 * _1951) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1951) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1951) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1951) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1951) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3341, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1951) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4537 = mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1951) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1951) + ceil32(return_data.size) + 224]
                        mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])] = mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 256 len floor32(mem[_4537 + (32 * _1951) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] <= _3341:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3341
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3341 > mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1951) + (2 * ceil32(return_data.size)) + 288] - _3341
                    else:
                        _1883 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1952 = mem[_1883 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1883 + 192])] = mem[_1883 + 224 len floor32(mem[_1883 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3345 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1952) + ceil32(return_data.size) + 260] = _3345
                        mem[(32 * _1952) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1952) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3345, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4539 = mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1952) + ceil32(return_data.size) + 224]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])] = mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 256 len floor32(mem[_4539 + (32 * _1952) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] <= _3345:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3345
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3345 > mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 288] - _3345
            else:
                if not arg2:
                    if not arg2:
                        _1885 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1953 = mem[_1885 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1885 + 192])] = mem[_1885 + 224 len floor32(mem[_1885 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3349 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1953) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1953) + ceil32(return_data.size) + 260] = _3349
                        mem[(32 * _1953) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1953) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1953) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1953) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1953) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3349, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1953) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4541 = mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1953) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1953) + ceil32(return_data.size) + 224]
                        mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])] = mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 256 len floor32(mem[_4541 + (32 * _1953) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] <= _3349:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3349
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3349 > mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1953) + (2 * ceil32(return_data.size)) + 288] - _3349
                    else:
                        _1887 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1954 = mem[_1887 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1887 + 192])] = mem[_1887 + 224 len floor32(mem[_1887 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3353 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1954) + ceil32(return_data.size) + 260] = _3353
                        mem[(32 * _1954) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1954) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3353, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4543 = mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1954) + ceil32(return_data.size) + 224]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])] = mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 256 len floor32(mem[_4543 + (32 * _1954) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] <= _3353:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3353
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3353 > mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 288] - _3353
                else:
                    if not arg2:
                        _1889 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1955 = mem[_1889 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1889 + 192])] = mem[_1889 + 224 len floor32(mem[_1889 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3357 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1955) + ceil32(return_data.size) + 260] = _3357
                        mem[(32 * _1955) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1955) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3357, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4545 = mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1955) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1955) + ceil32(return_data.size) + 224]
                        mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])] = mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 256 len floor32(mem[_4545 + (32 * _1955) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] <= _3357:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3357
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3357 > mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1955) + (2 * ceil32(return_data.size)) + 288] - _3357
                    else:
                        _1891 = mem[192 len 4], Mask(224, 32, arg2) >> 32
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[192 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192] <= 4294967296 and mem[192 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg2) >> 32 + 192]
                        _1956 = mem[_1891 + 192]
                        mem[ceil32(return_data.size) + 224 len floor32(mem[_1891 + 192])] = mem[_1891 + 224 len floor32(mem[_1891 + 192])]
                        require 0 < mem[ceil32(return_data.size) + 192]
                        _3361 = mem[ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1956) + ceil32(return_data.size) + 228] = arg2
                        mem[(32 * _1956) + ceil32(return_data.size) + 260] = _3361
                        mem[(32 * _1956) + ceil32(return_data.size) + 324] = msg.sender
                        mem[(32 * _1956) + ceil32(return_data.size) + 356] = block.timestamp
                        mem[(32 * _1956) + ceil32(return_data.size) + 292] = 160
                        mem[(32 * _1956) + ceil32(return_data.size) + 388] = 2
                        mem[(32 * _1956) + ceil32(return_data.size) + 420 len 0] = None
                        require ext_code.size(0x6f8ed60393ac6a4b16900273c9313222dfe9940)
                        call 0x06f8ed60393ac6a4b16900273c9313222dfe9940.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg2, _3361, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 420 len 64]), msg.sender, block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1956) + ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _4547 = mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 <= 4294967296
                        require mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]) + 32 <= return_data.size
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg2) >> 32 + (32 * _1956) + ceil32(return_data.size) + 224]
                        mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])] = mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 256 len floor32(mem[_4547 + (32 * _1956) + ceil32(return_data.size) + 224])]
                        require 1 < mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 224]
                        if mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] <= _3361:
                            revert with 0, 'Not enough tokens!'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _3361
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if _3361 > mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args stor0, mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 288] - _3361
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - deposit(uint256 arg1, uint256 arg2, uint256 arg3)
#  - pendingSushi(uint256 arg1, address arg2)
#  - withdrawNFT(uint256 arg1, uint256 arg2)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - sub_9ca2cb1a(?)
#
address owner;
address WETHAddress;
address sushiAddress;
address devaddr;
uint256 bonusEndBlock;
uint256 sushiPerBlock;
uint32 stor6;
address migratorAddress;
uint256 stor6;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 sub_9e98edc6;
uint256 sub_e600038d;
uint256 sub_a054b70a;
uint256 BLOCKS_PER_YEAR;
uint256 startBlock;
address sub_ae46f614Address;

function poolLength() {
    return poolInfo.length
}

function sushi() {
    return sushiAddress
}

function poolInfo(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           bool(poolInfo[arg1].field_768),
           poolInfo[arg1].field_1024,
           poolInfo[arg1].field_1280,
           poolInfo[arg1].field_1536
}

function totalAllocPoint() {
    return totalAllocPoint
}

function bonusEndBlock() {
    return bonusEndBlock
}

function startBlock() {
    return startBlock
}

function migrator() {
    return address(migratorAddress)
}

function owner() {
    return owner
}

function userInfo(uint256 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, 
           userInfo[arg1][arg2].field_256,
           userInfo[arg1][arg2].field_512,
           userInfo[arg1][arg2].field_768
}

function sub_9e98edc6(?) {
    return sub_9e98edc6
}

function sub_a054b70a(?) {
    return sub_a054b70a
}

function WETH() {
    return WETHAddress
}

function sub_ae46f614(?) {
    return sub_ae46f614Address
}

function sushiPerBlock() {
    return sushiPerBlock
}

function BLOCKS_PER_YEAR() {
    return BLOCKS_PER_YEAR
}

function devaddr() {
    return devaddr
}

function sub_e600038d(?) {
    return sub_e600038d
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function dev(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if devaddr != msg.sender:
        revert with 0, 'dev: wut?'
    devaddr = arg1
}

function _setMigrator(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        if devaddr != msg.sender:
            revert with 0, '!dev addr'
    address(migratorAddress) = arg1
}

function getTimeMultiplex(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        return 100
    if arg1 <= 168 * 24 * 3600:
        return 120
    if arg1 <= 336 * 24 * 3600:
        return 140
    if arg1 > 720 * 24 * 3600:
        return 200
    return 160
}

function formatDuration(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        return 0
    if arg1 <= 168 * 24 * 3600:
        return (168 * 24 * 3600)
    if arg1 <= 336 * 24 * 3600:
        return (336 * 24 * 3600)
    if arg1 > 720 * 24 * 3600:
        return (4320 * 24 * 3600)
    return (720 * 24 * 3600)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000
}

function initialize(address arg1, address arg2, address arg3, uint256 arg4, uint256 arg5, uint256 arg6) {
    require calldata.size - 4 >= 192
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    require arg6 == arg6
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sushiAddress = arg1
    devaddr = arg2
    WETHAddress = arg3
    sushiPerBlock = arg4
    startBlock = arg5
    bonusEndBlock = arg6
    create contract with 0 wei
                    code: code.data[21465 len 1116]
    if not create.new_address:
        revert with ext_call.return_data[0 len return_data.size]
    sub_ae46f614Address = address(create.new_address)
}

function _migrate(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not address(migratorAddress):
        revert with 0, 'migrate: no migrator'
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    mem[100] = this.address
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 0, stor6)
    mem[ceil32(return_data.size) + 128 len 4] = approve(address arg1, uint256 arg2)
    if ext_call.return_data[0] <= 0:
        mem[ceil32(return_data.size) + 196 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor6), uint32(stor6), ext_call.return_data[0], mem[ceil32(return_data.size) + 196 len 28]
        call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + 196 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(return_data.size) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
        else:
            mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
                if not mem[ceil32(return_data.size) + 228]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
    else:
        mem[ceil32(return_data.size) + 196 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor6), uint32(stor6), 0, mem[ceil32(return_data.size) + 196 len 28]
        call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + 196 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(return_data.size) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
            mem[ceil32(return_data.size) + 296 len 96] = 0, address(migratorAddress), ext_call.return_data[0], mem[ceil32(return_data.size) + 296 len 28]
            call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + 296 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(return_data.size) + 300 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
            else:
                mem[ceil32(return_data.size) + 328 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[ceil32(return_data.size) + 328] == bool(mem[ceil32(return_data.size) + 328])
                    if not mem[ceil32(return_data.size) + 328]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
        else:
            mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
                if not mem[ceil32(return_data.size) + 228]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
            mem[ceil32(return_data.size) + ceil32(return_data.size) + 297 len 96] = 0, address(migratorAddress), ext_call.return_data[0], mem[ceil32(return_data.size) + ceil32(return_data.size) + 297 len 28]
            call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + ceil32(return_data.size) + 297 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(return_data.size) + ceil32(return_data.size) + 301 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
            else:
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 329 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] == bool(mem[ceil32(return_data.size) + ceil32(return_data.size) + 329])
                    if not mem[ceil32(return_data.size) + ceil32(return_data.size) + 329]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
    require ext_code.size(address(migratorAddress))
    call address(migratorAddress).migrate(address arg1) with:
         gas gas_remaining wei
        args poolInfo[arg1].field_0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] != ext_call.return_data[0]:
        revert with 0, 'migrate: bad'
    poolInfo[arg1].field_0 = address(ext_call.return_data[0])
}

function sub_0805d884(?) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    if not sushiPerBlock:
        if poolInfo[arg1].field_768:
            if block.number <= bonusEndBlock:
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return (0 / sub_9e98edc6)
            if poolInfo[arg1].field_768:
                if block.number > bonusEndBlock:
                    if 100 < sub_a054b70a:
                        revert with 'NH{q', 17
                    if sub_9e98edc6 <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    return (0 / sub_9e98edc6)
                if poolInfo[arg1].field_768:
                    return 0
        if block.number > bonusEndBlock:
            if poolInfo[arg1].field_768:
                return 0
            if block.number <= bonusEndBlock:
                return 0
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (0 / totalAllocPoint)
    if sushiPerBlock and BLOCKS_PER_YEAR > -1 / sushiPerBlock:
        revert with 'NH{q', 17
    if not sushiPerBlock:
        revert with 'NH{q', 18
    if sushiPerBlock * BLOCKS_PER_YEAR / sushiPerBlock != BLOCKS_PER_YEAR:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not sushiPerBlock * BLOCKS_PER_YEAR:
        if poolInfo[arg1].field_768:
            if block.number <= bonusEndBlock:
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return (0 / sub_9e98edc6)
            if poolInfo[arg1].field_768:
                if block.number > bonusEndBlock:
                    if 100 < sub_a054b70a:
                        revert with 'NH{q', 17
                    if sub_9e98edc6 <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    return (0 / sub_9e98edc6)
                if poolInfo[arg1].field_768:
                    return 0
        if block.number > bonusEndBlock:
            if poolInfo[arg1].field_768:
                return 0
            if block.number <= bonusEndBlock:
                return 0
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (0 / totalAllocPoint)
    if sushiPerBlock * BLOCKS_PER_YEAR and poolInfo[arg1].field_256 > -1 / sushiPerBlock * BLOCKS_PER_YEAR:
        revert with 'NH{q', 17
    if not sushiPerBlock * BLOCKS_PER_YEAR:
        revert with 'NH{q', 18
    if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / sushiPerBlock * BLOCKS_PER_YEAR != poolInfo[arg1].field_256:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if poolInfo[arg1].field_768:
        if block.number <= bonusEndBlock:
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return (0 / sub_9e98edc6)
            if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and -sub_e600038d + 100 > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                revert with 'NH{q', 17
            if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                revert with 'NH{q', 18
            if (100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_e600038d * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            if sub_9e98edc6 <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            return ((100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_e600038d * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sub_9e98edc6)
        if poolInfo[arg1].field_768:
            if block.number > bonusEndBlock:
                if 100 < sub_a054b70a:
                    revert with 'NH{q', 17
                if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                    if sub_9e98edc6 <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    return (0 / sub_9e98edc6)
                if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and -sub_a054b70a + 100 > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                    revert with 'NH{q', 17
                if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                    revert with 'NH{q', 18
                if (100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_a054b70a * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != -sub_a054b70a + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return ((100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_a054b70a * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sub_9e98edc6)
            if poolInfo[arg1].field_768:
                return 0
    if block.number <= bonusEndBlock:
        if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalAllocPoint:
                revert with 'NH{q', 18
            return (0 / totalAllocPoint)
        if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and sub_e600038d > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
            revert with 'NH{q', 17
        if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
            revert with 'NH{q', 18
        if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_e600038d / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != sub_e600038d:
            revert with 0, 'SafeMath: multiplication overflow'
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_e600038d / totalAllocPoint)
    if poolInfo[arg1].field_768:
        return 0
    if block.number <= bonusEndBlock:
        return 0
    if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (0 / totalAllocPoint)
    if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and sub_a054b70a > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
        revert with 'NH{q', 17
    if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
        revert with 'NH{q', 18
    if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_a054b70a / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != sub_a054b70a:
        revert with 0, 'SafeMath: multiplication overflow'
    if totalAllocPoint <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalAllocPoint:
        revert with 'NH{q', 18
    return (sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_a054b70a / totalAllocPoint)
}

function sub_b1c1dc60(?) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == bool(arg3)
    if arg2 <= bonusEndBlock:
        if not arg3:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg2 < arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                return 0
            if arg2 - arg1 and sub_e600038d > -1 / arg2 - arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                revert with 'NH{q', 18
            if (arg2 * sub_e600038d) - (arg1 * sub_e600038d) / arg2 - arg1 != sub_e600038d:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((arg2 * sub_e600038d) - (arg1 * sub_e600038d) / 100)
        if 100 < sub_e600038d:
            revert with 'NH{q', 17
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            return 0
        if arg2 - arg1 and -sub_e600038d + 100 > -1 / arg2 - arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            revert with 'NH{q', 18
        if (100 * arg2) - (sub_e600038d * arg2) - (100 * arg1) + (sub_e600038d * arg1) / arg2 - arg1 != -sub_e600038d + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        return ((100 * arg2) - (sub_e600038d * arg2) - (100 * arg1) + (sub_e600038d * arg1) / 100)
    if arg1 >= bonusEndBlock:
        if not arg3:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg2 < arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                return 0
            if arg2 - arg1 and sub_a054b70a > -1 / arg2 - arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                revert with 'NH{q', 18
            if (arg2 * sub_a054b70a) - (arg1 * sub_a054b70a) / arg2 - arg1 != sub_a054b70a:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((arg2 * sub_a054b70a) - (arg1 * sub_a054b70a) / 100)
        if 100 < sub_a054b70a:
            revert with 'NH{q', 17
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            return 0
        if arg2 - arg1 and -sub_a054b70a + 100 > -1 / arg2 - arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            revert with 'NH{q', 18
        if (100 * arg2) - (sub_a054b70a * arg2) - (100 * arg1) + (sub_a054b70a * arg1) / arg2 - arg1 != -sub_a054b70a + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        return ((100 * arg2) - (sub_a054b70a * arg2) - (100 * arg1) + (sub_a054b70a * arg1) / 100)
    if not arg3:
        if bonusEndBlock > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < bonusEndBlock:
            revert with 'NH{q', 17
        if not arg2 - bonusEndBlock:
            if arg1 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if bonusEndBlock < arg1:
                revert with 'NH{q', 17
            if not bonusEndBlock - arg1:
                return 0
            if bonusEndBlock - arg1 and sub_e600038d > -1 / bonusEndBlock - arg1:
                revert with 'NH{q', 17
            if not bonusEndBlock - arg1:
                revert with 'NH{q', 18
            if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / bonusEndBlock - arg1 != sub_e600038d:
                revert with 0, 'SafeMath: multiplication overflow'
            if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100 > -1:
                revert with 'NH{q', 17
            if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100:
                revert with 0, 'SafeMath: addition overflow'
            return ((bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100)
        if arg2 - bonusEndBlock and sub_a054b70a > -1 / arg2 - bonusEndBlock:
            revert with 'NH{q', 17
        if not arg2 - bonusEndBlock:
            revert with 'NH{q', 18
        if (arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / arg2 - bonusEndBlock != sub_a054b70a:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if bonusEndBlock < arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            if 0 > -((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                revert with 'NH{q', 17
            if (arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100)
        if bonusEndBlock - arg1 and sub_e600038d > -1 / bonusEndBlock - arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            revert with 'NH{q', 18
        if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / bonusEndBlock - arg1 != sub_e600038d:
            revert with 0, 'SafeMath: multiplication overflow'
        if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100 > -((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
            revert with 'NH{q', 17
        if ((bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100) + ((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100:
            revert with 0, 'SafeMath: addition overflow'
        return (((bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100) + ((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100))
    if 100 < sub_a054b70a:
        revert with 'NH{q', 17
    if bonusEndBlock > arg2:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg2 < bonusEndBlock:
        revert with 'NH{q', 17
    if not arg2 - bonusEndBlock:
        if 100 < sub_e600038d:
            revert with 'NH{q', 17
        if arg1 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if bonusEndBlock < arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            return 0
        if bonusEndBlock - arg1 and -sub_e600038d + 100 > -1 / bonusEndBlock - arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            revert with 'NH{q', 18
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / bonusEndBlock - arg1 != -sub_e600038d + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100 > -1:
            revert with 'NH{q', 17
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100:
            revert with 0, 'SafeMath: addition overflow'
        return ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100)
    if arg2 - bonusEndBlock and -sub_a054b70a + 100 > -1 / arg2 - bonusEndBlock:
        revert with 'NH{q', 17
    if not arg2 - bonusEndBlock:
        revert with 'NH{q', 18
    if (100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / arg2 - bonusEndBlock != -sub_a054b70a + 100:
        revert with 0, 'SafeMath: multiplication overflow'
    if 100 < sub_e600038d:
        revert with 'NH{q', 17
    if arg1 > bonusEndBlock:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if bonusEndBlock < arg1:
        revert with 'NH{q', 17
    if not bonusEndBlock - arg1:
        if 0 > -((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
            revert with 'NH{q', 17
        if (100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100)
    if bonusEndBlock - arg1 and -sub_e600038d + 100 > -1 / bonusEndBlock - arg1:
        revert with 'NH{q', 17
    if not bonusEndBlock - arg1:
        revert with 'NH{q', 18
    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / bonusEndBlock - arg1 != -sub_e600038d + 100:
        revert with 0, 'SafeMath: multiplication overflow'
    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100 > -((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
        revert with 'NH{q', 17
    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100) + ((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100:
        revert with 0, 'SafeMath: addition overflow'
    return (((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100) + ((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100))
}

function updatePool(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    if block.number > poolInfo[arg1].field_1280:
        if poolInfo[arg1].field_512:
            if block.number <= bonusEndBlock:
                if not poolInfo[arg1].field_768:
                    if poolInfo[arg1].field_1280 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.number < poolInfo[arg1].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[arg1].field_1280:
                        if not poolInfo[arg1].field_768:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / totalAllocPoint), this.address);
                                if not 0 / totalAllocPoint:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                        revert with 'NH{q', 17
                                    if not 0 / totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if sub_9e98edc6 <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not sub_9e98edc6:
                                revert with 'NH{q', 18
                            if not 0 / sub_9e98edc6:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / sub_9e98edc6
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / sub_9e98edc6), this.address);
                                if not 0 / sub_9e98edc6:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                        revert with 'NH{q', 17
                                    if not 0 / sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                    else:
                        if block.number - poolInfo[arg1].field_1280 and sub_e600038d > -1 / block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 18
                        if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / block.number - poolInfo[arg1].field_1280 != sub_e600038d:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                            if not poolInfo[arg1].field_768:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if sub_9e98edc6 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not sub_9e98edc6:
                                    revert with 'NH{q', 18
                                if not 0 / sub_9e98edc6:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / sub_9e98edc6
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / sub_9e98edc6), this.address);
                                    if not 0 / sub_9e98edc6:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                            revert with 'NH{q', 17
                                        if not 0 / sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                        else:
                            if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                revert with 'NH{q', 17
                            if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                revert with 'NH{q', 18
                            if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not 0 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / sub_9e98edc6), this.address);
                                        if not 0 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not 0 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 17
                                if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 18
                                if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint(((block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                        if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint(((block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                        if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
                else:
                    if 100 < sub_e600038d:
                        revert with 'NH{q', 17
                    if poolInfo[arg1].field_1280 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.number < poolInfo[arg1].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[arg1].field_1280:
                        if not poolInfo[arg1].field_768:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / totalAllocPoint), this.address);
                                if not 0 / totalAllocPoint:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                        revert with 'NH{q', 17
                                    if not 0 / totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if sub_9e98edc6 <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not sub_9e98edc6:
                                revert with 'NH{q', 18
                            if not 0 / sub_9e98edc6:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / sub_9e98edc6
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / sub_9e98edc6), this.address);
                                if not 0 / sub_9e98edc6:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                        revert with 'NH{q', 17
                                    if not 0 / sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                    else:
                        if block.number - poolInfo[arg1].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 18
                        if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / block.number - poolInfo[arg1].field_1280 != -sub_e600038d + 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                            if not poolInfo[arg1].field_768:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if sub_9e98edc6 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not sub_9e98edc6:
                                    revert with 'NH{q', 18
                                if not 0 / sub_9e98edc6:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / sub_9e98edc6
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / sub_9e98edc6), this.address);
                                    if not 0 / sub_9e98edc6:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                            revert with 'NH{q', 17
                                        if not 0 / sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                        else:
                            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                revert with 'NH{q', 17
                            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                revert with 'NH{q', 18
                            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 != sushiPerBlock:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not 0 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / sub_9e98edc6), this.address);
                                        if not 0 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not 0 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 17
                                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 18
                                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                        if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                        if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
            else:
                if poolInfo[arg1].field_1280 >= bonusEndBlock:
                    if not poolInfo[arg1].field_768:
                        if poolInfo[arg1].field_1280 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            if not poolInfo[arg1].field_768:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if sub_9e98edc6 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not sub_9e98edc6:
                                    revert with 'NH{q', 18
                                if not 0 / sub_9e98edc6:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / sub_9e98edc6
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / sub_9e98edc6), this.address);
                                    if not 0 / sub_9e98edc6:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                            revert with 'NH{q', 17
                                        if not 0 / sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                        else:
                            if block.number - poolInfo[arg1].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 18
                            if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / block.number - poolInfo[arg1].field_1280 != sub_a054b70a:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100:
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not 0 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / sub_9e98edc6), this.address);
                                        if not 0 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not 0 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100:
                                    revert with 'NH{q', 17
                                if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100:
                                    revert with 'NH{q', 18
                                if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 17
                                    if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 18
                                    if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                            if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                            if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
                    else:
                        if 100 < sub_a054b70a:
                            revert with 'NH{q', 17
                        if poolInfo[arg1].field_1280 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            if not poolInfo[arg1].field_768:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if sub_9e98edc6 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not sub_9e98edc6:
                                    revert with 'NH{q', 18
                                if not 0 / sub_9e98edc6:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / sub_9e98edc6
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / sub_9e98edc6), this.address);
                                    if not 0 / sub_9e98edc6:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                            revert with 'NH{q', 17
                                        if not 0 / sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                        else:
                            if block.number - poolInfo[arg1].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 18
                            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / block.number - poolInfo[arg1].field_1280 != -sub_a054b70a + 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100:
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not 0 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / sub_9e98edc6), this.address);
                                        if not 0 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not 0 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100:
                                    revert with 'NH{q', 17
                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100:
                                    revert with 'NH{q', 18
                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 != sushiPerBlock:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 17
                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 18
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
                else:
                    if not poolInfo[arg1].field_768:
                        if bonusEndBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < bonusEndBlock:
                            revert with 'NH{q', 17
                        if not block.number - bonusEndBlock:
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not 0 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / sub_9e98edc6), this.address);
                                        if not 0 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not 0 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[arg1].field_1280 != sub_e600038d:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 > -1:
                                    revert with 'NH{q', 17
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                        revert with 'NH{q', 17
                                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                        revert with 'NH{q', 18
                                    if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not 0 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / totalAllocPoint), this.address);
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not 0 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not 0 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / sub_9e98edc6), this.address);
                                                if not 0 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                    else:
                                        if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                                if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                                if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
                        else:
                            if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                                revert with 'NH{q', 17
                            if not block.number - bonusEndBlock:
                                revert with 'NH{q', 18
                            if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                                    revert with 'NH{q', 17
                                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                                        revert with 'NH{q', 17
                                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                                        revert with 'NH{q', 18
                                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not 0 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / totalAllocPoint), this.address);
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not 0 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not 0 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / sub_9e98edc6), this.address);
                                                if not 0 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                    else:
                                        if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[arg1].field_1280 != sub_e600038d:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                                    revert with 'NH{q', 17
                                if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                                        revert with 'NH{q', 17
                                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                                        revert with 'NH{q', 18
                                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not 0 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / totalAllocPoint), this.address);
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not 0 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not 0 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / sub_9e98edc6), this.address);
                                                if not 0 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                    else:
                                        if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[arg1].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 17
                                        if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 18
                                        if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint), this.address);
                                                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6), this.address);
                                                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / poolInfo[arg1].field_512
                    else:
                        if 100 < sub_a054b70a:
                            revert with 'NH{q', 17
                        if bonusEndBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < bonusEndBlock:
                            revert with 'NH{q', 17
                        if not block.number - bonusEndBlock:
                            if 100 < sub_e600038d:
                                revert with 'NH{q', 17
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if not poolInfo[arg1].field_768:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if sub_9e98edc6 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not sub_9e98edc6:
                                        revert with 'NH{q', 18
                                    if not 0 / sub_9e98edc6:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / sub_9e98edc6
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / sub_9e98edc6), this.address);
                                        if not 0 / sub_9e98edc6:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                revert with 'NH{q', 17
                                            if not 0 / sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / bonusEndBlock - poolInfo[arg1].field_1280 != -sub_e600038d + 100:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 > -1:
                                    revert with 'NH{q', 17
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                        revert with 'NH{q', 17
                                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                        revert with 'NH{q', 18
                                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not 0 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / totalAllocPoint), this.address);
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not 0 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not 0 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / sub_9e98edc6), this.address);
                                                if not 0 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                    else:
                                        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
                        else:
                            if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
                                revert with 'NH{q', 17
                            if not block.number - bonusEndBlock:
                                revert with 'NH{q', 18
                            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 100 < sub_e600038d:
                                revert with 'NH{q', 17
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                                    revert with 'NH{q', 17
                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                                        revert with 'NH{q', 17
                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                                        revert with 'NH{q', 18
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not 0 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / totalAllocPoint), this.address);
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not 0 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not 0 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / sub_9e98edc6), this.address);
                                                if not 0 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                    else:
                                        if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6), this.address);
                                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / sub_9e98edc6 / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / bonusEndBlock - poolInfo[arg1].field_1280 != -sub_e600038d + 100:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                                    revert with 'NH{q', 17
                                if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                                    if not poolInfo[arg1].field_768:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if sub_9e98edc6 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not sub_9e98edc6:
                                            revert with 'NH{q', 18
                                        if not 0 / sub_9e98edc6:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / sub_9e98edc6
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / sub_9e98edc6), this.address);
                                            if not 0 / sub_9e98edc6:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 17
                                                if not 0 / sub_9e98edc6:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                else:
                                    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                                        revert with 'NH{q', 17
                                    if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                                        revert with 'NH{q', 18
                                    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not 0 / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / totalAllocPoint), this.address);
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not 0 / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not 0 / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), 0 / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((0 / sub_9e98edc6), this.address);
                                                if not 0 / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not 0 / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[arg1].field_512
                                    else:
                                        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[arg1].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 17
                                        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 18
                                        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not poolInfo[arg1].field_768:
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint), this.address);
                                                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        revert with 'NH{q', 17
                                                    if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512
                                        else:
                                            if sub_9e98edc6 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not sub_9e98edc6:
                                                revert with 'NH{q', 18
                                            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                emit Mint(0, this.address);
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                require ext_code.size(sushiAddress)
                                                call sushiAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6), this.address);
                                                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                                else:
                                                    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                        revert with 'NH{q', 17
                                                    if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6:
                                                        revert with 'NH{q', 18
                                                    if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 != 10^12:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if poolInfo[arg1].field_512 <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    if not poolInfo[arg1].field_512:
                                                        revert with 'NH{q', 18
                                                    if poolInfo[arg1].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / poolInfo[arg1].field_512) - 1:
                                                        revert with 'NH{q', 17
                                                    if poolInfo[arg1].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / sub_9e98edc6 / poolInfo[arg1].field_512
        poolInfo[arg1].field_1280 = block.number
}

function massUpdatePools() payable {
    mem[64] = 96
    require not msg.value
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 7
        if block.number <= poolInfo[idx].field_1280:
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_512:
            poolInfo[idx].field_1280 = block.number
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        if block.number <= bonusEndBlock:
            if not poolInfo[idx].field_768:
                _2635 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2635] = 30
                mem[_2635 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _2638 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2638 + idx + 68] = mem[_2635 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2638 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2638 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _2656 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2656] = 26
                    mem[_2656 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _2695 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2695] = 26
                        mem[_2695 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2700 + idx + 68] = mem[_2695 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2700 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2700 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2834 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2834] = 26
                            mem[_2834 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2853 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2853 + idx + 68] = mem[_2834 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2853 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2853 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2955 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2955] = 26
                            mem[_2955 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2978 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2978 + idx + 68] = mem[_2955 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2978 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2978 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3178 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3178] = 26
                        mem[_3178 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3212 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3212 + idx + 68] = mem[_3178 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3212 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3212 + -mem[64] + 100
                    _2696 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2696] = 26
                    mem[_2696 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2701 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2701 + idx + 68] = mem[_2696 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2701 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2701 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2835 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2835] = 26
                        mem[_2835 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2854 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2854 + idx + 68] = mem[_2835 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2854 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2854 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2956 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2956] = 26
                        mem[_2956 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2979 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2979 + idx + 68] = mem[_2956 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2979 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2979 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3179 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3179] = 26
                    mem[_3179 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3214 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3214 + idx + 68] = mem[_3179 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3214 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3214 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and sub_e600038d > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / block.number - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2682 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2682] = 26
                mem[_2682 + 32] = 'SafeMath: division by zero'
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    if not poolInfo[idx].field_768:
                        _2745 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2745] = 26
                        mem[_2745 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2750 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2750 + idx + 68] = mem[_2745 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2750 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2750 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2990 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2990] = 26
                            mem[_2990 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3006 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3006 + idx + 68] = mem[_2990 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3006 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3006 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3176 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3176] = 26
                            mem[_3176 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3210 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3210 + idx + 68] = mem[_3176 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3210 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3210 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3492 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3492] = 26
                        mem[_3492 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3528 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3528 + idx + 68] = mem[_3492 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3528 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3528 + -mem[64] + 100
                    _2746 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2746] = 26
                    mem[_2746 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2751 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2751 + idx + 68] = mem[_2746 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2751 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2751 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2991 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2991] = 26
                        mem[_2991 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3007 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3007 + idx + 68] = mem[_2991 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3007 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3007 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3177] = 26
                        mem[_3177 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3211 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3211 + idx + 68] = mem[_3177 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3211 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3211 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3493 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3493] = 26
                    mem[_3493 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3530 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3530 + idx + 68] = mem[_3493 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3530 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3530 + -mem[64] + 100
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 17
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 18
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2849] = 26
                        mem[_2849 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2858 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2858 + idx + 68] = mem[_2849 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2858 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2858 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3232 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3232] = 26
                            mem[_3232 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3266 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3266 + idx + 68] = mem[_3232 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3266 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3266 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3490] = 26
                            mem[_3490 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3526 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3526 + idx + 68] = mem[_3490 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3526 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3526 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3861 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3861] = 26
                        mem[_3861 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3907 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3907 + idx + 68] = mem[_3861 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3907 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3907 + -mem[64] + 100
                    _2850 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2850] = 26
                    mem[_2850 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2859 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2859 + idx + 68] = mem[_2850 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2859 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2859 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3233 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3233] = 26
                        mem[_3233 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3267 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3267 + idx + 68] = mem[_3233 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3267 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3267 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3491 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3491] = 26
                        mem[_3491 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3527 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3527 + idx + 68] = mem[_3491 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3527 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3527 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3862 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3862] = 26
                    mem[_3862 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3909 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3909 + idx + 68] = mem[_3862 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3909 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3909 + -mem[64] + 100
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3002 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3002] = 26
                    mem[_3002 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3021 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3021 + idx + 68] = mem[_3002 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3021 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3021 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3550] = 26
                        mem[_3550 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3596 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3596 + idx + 68] = mem[_3550 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3596 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3596 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _3859 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3859] = 26
                        mem[_3859 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3905 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3905 + idx + 68] = mem[_3859 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3905 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3905 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4263 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4263] = 26
                    mem[_4263 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4309 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4309 + idx + 68] = mem[_4263 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4309 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4309 + -mem[64] + 100
                _3003 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3003] = 26
                mem[_3003 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3022 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3022 + idx + 68] = mem[_3003 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3022 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3022 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3551 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3551] = 26
                    mem[_3551 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3597 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3597 + idx + 68] = mem[_3551 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3597 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3597 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _3860 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3860] = 26
                    mem[_3860 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3906 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3906 + idx + 68] = mem[_3860 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3906 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3906 + -mem[64] + 100
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4264 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4264] = 26
                mem[_4264 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4311 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4311 + idx + 68] = mem[_4264 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4311 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4311 + -mem[64] + 100
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _2644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2644] = 30
            mem[_2644 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > block.number:
                _2647 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2647 + idx + 68] = mem[_2644 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2647 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2647 + -mem[64] + 100
            if block.number < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                _2668 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2668] = 26
                mem[_2668 + 32] = 'SafeMath: division by zero'
                if not poolInfo[idx].field_768:
                    _2717 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2717] = 26
                    mem[_2717 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2723 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2723 + idx + 68] = mem[_2717 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2723 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2723 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2905 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2905] = 26
                        mem[_2905 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2923 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2923 + idx + 68] = mem[_2905 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2923 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2923 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _3046 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3046] = 26
                        mem[_3046 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3076 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3076 + idx + 68] = mem[_3046 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3076 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3076 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3311 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3311] = 26
                    mem[_3311 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3347 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3347 + idx + 68] = mem[_3311 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3347 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3347 + -mem[64] + 100
                _2718 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2718] = 26
                mem[_2718 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2724 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2724 + idx + 68] = mem[_2718 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2724 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2724 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2906 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2906] = 26
                    mem[_2906 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2924 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2924 + idx + 68] = mem[_2906 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2924 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2924 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _3047 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3047] = 26
                    mem[_3047 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3077 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3077 + idx + 68] = mem[_3047 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3077 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3077 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3312 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3312] = 26
                mem[_3312 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3349 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3349 + idx + 68] = mem[_3312 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3349 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3349 + -mem[64] + 100
            if block.number - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _2692 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2692] = 26
            mem[_2692 + 32] = 'SafeMath: division by zero'
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                if not poolInfo[idx].field_768:
                    _2790 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2790] = 26
                    mem[_2790 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2800 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2800 + idx + 68] = mem[_2790 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2800 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2800 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3088] = 26
                        mem[_3088 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3117 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3117 + idx + 68] = mem[_3088 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3117 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3117 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _3309 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3309] = 26
                        mem[_3309 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3345 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3345 + idx + 68] = mem[_3309 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3345 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3345 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3636 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3636] = 26
                    mem[_3636 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3682 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3682 + idx + 68] = mem[_3636 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3682 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3682 + -mem[64] + 100
                _2791 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2791] = 26
                mem[_2791 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2801 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2801 + idx + 68] = mem[_2791 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2801 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2801 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3089 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3089] = 26
                    mem[_3089 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3118 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3118 + idx + 68] = mem[_3089 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3118 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3118 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _3310 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3310] = 26
                    mem[_3310 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3346 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3346 + idx + 68] = mem[_3310 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3346 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3346 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3637 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3637] = 26
                mem[_3637 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3684 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3684 + idx + 68] = mem[_3637 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3684 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3684 + -mem[64] + 100
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                if not poolInfo[idx].field_768:
                    _2916 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2916] = 26
                    mem[_2916 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2930 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2930 + idx + 68] = mem[_2916 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2930 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2930 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3363] = 26
                        mem[_3363 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3419 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3419 + idx + 68] = mem[_3363 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3419 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3419 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _3634 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3634] = 26
                        mem[_3634 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3680 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3680 + idx + 68] = mem[_3634 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3680 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3680 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4010 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4010] = 26
                    mem[_4010 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4061 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4061 + idx + 68] = mem[_4010 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4061 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4061 + -mem[64] + 100
                _2917 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2917] = 26
                mem[_2917 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2931 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2931 + idx + 68] = mem[_2917 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2931 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2931 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3364 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3364] = 26
                    mem[_3364 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3420 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3420 + idx + 68] = mem[_3364 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3420 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3420 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _3635 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3635] = 26
                    mem[_3635 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3681 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3681 + idx + 68] = mem[_3635 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3681 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3681 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4011 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4011] = 26
                mem[_4011 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4063 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4063 + idx + 68] = mem[_4011 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4063 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4063 + -mem[64] + 100
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            if not poolInfo[idx].field_768:
                _3100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3100] = 26
                mem[_3100 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _3135 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3135 + idx + 68] = mem[_3100 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3135 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3135 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3702 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3702] = 26
                    mem[_3702 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3775 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3775 + idx + 68] = mem[_3702 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3775 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3775 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _4008 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4008] = 26
                    mem[_4008 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4059 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4059 + idx + 68] = mem[_4008 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4059 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4059 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4405 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4405] = 26
                mem[_4405 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4456 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4456 + idx + 68] = mem[_4405 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4456 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4456 + -mem[64] + 100
            _3101 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3101] = 26
            mem[_3101 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _3136 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3136 + idx + 68] = mem[_3101 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3136 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3136 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _3703 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3703] = 26
                mem[_3703 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3776 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3776 + idx + 68] = mem[_3703 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3776 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3776 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                _4009 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4009] = 26
                mem[_4009 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4060 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4060 + idx + 68] = mem[_4009 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4060 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4060 + -mem[64] + 100
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _4406 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4406] = 26
            mem[_4406 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _4458 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4458 + idx + 68] = mem[_4406 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4458 + 94] = 0
            revert with memory
              from mem[64]
               len _4458 + -mem[64] + 100
        if poolInfo[idx].field_1280 >= bonusEndBlock:
            if not poolInfo[idx].field_768:
                _2637 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2637] = 30
                mem[_2637 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _2640 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2640 + idx + 68] = mem[_2637 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2640 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2640 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _2658 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2658] = 26
                    mem[_2658 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _2698 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2698] = 26
                        mem[_2698 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2704 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2704 + idx + 68] = mem[_2698 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2704 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2704 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2844] = 26
                            mem[_2844 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2856 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2856 + idx + 68] = mem[_2844 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2856 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2856 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2966] = 26
                            mem[_2966 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2984 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2984 + idx + 68] = mem[_2966 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2984 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2984 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3194 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3194] = 26
                        mem[_3194 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3224 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3224 + idx + 68] = mem[_3194 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3224 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3224 + -mem[64] + 100
                    _2699 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2699] = 26
                    mem[_2699 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2705 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2705 + idx + 68] = mem[_2699 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2705 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2705 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2845 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2845] = 26
                        mem[_2845 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2857 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2857 + idx + 68] = mem[_2845 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2857 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2857 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2967 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2967] = 26
                        mem[_2967 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2985 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2985 + idx + 68] = mem[_2967 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2985 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2985 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3195 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3195] = 26
                    mem[_3195 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3226 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3226 + idx + 68] = mem[_3195 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3226 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3226 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / block.number - poolInfo[idx].field_1280 != sub_a054b70a:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2684 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2684] = 26
                mem[_2684 + 32] = 'SafeMath: division by zero'
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                    if not poolInfo[idx].field_768:
                        _2748 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2748] = 26
                        mem[_2748 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2755 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2755 + idx + 68] = mem[_2748 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2755 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2755 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2998 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2998] = 26
                            mem[_2998 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3015 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3015 + idx + 68] = mem[_2998 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3015 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3015 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3192] = 26
                            mem[_3192 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3222 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3222 + idx + 68] = mem[_3192 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3222 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3222 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3508 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3508] = 26
                        mem[_3508 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3544 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3544 + idx + 68] = mem[_3508 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3544 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3544 + -mem[64] + 100
                    _2749 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2749] = 26
                    mem[_2749 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2756 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2756 + idx + 68] = mem[_2749 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2756 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2756 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2999 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2999] = 26
                        mem[_2999 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3016 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3016 + idx + 68] = mem[_2999 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3016 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3016 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3193] = 26
                        mem[_3193 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3223 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3223 + idx + 68] = mem[_3193 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3223 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3223 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3509 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3509] = 26
                    mem[_3509 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3546 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3546 + idx + 68] = mem[_3509 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3546 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3546 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2851 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2851] = 26
                        mem[_2851 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2863 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2863 + idx + 68] = mem[_2851 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2863 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2863 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3246 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3246] = 26
                            mem[_3246 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3277 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3277 + idx + 68] = mem[_3246 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3277 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3277 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3506 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3506] = 26
                            mem[_3506 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3542 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3542 + idx + 68] = mem[_3506 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3542 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3542 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3881 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3881] = 26
                        mem[_3881 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3921 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3921 + idx + 68] = mem[_3881 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3921 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3921 + -mem[64] + 100
                    _2852 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2852] = 26
                    mem[_2852 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2864 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2864 + idx + 68] = mem[_2852 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2864 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2864 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3247 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3247] = 26
                        mem[_3247 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3278 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3278 + idx + 68] = mem[_3247 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3278 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3278 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3507 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3507] = 26
                        mem[_3507 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3543 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3543 + idx + 68] = mem[_3507 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3543 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3543 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3882 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3882] = 26
                    mem[_3882 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3923 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3923 + idx + 68] = mem[_3882 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3923 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3923 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3004 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3004] = 26
                    mem[_3004 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3030 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3030 + idx + 68] = mem[_3004 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3030 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3030 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3570 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3570] = 26
                        mem[_3570 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3608 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3608 + idx + 68] = mem[_3570 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3608 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3608 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _3879 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3879] = 26
                        mem[_3879 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3919 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3919 + idx + 68] = mem[_3879 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3919 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3919 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4283 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4283] = 26
                    mem[_4283 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4317 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4317 + idx + 68] = mem[_4283 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4317 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4317 + -mem[64] + 100
                _3005 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3005] = 26
                mem[_3005 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3031 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3031 + idx + 68] = mem[_3005 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3031 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3031 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3571 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3571] = 26
                    mem[_3571 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3609 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3609 + idx + 68] = mem[_3571 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3609 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3609 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _3880 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3880] = 26
                    mem[_3880 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3920 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3920 + idx + 68] = mem[_3880 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3920 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3920 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4284 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4284] = 26
                mem[_4284 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4319 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4319 + idx + 68] = mem[_4284 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4319 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4319 + -mem[64] + 100
            if 100 < sub_a054b70a:
                revert with 'NH{q', 17
            _2646 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2646] = 30
            mem[_2646 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > block.number:
                _2649 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2649 + idx + 68] = mem[_2646 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2649 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2649 + -mem[64] + 100
            if block.number < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                _2670 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2670] = 26
                mem[_2670 + 32] = 'SafeMath: division by zero'
                if not poolInfo[idx].field_768:
                    _2720 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2720] = 26
                    mem[_2720 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2726 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2726 + idx + 68] = mem[_2720 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2726 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2726 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2912 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2912] = 26
                        mem[_2912 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2928 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2928 + idx + 68] = mem[_2912 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2928 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2928 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _3055 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3055] = 26
                        mem[_3055 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3082 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3082 + idx + 68] = mem[_3055 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3082 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3082 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3323 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3323] = 26
                    mem[_3323 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3355 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3355 + idx + 68] = mem[_3323 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3355 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3355 + -mem[64] + 100
                _2721 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2721] = 26
                mem[_2721 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2727 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2727 + idx + 68] = mem[_2721 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2727 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2727 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2913 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2913] = 26
                    mem[_2913 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2929 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2929 + idx + 68] = mem[_2913 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2929 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2929 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _3056 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3056] = 26
                    mem[_3056 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3083 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3083 + idx + 68] = mem[_3056 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3083 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3083 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3324 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3324] = 26
                mem[_3324 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3357 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3357 + idx + 68] = mem[_3324 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3357 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3357 + -mem[64] + 100
            if block.number - poolInfo[idx].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_a054b70a + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _2694 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2694] = 26
            mem[_2694 + 32] = 'SafeMath: division by zero'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                if not poolInfo[idx].field_768:
                    _2796 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2796] = 26
                    mem[_2796 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2804 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2804 + idx + 68] = mem[_2796 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2804 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2804 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3094] = 26
                        mem[_3094 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3129 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3129 + idx + 68] = mem[_3094 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3129 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3129 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _3321 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3321] = 26
                        mem[_3321 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3353 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3353 + idx + 68] = mem[_3321 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3353 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3353 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3650 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3650] = 26
                    mem[_3650 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3696 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3696 + idx + 68] = mem[_3650 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3696 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3696 + -mem[64] + 100
                _2797 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2797] = 26
                mem[_2797 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2805 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2805 + idx + 68] = mem[_2797 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2805 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2805 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3095 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3095] = 26
                    mem[_3095 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3130 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3130 + idx + 68] = mem[_3095 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3130 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3130 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _3322 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3322] = 26
                    mem[_3322 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3354 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3354 + idx + 68] = mem[_3322 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3354 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3354 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3651 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3651] = 26
                mem[_3651 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3698 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3698 + idx + 68] = mem[_3651 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3698 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3698 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                if not poolInfo[idx].field_768:
                    _2921 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2921] = 26
                    mem[_2921 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2934 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2934 + idx + 68] = mem[_2921 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2934 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2934 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3381 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3381] = 26
                        mem[_3381 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3437 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3437 + idx + 68] = mem[_3381 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3437 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3437 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _3648 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3648] = 26
                        mem[_3648 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3694 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3694 + idx + 68] = mem[_3648 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3694 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3694 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4034 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4034] = 26
                    mem[_4034 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4076 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4076 + idx + 68] = mem[_4034 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4076 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4076 + -mem[64] + 100
                _2922 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2922] = 26
                mem[_2922 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2935 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2935 + idx + 68] = mem[_2922 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2935 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2935 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3382 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3382] = 26
                    mem[_3382 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3438 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3438 + idx + 68] = mem[_3382 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3438 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3438 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _3649 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3649] = 26
                    mem[_3649 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3695 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3695 + idx + 68] = mem[_3649 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3695 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3695 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4035 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4035] = 26
                mem[_4035 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4078 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4078 + idx + 68] = mem[_4035 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4078 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4078 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            if not poolInfo[idx].field_768:
                _3113 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3113] = 26
                mem[_3113 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _3146 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3146 + idx + 68] = mem[_3113 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3146 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3146 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3727 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3727] = 26
                    mem[_3727 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3797 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3797 + idx + 68] = mem[_3727 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3797 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3797 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _4032 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4032] = 26
                    mem[_4032 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4074 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4074 + idx + 68] = mem[_4032 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4074 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4074 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4436 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4436] = 26
                mem[_4436 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4476 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4476 + idx + 68] = mem[_4436 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4476 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4476 + -mem[64] + 100
            _3114 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3114] = 26
            mem[_3114 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _3147 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3147 + idx + 68] = mem[_3114 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3147 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3147 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _3728 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3728] = 26
                mem[_3728 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3798 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3798 + idx + 68] = mem[_3728 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3798 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3798 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                _4033 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4033] = 26
                mem[_4033 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4075 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4075 + idx + 68] = mem[_4033 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4075 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4075 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _4437 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4437] = 26
            mem[_4437 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _4478 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4478 + idx + 68] = mem[_4437 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4478 + 94] = 0
            revert with memory
              from mem[64]
               len _4478 + -mem[64] + 100
        if not poolInfo[idx].field_768:
            _2636 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2636] = 30
            mem[_2636 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                _2639 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2639 + idx + 68] = mem[_2636 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2639 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2639 + -mem[64] + 100
            if block.number < bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                _2657 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2657] = 26
                mem[_2657 + 32] = 'SafeMath: division by zero'
                _2679 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2679] = 30
                mem[_2679 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _2681 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2681 + idx + 68] = mem[_2679 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2681 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2681 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _2711 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2711] = 26
                    mem[_2711 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _2926 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2926] = 26
                        mem[_2926 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2944 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2944 + idx + 68] = mem[_2926 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2944 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2944 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3403] = 26
                            mem[_3403 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3451 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3451 + idx + 68] = mem[_3403 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3451 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3451 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3670] = 26
                            mem[_3670 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3715 + idx + 68] = mem[_3670 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3715 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3715 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4055 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4055] = 26
                        mem[_4055 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4098 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4098 + idx + 68] = mem[_4055 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4098 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4098 + -mem[64] + 100
                    _2927 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2927] = 26
                    mem[_2927 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2945 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2945 + idx + 68] = mem[_2927 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2945 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2945 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3404 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3404] = 26
                        mem[_3404 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3452 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3452 + idx + 68] = mem[_3404 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3452 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3452 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3671] = 26
                        mem[_3671 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3716 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3716 + idx + 68] = mem[_3671 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3716 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3716 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4056 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4056] = 26
                    mem[_4056 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4100 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4100 + idx + 68] = mem[_4056 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4100 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4100 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2772 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2772] = 26
                mem[_2772 + 32] = 'SafeMath: division by zero'
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -1:
                    revert with 'NH{q', 17
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    if not poolInfo[idx].field_768:
                        _3125 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3125] = 26
                        mem[_3125 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3162 + idx + 68] = mem[_3125 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3162 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3162 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3757 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3757] = 26
                            mem[_3757 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3813 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3813 + idx + 68] = mem[_3757 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3813 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3813 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _4053 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4053] = 26
                            mem[_4053 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4096 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4096 + idx + 68] = mem[_4053 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4096 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4096 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4454 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4454] = 26
                        mem[_4454 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4504 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4504 + idx + 68] = mem[_4454 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4504 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4504 + -mem[64] + 100
                    _3126 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3126] = 26
                    mem[_3126 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3163 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3163 + idx + 68] = mem[_3126 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3163 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3163 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3758 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3758] = 26
                        mem[_3758 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3814 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3814 + idx + 68] = mem[_3758 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3814 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3814 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _4054 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4054] = 26
                        mem[_4054 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4097 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4097 + idx + 68] = mem[_4054 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4097 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4097 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4455 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4455] = 26
                    mem[_4455 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4506 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4506 + idx + 68] = mem[_4455 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4506 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4506 + -mem[64] + 100
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 17
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _3433 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3433] = 26
                        mem[_3433 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3476 + idx + 68] = mem[_3433 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3476 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3476 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _4148 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4148] = 26
                            mem[_4148 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4212 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4212 + idx + 68] = mem[_4148 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4212 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4212 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _4452 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4452] = 26
                            mem[_4452 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4502 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4502 + idx + 68] = mem[_4452 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4502 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4502 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4813 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4813] = 26
                        mem[_4813 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4861 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4861 + idx + 68] = mem[_4813 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4861 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4861 + -mem[64] + 100
                    _3434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3434] = 26
                    mem[_3434 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3477 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3477 + idx + 68] = mem[_3434 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3477 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3477 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4149] = 26
                        mem[_4149 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4213 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4213 + idx + 68] = mem[_4149 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4213 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4213 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _4453 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4453] = 26
                        mem[_4453 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4503 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4503 + idx + 68] = mem[_4453 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4503 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4503 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4814 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4814] = 26
                    mem[_4814 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4863 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4863 + idx + 68] = mem[_4814 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4863 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4863 + -mem[64] + 100
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3791 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3791] = 26
                    mem[_3791 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3844 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3844 + idx + 68] = mem[_3791 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3844 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3844 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4556 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4556] = 26
                        mem[_4556 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4618 + idx + 68] = mem[_4556 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4618 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4618 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _4811 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4811] = 26
                        mem[_4811 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4859 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4859 + idx + 68] = mem[_4811 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4859 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4859 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5113 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5113] = 26
                    mem[_5113 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5153 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5153 + idx + 68] = mem[_5113 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5153 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5153 + -mem[64] + 100
                _3792 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3792] = 26
                mem[_3792 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3845 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3845 + idx + 68] = mem[_3792 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3845 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3845 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4557 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4557] = 26
                    mem[_4557 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4619 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4619 + idx + 68] = mem[_4557 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4619 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4619 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _4812 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4812] = 26
                    mem[_4812 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4860 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4860 + idx + 68] = mem[_4812 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4860 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4860 + -mem[64] + 100
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5114 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5114] = 26
                mem[_5114 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5155 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5155 + idx + 68] = mem[_5114 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5155 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5155 + -mem[64] + 100
            if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                revert with 'NH{q', 18
            if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                revert with 0, 'SafeMath: multiplication overflow'
            _2683 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2683] = 26
            mem[_2683 + 32] = 'SafeMath: division by zero'
            _2708 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2708] = 30
            mem[_2708 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _2715 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2715 + idx + 68] = mem[_2708 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2715 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2715 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _2771 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2771] = 26
                mem[_2771 + 32] = 'SafeMath: division by zero'
                if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                    revert with 'NH{q', 17
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                    if not poolInfo[idx].field_768:
                        _3123 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3123] = 26
                        mem[_3123 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3160 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3160 + idx + 68] = mem[_3123 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3160 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3160 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3751] = 26
                            mem[_3751 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3811 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3811 + idx + 68] = mem[_3751 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3811 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3811 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _4047 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4047] = 26
                            mem[_4047 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4092 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4092 + idx + 68] = mem[_4047 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4092 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4092 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4448] = 26
                        mem[_4448 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4496 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4496 + idx + 68] = mem[_4448 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4496 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4496 + -mem[64] + 100
                    _3124 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3124] = 26
                    mem[_3124 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3161 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3161 + idx + 68] = mem[_3124 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3161 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3161 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3752 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3752] = 26
                        mem[_3752 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3812 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3812 + idx + 68] = mem[_3752 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3812 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3812 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _4048 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4048] = 26
                        mem[_4048 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4093 + idx + 68] = mem[_4048 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4093 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4093 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4449 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4449] = 26
                    mem[_4449 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4498 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4498 + idx + 68] = mem[_4449 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4498 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4498 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _3431 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3431] = 26
                        mem[_3431 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3472 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3472 + idx + 68] = mem[_3431 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3472 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3472 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _4142 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4142] = 26
                            mem[_4142 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4206 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4206 + idx + 68] = mem[_4142 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4206 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4206 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _4446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4446] = 26
                            mem[_4446 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4494 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4494 + idx + 68] = mem[_4446 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4494 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4494 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4809 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4809] = 26
                        mem[_4809 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4853 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4853 + idx + 68] = mem[_4809 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4853 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4853 + -mem[64] + 100
                    _3432 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3432] = 26
                    mem[_3432 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3473 + idx + 68] = mem[_3432 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3473 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3473 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4143] = 26
                        mem[_4143 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4207 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4207 + idx + 68] = mem[_4143 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4207 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4207 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _4447 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4447] = 26
                        mem[_4447 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4495 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4495 + idx + 68] = mem[_4447 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4495 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4495 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4810 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4810] = 26
                    mem[_4810 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4855 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4855 + idx + 68] = mem[_4810 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4855 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4855 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3789 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3789] = 26
                    mem[_3789 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3839 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3839 + idx + 68] = mem[_3789 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3839 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3839 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4550] = 26
                        mem[_4550 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4608 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4608 + idx + 68] = mem[_4550 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4608 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4608 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _4807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4807] = 26
                        mem[_4807 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4851 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4851 + idx + 68] = mem[_4807 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4851 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4851 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5111 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5111] = 26
                    mem[_5111 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5147 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5147 + idx + 68] = mem[_5111 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5147 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5147 + -mem[64] + 100
                _3790 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3790] = 26
                mem[_3790 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3840 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3840 + idx + 68] = mem[_3790 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3840 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3840 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4551 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4551] = 26
                    mem[_4551 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4609 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4609 + idx + 68] = mem[_4551 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4609 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4609 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _4808 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4808] = 26
                    mem[_4808 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4852 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4852 + idx + 68] = mem[_4808 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4852 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4852 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5112 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5112] = 26
                mem[_5112 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5149 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5149 + idx + 68] = mem[_5112 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5149 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5149 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                revert with 0, 'SafeMath: multiplication overflow'
            _2894 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2894] = 26
            mem[_2894 + 32] = 'SafeMath: division by zero'
            if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                revert with 'NH{q', 17
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                if not poolInfo[idx].field_768:
                    _3429 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3429] = 26
                    mem[_3429 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3470 + idx + 68] = mem[_3429 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3470 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3470 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4136 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4136] = 26
                        mem[_4136 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4204 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4204 + idx + 68] = mem[_4136 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4204 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4204 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4442 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4442] = 26
                        mem[_4442 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4490 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4490 + idx + 68] = mem[_4442 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4490 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4490 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4805 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4805] = 26
                    mem[_4805 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4847 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4847 + idx + 68] = mem[_4805 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4847 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4847 + -mem[64] + 100
                _3430 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3430] = 26
                mem[_3430 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3471 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3471 + idx + 68] = mem[_3430 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3471 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3471 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4137 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4137] = 26
                    mem[_4137 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4205 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4205 + idx + 68] = mem[_4137 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4205 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4205 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4443 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4443] = 26
                    mem[_4443 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4491 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4491 + idx + 68] = mem[_4443 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4491 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4491 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4806 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4806] = 26
                mem[_4806 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4849 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4849 + idx + 68] = mem[_4806 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4849 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4849 + -mem[64] + 100
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                revert with 'NH{q', 17
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                revert with 'NH{q', 18
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                if not poolInfo[idx].field_768:
                    _3787 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3787] = 26
                    mem[_3787 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3835 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3835 + idx + 68] = mem[_3787 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3835 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3835 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4548 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4548] = 26
                        mem[_4548 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4602 + idx + 68] = mem[_4548 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4602 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4602 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4803 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4803] = 26
                        mem[_4803 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4845 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4845 + idx + 68] = mem[_4803 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4845 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4845 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5109 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5109] = 26
                    mem[_5109 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5141 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5141 + idx + 68] = mem[_5109 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5141 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5141 + -mem[64] + 100
                _3788 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3788] = 26
                mem[_3788 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3836 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3836 + idx + 68] = mem[_3788 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3836 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3836 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4549 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4549] = 26
                    mem[_4549 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4603 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4603 + idx + 68] = mem[_4549 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4603 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4603 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4804 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4804] = 26
                    mem[_4804 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4846 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4846 + idx + 68] = mem[_4804 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4846 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4846 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5110 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5110] = 26
                mem[_5110 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5143 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5143 + idx + 68] = mem[_5110 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5143 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5143 + -mem[64] + 100
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                revert with 'NH{q', 17
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                revert with 'NH{q', 18
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            if not poolInfo[idx].field_768:
                _4180 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4180] = 26
                mem[_4180 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _4242 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4242 + idx + 68] = mem[_4180 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4242 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4242 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4891 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4891] = 26
                    mem[_4891 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4943 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4943 + idx + 68] = mem[_4891 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4943 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4943 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _5107 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5107] = 26
                    mem[_5107 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5139 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5139 + idx + 68] = mem[_5107 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5139 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5139 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5619 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5619] = 26
                mem[_5619 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5629 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5629 + idx + 68] = mem[_5619 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5629 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5629 + -mem[64] + 100
            _4181 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4181] = 26
            mem[_4181 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _4243 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4243 + idx + 68] = mem[_4181 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4243 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4243 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _4892 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4892] = 26
                mem[_4892 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4944 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4944 + idx + 68] = mem[_4892 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4944 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4944 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6), this.address);
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                _5108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5108] = 26
                mem[_5108 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5140 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5140 + idx + 68] = mem[_5108 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5140 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5140 + -mem[64] + 100
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                revert with 'NH{q', 17
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _5620 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5620] = 26
            mem[_5620 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5630 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5630 + idx + 68] = mem[_5620 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5630 + 94] = 0
            revert with memory
              from mem[64]
               len _5630 + -mem[64] + 100
        if 100 < sub_a054b70a:
            revert with 'NH{q', 17
        _2645 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2645] = 30
        mem[_2645 + 32] = 'SafeMath: subtraction overflow'
        if bonusEndBlock > block.number:
            _2648 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_2648 + idx + 68] = mem[_2645 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2648 + 98] = 0
            revert with memory
              from mem[64]
               len _2648 + -mem[64] + 100
        if block.number < bonusEndBlock:
            revert with 'NH{q', 17
        if not block.number - bonusEndBlock:
            _2669 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2669] = 26
            mem[_2669 + 32] = 'SafeMath: division by zero'
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _2707 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2707] = 30
            mem[_2707 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _2712 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2712 + idx + 68] = mem[_2707 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2712 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2712 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _2768 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2768] = 26
                mem[_2768 + 32] = 'SafeMath: division by zero'
                if not poolInfo[idx].field_768:
                    _3107 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3107] = 26
                    mem[_3107 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3144 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3144 + idx + 68] = mem[_3107 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3144 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3144 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3725 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3725] = 26
                        mem[_3725 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3793 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3793 + idx + 68] = mem[_3725 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3793 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3793 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4030 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4030] = 26
                        mem[_4030 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4072 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4072 + idx + 68] = mem[_4030 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4072 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4072 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4434] = 26
                    mem[_4434 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4472 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4472 + idx + 68] = mem[_4434 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4472 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4472 + -mem[64] + 100
                _3108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3108] = 26
                mem[_3108 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3145 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3145 + idx + 68] = mem[_3108 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3145 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3145 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3726 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3726] = 26
                    mem[_3726 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3794 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3794 + idx + 68] = mem[_3726 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3794 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3794 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4031 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4031] = 26
                    mem[_4031 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4073 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4073 + idx + 68] = mem[_4031 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4073 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4073 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4435 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4435] = 26
                mem[_4435 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4474 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4474 + idx + 68] = mem[_4435 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4474 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4474 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _2884 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2884] = 26
            mem[_2884 + 32] = 'SafeMath: division by zero'
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -1:
                revert with 'NH{q', 17
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                if not poolInfo[idx].field_768:
                    _3407 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3407] = 26
                    mem[_3407 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3456 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3456 + idx + 68] = mem[_3407 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3456 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3456 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4116 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4116] = 26
                        mem[_4116 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4184 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4184 + idx + 68] = mem[_4116 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4184 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4184 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4432 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4432] = 26
                        mem[_4432 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4470 + idx + 68] = mem[_4432 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4470 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4470 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4799 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4799] = 26
                    mem[_4799 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4833 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4833 + idx + 68] = mem[_4799 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4833 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4833 + -mem[64] + 100
                _3408 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3408] = 26
                mem[_3408 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3457 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3457 + idx + 68] = mem[_3408 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3457 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3457 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4117 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4117] = 26
                    mem[_4117 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4185 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4185 + idx + 68] = mem[_4117 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4185 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4185 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4433 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4433] = 26
                    mem[_4433 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4471 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4471 + idx + 68] = mem[_4433 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4471 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4471 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4800 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4800] = 26
                mem[_4800 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4835 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4835 + idx + 68] = mem[_4800 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4835 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4835 + -mem[64] + 100
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 17
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                if not poolInfo[idx].field_768:
                    _3763 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3763] = 26
                    mem[_3763 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3825 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3825 + idx + 68] = mem[_3763 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3825 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3825 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4526 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4526] = 26
                        mem[_4526 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4586 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4586 + idx + 68] = mem[_4526 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4586 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4586 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4797 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4797] = 26
                        mem[_4797 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4831 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4831 + idx + 68] = mem[_4797 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4831 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4831 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5105 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5105] = 26
                    mem[_5105 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5133 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5133 + idx + 68] = mem[_5105 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5133 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5133 + -mem[64] + 100
                _3764 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3764] = 26
                mem[_3764 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3826 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3826 + idx + 68] = mem[_3764 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3826 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3826 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4527] = 26
                    mem[_4527 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4587 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4587 + idx + 68] = mem[_4527 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4587 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4587 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4798 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4798] = 26
                    mem[_4798 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4832 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4832 + idx + 68] = mem[_4798 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4832 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4832 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5106] = 26
                mem[_5106 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5135 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5135 + idx + 68] = mem[_5106 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5135 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5135 + -mem[64] + 100
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            if not poolInfo[idx].field_768:
                _4158 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4158] = 26
                mem[_4158 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _4231 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4231 + idx + 68] = mem[_4158 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4231 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4231 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4879 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4879] = 26
                    mem[_4879 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4929 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4929 + idx + 68] = mem[_4879 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4929 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4929 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _5103 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5103] = 26
                    mem[_5103 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5131 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5131 + idx + 68] = mem[_5103 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5131 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5131 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5617 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5617] = 26
                mem[_5617 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5627 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5627 + idx + 68] = mem[_5617 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5627 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5627 + -mem[64] + 100
            _4159 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4159] = 26
            mem[_4159 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _4232 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4232 + idx + 68] = mem[_4159 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4232 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4232 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _4880 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4880] = 26
                mem[_4880 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4930 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4930 + idx + 68] = mem[_4880 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4930 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4930 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                _5104 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5104] = 26
                mem[_5104 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5132 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5132 + idx + 68] = mem[_5104 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5132 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5132 + -mem[64] + 100
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 17
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _5618 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5618] = 26
            mem[_5618 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5628 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5628 + idx + 68] = mem[_5618 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5628 + 94] = 0
            revert with memory
              from mem[64]
               len _5628 + -mem[64] + 100
        if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
            revert with 'NH{q', 17
        if not block.number - bonusEndBlock:
            revert with 'NH{q', 18
        if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        _2693 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2693] = 26
        mem[_2693 + 32] = 'SafeMath: division by zero'
        if 100 < sub_e600038d:
            revert with 'NH{q', 17
        _2763 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2763] = 30
        mem[_2763 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_1280 > bonusEndBlock:
            _2773 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_2773 + idx + 68] = mem[_2763 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2773 + 98] = 0
            revert with memory
              from mem[64]
               len _2773 + -mem[64] + 100
        if bonusEndBlock < poolInfo[idx].field_1280:
            revert with 'NH{q', 17
        if not bonusEndBlock - poolInfo[idx].field_1280:
            _2883 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2883] = 26
            mem[_2883 + 32] = 'SafeMath: division by zero'
            if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                revert with 'NH{q', 17
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                if not poolInfo[idx].field_768:
                    _3405 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3405] = 26
                    mem[_3405 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3454 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3454 + idx + 68] = mem[_3405 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3454 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3454 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4110] = 26
                        mem[_4110 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4182 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4182 + idx + 68] = mem[_4110 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4182 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4182 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4426] = 26
                        mem[_4426 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4466 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4466 + idx + 68] = mem[_4426 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4466 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4466 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4793 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4793] = 26
                    mem[_4793 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4825 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4825 + idx + 68] = mem[_4793 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4825 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4825 + -mem[64] + 100
                _3406 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3406] = 26
                mem[_3406 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3455 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3455 + idx + 68] = mem[_3406 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3455 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3455 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4111 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4111] = 26
                    mem[_4111 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4183 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4183 + idx + 68] = mem[_4111 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4183 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4183 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4427] = 26
                    mem[_4427 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4467 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4467 + idx + 68] = mem[_4427 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4467 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4467 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4794 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4794] = 26
                mem[_4794 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4827 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4827 + idx + 68] = mem[_4794 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4827 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4827 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                if not poolInfo[idx].field_768:
                    _3761 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3761] = 26
                    mem[_3761 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3821 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3821 + idx + 68] = mem[_3761 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3821 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3821 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4520 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4520] = 26
                        mem[_4520 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4580 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4580 + idx + 68] = mem[_4520 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4580 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4580 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4791 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4791] = 26
                        mem[_4791 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4823 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4823 + idx + 68] = mem[_4791 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4823 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4823 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5101 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5101] = 26
                    mem[_5101 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5125 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5125 + idx + 68] = mem[_5101 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5125 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5125 + -mem[64] + 100
                _3762 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3762] = 26
                mem[_3762 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3822 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3822 + idx + 68] = mem[_3762 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3822 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3822 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4521 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4521] = 26
                    mem[_4521 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4581 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4581 + idx + 68] = mem[_4521 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4581 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4581 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4792 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4792] = 26
                    mem[_4792 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4824 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4824 + idx + 68] = mem[_4792 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4824 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4824 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5102 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5102] = 26
                mem[_5102 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5127 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5127 + idx + 68] = mem[_5102 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5127 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5127 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            if not poolInfo[idx].field_768:
                _4156 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4156] = 26
                mem[_4156 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _4226 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4226 + idx + 68] = mem[_4156 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4226 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4226 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4873 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4873] = 26
                    mem[_4873 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4919 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4919 + idx + 68] = mem[_4873 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4919 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4919 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _5099 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5099] = 26
                    mem[_5099 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5123 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5123 + idx + 68] = mem[_5099 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5123 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5123 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5615 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5615] = 26
                mem[_5615 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5625 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5625 + idx + 68] = mem[_5615 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5625 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5625 + -mem[64] + 100
            _4157 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4157] = 26
            mem[_4157 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _4227 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4227 + idx + 68] = mem[_4157 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4227 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4227 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _4874 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4874] = 26
                mem[_4874 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4920 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4920 + idx + 68] = mem[_4874 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4920 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4920 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
            emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                _5100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5100] = 26
                mem[_5100 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5124 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5124 + idx + 68] = mem[_5100 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5124 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5124 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _5616 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5616] = 26
            mem[_5616 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5626 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5626 + idx + 68] = mem[_5616 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5626 + 94] = 0
            revert with memory
              from mem[64]
               len _5626 + -mem[64] + 100
        if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
            revert with 'NH{q', 17
        if not bonusEndBlock - poolInfo[idx].field_1280:
            revert with 'NH{q', 18
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        _3065 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3065] = 26
        mem[_3065 + 32] = 'SafeMath: division by zero'
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
            revert with 'NH{q', 17
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
            revert with 0, 'SafeMath: addition overflow'
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
            if not poolInfo[idx].field_768:
                _3759 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3759] = 26
                mem[_3759 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _3819 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3819 + idx + 68] = mem[_3759 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3819 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3819 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4514 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4514] = 26
                    mem[_4514 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4578 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4578 + idx + 68] = mem[_4514 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4578 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4578 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _4787 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4787] = 26
                    mem[_4787 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4819 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4819 + idx + 68] = mem[_4787 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4819 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4819 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5097 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5097] = 26
                mem[_5097 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5119 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5119 + idx + 68] = mem[_5097 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5119 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5119 + -mem[64] + 100
            _3760 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3760] = 26
            mem[_3760 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _3820 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3820 + idx + 68] = mem[_3760 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3820 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3820 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not 0 / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _4515 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4515] = 26
                mem[_4515 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4579 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4579 + idx + 68] = mem[_4515 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4579 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4579 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), 0 / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0 / sub_9e98edc6
            emit Mint((0 / sub_9e98edc6), this.address);
            if not 0 / sub_9e98edc6:
                _4788 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4788] = 26
                mem[_4788 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4820 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4820 + idx + 68] = mem[_4788 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4820 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4820 + -mem[64] + 100
            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                revert with 'NH{q', 17
            if not 0 / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _5098 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5098] = 26
            mem[_5098 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5121 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5121 + idx + 68] = mem[_5098 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5121 + 94] = 0
            revert with memory
              from mem[64]
               len _5121 + -mem[64] + 100
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
            revert with 'NH{q', 17
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
            revert with 'NH{q', 18
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
            if not poolInfo[idx].field_768:
                _4154 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4154] = 26
                mem[_4154 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _4222 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4222 + idx + 68] = mem[_4154 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4222 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4222 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4871 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4871] = 26
                    mem[_4871 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4913 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4913 + idx + 68] = mem[_4871 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4913 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4913 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _5095 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5095] = 26
                    mem[_5095 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _5117 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_5117 + idx + 68] = mem[_5095 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5117 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5117 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5613 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5613] = 26
                mem[_5613 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5623 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5623 + idx + 68] = mem[_5613 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5623 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5623 + -mem[64] + 100
            _4155 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4155] = 26
            mem[_4155 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _4223 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4223 + idx + 68] = mem[_4155 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4223 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4223 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not 0 / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _4872 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4872] = 26
                mem[_4872 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4914 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4914 + idx + 68] = mem[_4872 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4914 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4914 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), 0 / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0 / sub_9e98edc6
            emit Mint((0 / sub_9e98edc6), this.address);
            if not 0 / sub_9e98edc6:
                _5096 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5096] = 26
                mem[_5096 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5118 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5118 + idx + 68] = mem[_5096 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5118 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5118 + -mem[64] + 100
            if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                revert with 'NH{q', 17
            if not 0 / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _5614 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5614] = 26
            mem[_5614 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5624 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5624 + idx + 68] = mem[_5614 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5624 + 94] = 0
            revert with memory
              from mem[64]
               len _5624 + -mem[64] + 100
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
            revert with 'NH{q', 17
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
            revert with 'NH{q', 18
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        if not poolInfo[idx].field_768:
            _4564 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4564] = 26
            mem[_4564 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _4630 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4630 + idx + 68] = mem[_4564 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4630 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4630 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _5159 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5159] = 26
                mem[_5159 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5195 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5195 + idx + 68] = mem[_5159 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5195 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5195 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _5611 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5611] = 26
                mem[_5611 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5621 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5621 + idx + 68] = mem[_5611 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5621 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5621 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _6277 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6277] = 26
            mem[_6277 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _6279 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_6279 + idx + 68] = mem[_6277 + idx + 32]
                idx = idx + 32
                continue 
            mem[_6279 + 94] = 0
            revert with memory
              from mem[64]
               len _6279 + -mem[64] + 100
        _4565 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4565] = 26
        mem[_4565 + 32] = 'SafeMath: division by zero'
        if sub_9e98edc6 <= 0:
            _4631 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4631 + idx + 68] = mem[_4565 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4631 + 94] = 0
            revert with memory
              from mem[64]
               len _4631 + -mem[64] + 100
        if not sub_9e98edc6:
            revert with 'NH{q', 18
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
            mem[mem[64]] = 0
            emit Mint(0, this.address);
            _5160 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5160] = 26
            mem[_5160 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5196 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5196 + idx + 68] = mem[_5160 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5196 + 94] = 0
            revert with memory
              from mem[64]
               len _5196 + -mem[64] + 100
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
        require ext_code.size(sushiAddress)
        call sushiAddress.mint(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
        emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6), this.address);
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
            _5612 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5612] = 26
            mem[_5612 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5622 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5622 + idx + 68] = mem[_5612 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5622 + 94] = 0
            revert with memory
              from mem[64]
               len _5622 + -mem[64] + 100
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
            revert with 'NH{q', 17
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
            revert with 'NH{q', 18
        if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _6278 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6278] = 26
        mem[_6278 + 32] = 'SafeMath: division by zero'
        if poolInfo[idx].field_512 > 0:
            if not poolInfo[idx].field_512:
                revert with 'NH{q', 18
            if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                revert with 'NH{q', 17
            if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512
            poolInfo[idx].field_1280 = block.number
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        _6281 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[_6281 + idx + 68] = mem[_6278 + idx + 32]
            idx = idx + 32
            continue 
        mem[_6281 + 94] = 0
        revert with memory
          from mem[64]
           len _6281 + -mem[64] + 100
}

function add(uint256 arg1, address arg2, bool arg3, bool arg4, uint256 arg5) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    if owner != msg.sender:
        revert with 0, '!dev addr'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 7
            if block.number <= poolInfo[idx].field_1280:
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if not poolInfo[idx].field_512:
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if block.number <= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1773 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1773] = 30
                    mem[_1773 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1776 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1776 + idx + 68] = mem[_1773 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1776 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1776 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1838] = 26
                        mem[_1838 + 32] = 'SafeMath: division by zero'
                        if not poolInfo[idx].field_768:
                            _1877 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1877] = 26
                            mem[_1877 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _1882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_1882 + idx + 68] = mem[_1877 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1882 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1882 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2016 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2016] = 26
                                mem[_2016 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2035 + idx + 68] = mem[_2016 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2035 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2035 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2137 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2137] = 26
                                mem[_2137 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2160 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2160 + idx + 68] = mem[_2137 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2160 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2160 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2360 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2360] = 26
                            mem[_2360 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2394 + idx + 68] = mem[_2360 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2394 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2394 + -mem[64] + 100
                        _1878 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1878] = 26
                        mem[_1878 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _1883 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1883 + idx + 68] = mem[_1878 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1883 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1883 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2017 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2017] = 26
                            mem[_2017 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2036 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2036 + idx + 68] = mem[_2017 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2036 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2036 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2138 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2138] = 26
                            mem[_2138 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2161 + idx + 68] = mem[_2138 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2161 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2161 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2361] = 26
                        mem[_2361 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2396 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2396 + idx + 68] = mem[_2361 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2396 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2396 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_e600038d > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / block.number - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1864 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1864] = 26
                    mem[_1864 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        if not poolInfo[idx].field_768:
                            _1927 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1927] = 26
                            mem[_1927 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _1932 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_1932 + idx + 68] = mem[_1927 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1932 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1932 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2172] = 26
                                mem[_2172 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2188 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2188 + idx + 68] = mem[_2172 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2188 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2188 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2358 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2358] = 26
                                mem[_2358 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2392 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2392 + idx + 68] = mem[_2358 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2392 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2392 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2674 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2674] = 26
                            mem[_2674 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2710 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2710 + idx + 68] = mem[_2674 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2710 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2710 + -mem[64] + 100
                        _1928 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1928] = 26
                        mem[_1928 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _1933 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1933 + idx + 68] = mem[_1928 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1933 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1933 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2173 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2173] = 26
                            mem[_2173 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2189 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2189 + idx + 68] = mem[_2173 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2189 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2189 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2359 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2359] = 26
                            mem[_2359 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2393 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2393 + idx + 68] = mem[_2359 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2393 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2393 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2675 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2675] = 26
                        mem[_2675 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2712 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2712 + idx + 68] = mem[_2675 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2712 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2712 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2031] = 26
                            mem[_2031 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2040 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2040 + idx + 68] = mem[_2031 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2040 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2040 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2414 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2414] = 26
                                mem[_2414 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2448 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2448 + idx + 68] = mem[_2414 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2448 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2448 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2672 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2672] = 26
                                mem[_2672 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2708 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2708 + idx + 68] = mem[_2672 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2708 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2708 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3043 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3043] = 26
                            mem[_3043 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3089 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3089 + idx + 68] = mem[_3043 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3089 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3089 + -mem[64] + 100
                        _2032 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2032] = 26
                        mem[_2032 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2041 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2041 + idx + 68] = mem[_2032 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2041 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2041 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2415 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2415] = 26
                            mem[_2415 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2449 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2449 + idx + 68] = mem[_2415 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2449 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2449 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2673] = 26
                            mem[_2673 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2709 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2709 + idx + 68] = mem[_2673 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2709 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2709 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3044 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3044] = 26
                        mem[_3044 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3091 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3091 + idx + 68] = mem[_3044 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3091 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3091 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _2184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2184] = 26
                        mem[_2184 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2203 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2203 + idx + 68] = mem[_2184 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2203 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2203 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2732] = 26
                            mem[_2732 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2778 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2778 + idx + 68] = mem[_2732 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2778 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2778 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _3041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3041] = 26
                            mem[_3041 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3087 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3087 + idx + 68] = mem[_3041 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3087 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3087 + -mem[64] + 100
                        if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3445 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3445] = 26
                        mem[_3445 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3491 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3491 + idx + 68] = mem[_3445 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3491 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3491 + -mem[64] + 100
                    _2185 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2185] = 26
                    mem[_2185 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2204 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2204 + idx + 68] = mem[_2185 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2204 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2204 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2733 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2733] = 26
                        mem[_2733 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2779 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2779 + idx + 68] = mem[_2733 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2779 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2779 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _3042 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3042] = 26
                        mem[_3042 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3088 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3088 + idx + 68] = mem[_3042 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3088 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3088 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3446 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3446] = 26
                    mem[_3446 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3493 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3493 + idx + 68] = mem[_3446 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3493 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3493 + -mem[64] + 100
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _1786 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1786] = 30
                mem[_1786 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1825 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1825 + idx + 68] = mem[_1786 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1825 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1825 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1850 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1850] = 26
                    mem[_1850 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _1899 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1899] = 26
                        mem[_1899 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1905 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1905 + idx + 68] = mem[_1899 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1905 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1905 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2087] = 26
                            mem[_2087 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2105 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2105 + idx + 68] = mem[_2087 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2105 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2105 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2228 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2228] = 26
                            mem[_2228 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2258 + idx + 68] = mem[_2228 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2258 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2258 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2493 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2493] = 26
                        mem[_2493 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2529 + idx + 68] = mem[_2493 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2529 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2529 + -mem[64] + 100
                    _1900 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1900] = 26
                    mem[_1900 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _1906 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1906 + idx + 68] = mem[_1900 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1906 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1906 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2088] = 26
                        mem[_2088 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2106 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2106 + idx + 68] = mem[_2088 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2106 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2106 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2229 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2229] = 26
                        mem[_2229 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2259 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2259 + idx + 68] = mem[_2229 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2259 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2259 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2494 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2494] = 26
                    mem[_2494 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2531 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2531 + idx + 68] = mem[_2494 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2531 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2531 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1874 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1874] = 26
                mem[_1874 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    if not poolInfo[idx].field_768:
                        _1972 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1972] = 26
                        mem[_1972 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1982 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1982 + idx + 68] = mem[_1972 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1982 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1982 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2270 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2270] = 26
                            mem[_2270 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2299 + idx + 68] = mem[_2270 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2299 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2299 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2491] = 26
                            mem[_2491 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2527 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2527 + idx + 68] = mem[_2491 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2527 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2527 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2818 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2818] = 26
                        mem[_2818 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2864 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2864 + idx + 68] = mem[_2818 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2864 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2864 + -mem[64] + 100
                    _1973 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1973] = 26
                    mem[_1973 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _1983 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1983 + idx + 68] = mem[_1973 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1983 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1983 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2271] = 26
                        mem[_2271 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2300 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2300 + idx + 68] = mem[_2271 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2300 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2300 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2492 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2492] = 26
                        mem[_2492 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2528 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2528 + idx + 68] = mem[_2492 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2528 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2528 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2819 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2819] = 26
                    mem[_2819 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2866 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2866 + idx + 68] = mem[_2819 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2866 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2866 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2098 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2098] = 26
                        mem[_2098 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2112 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2112 + idx + 68] = mem[_2098 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2112 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2112 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2545] = 26
                            mem[_2545 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2601 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2601 + idx + 68] = mem[_2545 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2601 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2601 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2816 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2816] = 26
                            mem[_2816 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2862 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2862 + idx + 68] = mem[_2816 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2862 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2862 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3192 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3192] = 26
                        mem[_3192 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3243 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3243 + idx + 68] = mem[_3192 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3243 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3243 + -mem[64] + 100
                    _2099 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2099] = 26
                    mem[_2099 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2113 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2113 + idx + 68] = mem[_2099 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2113 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2113 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2546 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2546] = 26
                        mem[_2546 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2602 + idx + 68] = mem[_2546 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2602 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2602 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2817 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2817] = 26
                        mem[_2817 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2863 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2863 + idx + 68] = mem[_2817 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2863 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2863 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3193 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3193] = 26
                    mem[_3193 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3245 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3245 + idx + 68] = mem[_3193 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3245 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3245 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _2282 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2282] = 26
                    mem[_2282 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2317 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2317 + idx + 68] = mem[_2282 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2317 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2317 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2884 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2884] = 26
                        mem[_2884 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2957 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2957 + idx + 68] = mem[_2884 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2957 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2957 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _3190 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3190] = 26
                        mem[_3190 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3241 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3241 + idx + 68] = mem[_3190 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3241 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3241 + -mem[64] + 100
                    if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3587] = 26
                    mem[_3587 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3638 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3638 + idx + 68] = mem[_3587 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3638 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3638 + -mem[64] + 100
                _2283 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2283] = 26
                mem[_2283 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2318 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2318 + idx + 68] = mem[_2283 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2318 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2318 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2885 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2885] = 26
                    mem[_2885 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2958 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2958 + idx + 68] = mem[_2885 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2958 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2958 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _3191 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3191] = 26
                    mem[_3191 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3242 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3242 + idx + 68] = mem[_3191 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3242 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3242 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3588 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3588] = 26
                mem[_3588 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3640 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3640 + idx + 68] = mem[_3588 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3640 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3640 + -mem[64] + 100
            if poolInfo[idx].field_1280 >= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1775 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1775] = 30
                    mem[_1775 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1778 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1778 + idx + 68] = mem[_1775 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1778 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1778 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1840 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1840] = 26
                        mem[_1840 + 32] = 'SafeMath: division by zero'
                        if not poolInfo[idx].field_768:
                            _1880 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1880] = 26
                            mem[_1880 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _1886 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_1886 + idx + 68] = mem[_1880 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1886 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1886 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2026 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2026] = 26
                                mem[_2026 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2038 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2038 + idx + 68] = mem[_2026 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2038 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2038 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2148 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2148] = 26
                                mem[_2148 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2166 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2166 + idx + 68] = mem[_2148 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2166 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2166 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2376 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2376] = 26
                            mem[_2376 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2406 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2406 + idx + 68] = mem[_2376 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2406 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2406 + -mem[64] + 100
                        _1881 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1881] = 26
                        mem[_1881 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _1887 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1887 + idx + 68] = mem[_1881 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1887 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1887 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2027] = 26
                            mem[_2027 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2039 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2039 + idx + 68] = mem[_2027 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2039 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2039 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2149] = 26
                            mem[_2149 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2167 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2167 + idx + 68] = mem[_2149 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2167 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2167 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2377 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2377] = 26
                        mem[_2377 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2408 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2408 + idx + 68] = mem[_2377 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2408 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2408 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / block.number - poolInfo[idx].field_1280 != sub_a054b70a:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1866 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1866] = 26
                    mem[_1866 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        if not poolInfo[idx].field_768:
                            _1930 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1930] = 26
                            mem[_1930 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _1937 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_1937 + idx + 68] = mem[_1930 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1937 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1937 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2180] = 26
                                mem[_2180 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2197 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2197 + idx + 68] = mem[_2180 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2197 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2197 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2374 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2374] = 26
                                mem[_2374 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2404 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2404 + idx + 68] = mem[_2374 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2404 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2404 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2690] = 26
                            mem[_2690 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2726 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2726 + idx + 68] = mem[_2690 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2726 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2726 + -mem[64] + 100
                        _1931 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1931] = 26
                        mem[_1931 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _1938 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1938 + idx + 68] = mem[_1931 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1938 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1938 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2181 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2181] = 26
                            mem[_2181 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2198 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2198 + idx + 68] = mem[_2181 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2198 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2198 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2375 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2375] = 26
                            mem[_2375 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2405 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2405 + idx + 68] = mem[_2375 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2405 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2405 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2691 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2691] = 26
                        mem[_2691 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2728 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2728 + idx + 68] = mem[_2691 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2728 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2728 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2033] = 26
                            mem[_2033 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2045 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2045 + idx + 68] = mem[_2033 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2045 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2045 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2428] = 26
                                mem[_2428 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2459 + idx + 68] = mem[_2428 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2459 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2459 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2688 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2688] = 26
                                mem[_2688 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2724 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2724 + idx + 68] = mem[_2688 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2724 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2724 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3063 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3063] = 26
                            mem[_3063 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3103 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3103 + idx + 68] = mem[_3063 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3103 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3103 + -mem[64] + 100
                        _2034 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2034] = 26
                        mem[_2034 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2046 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2046 + idx + 68] = mem[_2034 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2046 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2046 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2429 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2429] = 26
                            mem[_2429 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2460 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2460 + idx + 68] = mem[_2429 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2460 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2460 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2689 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2689] = 26
                            mem[_2689 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2725 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2725 + idx + 68] = mem[_2689 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2725 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2725 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3064 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3064] = 26
                        mem[_3064 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3105 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3105 + idx + 68] = mem[_3064 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3105 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3105 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _2186 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2186] = 26
                        mem[_2186 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2212 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2212 + idx + 68] = mem[_2186 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2212 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2212 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2752 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2752] = 26
                            mem[_2752 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2790 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2790 + idx + 68] = mem[_2752 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2790 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2790 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _3061 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3061] = 26
                            mem[_3061 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3101 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3101 + idx + 68] = mem[_3061 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3101 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3101 + -mem[64] + 100
                        if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3465 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3465] = 26
                        mem[_3465 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3499 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3499 + idx + 68] = mem[_3465 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3499 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3499 + -mem[64] + 100
                    _2187 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2187] = 26
                    mem[_2187 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2213 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2213 + idx + 68] = mem[_2187 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2213 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2213 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2753 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2753] = 26
                        mem[_2753 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2791 + idx + 68] = mem[_2753 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2791 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2791 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _3062 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3062] = 26
                        mem[_3062 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3102 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3102 + idx + 68] = mem[_3062 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3102 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3102 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3466 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3466] = 26
                    mem[_3466 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3501 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3501 + idx + 68] = mem[_3466 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3501 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3501 + -mem[64] + 100
                if 100 < sub_a054b70a:
                    revert with 'NH{q', 17
                _1824 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1824] = 30
                mem[_1824 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1827 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1827 + idx + 68] = mem[_1824 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1827 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1827 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1852 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1852] = 26
                    mem[_1852 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _1902 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1902] = 26
                        mem[_1902 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1908 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1908 + idx + 68] = mem[_1902 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1908 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1908 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2094 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2094] = 26
                            mem[_2094 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2110 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2110 + idx + 68] = mem[_2094 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2110 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2110 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2237 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2237] = 26
                            mem[_2237 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2264 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2264 + idx + 68] = mem[_2237 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2264 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2264 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2505 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2505] = 26
                        mem[_2505 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2537 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2537 + idx + 68] = mem[_2505 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2537 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2537 + -mem[64] + 100
                    _1903 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1903] = 26
                    mem[_1903 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _1909 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1909 + idx + 68] = mem[_1903 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1909 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1909 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2095 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2095] = 26
                        mem[_2095 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2111 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2111 + idx + 68] = mem[_2095 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2111 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2111 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2238] = 26
                        mem[_2238 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2265 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2265 + idx + 68] = mem[_2238 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2265 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2265 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2506 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2506] = 26
                    mem[_2506 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2539 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2539 + idx + 68] = mem[_2506 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2539 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2539 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_a054b70a + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1876 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1876] = 26
                mem[_1876 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    if not poolInfo[idx].field_768:
                        _1978 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1978] = 26
                        mem[_1978 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1986 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1986 + idx + 68] = mem[_1978 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1986 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1986 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2276 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2276] = 26
                            mem[_2276 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2311 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2311 + idx + 68] = mem[_2276 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2311 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2311 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2503] = 26
                            mem[_2503 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2535 + idx + 68] = mem[_2503 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2535 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2535 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2832 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2832] = 26
                        mem[_2832 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2878 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2878 + idx + 68] = mem[_2832 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2878 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2878 + -mem[64] + 100
                    _1979 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1979] = 26
                    mem[_1979 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _1987 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1987 + idx + 68] = mem[_1979 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1987 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1987 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2277 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2277] = 26
                        mem[_2277 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2312 + idx + 68] = mem[_2277 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2312 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2312 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2504] = 26
                        mem[_2504 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2536 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2536 + idx + 68] = mem[_2504 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2536 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2536 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2833 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2833] = 26
                    mem[_2833 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2880 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2880 + idx + 68] = mem[_2833 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2880 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2880 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2103 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2103] = 26
                        mem[_2103 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2116 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2116 + idx + 68] = mem[_2103 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2116 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2116 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2563] = 26
                            mem[_2563 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2619 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2619 + idx + 68] = mem[_2563 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2619 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2619 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2830] = 26
                            mem[_2830 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2876 + idx + 68] = mem[_2830 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2876 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2876 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3216 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3216] = 26
                        mem[_3216 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3258 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3258 + idx + 68] = mem[_3216 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3258 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3258 + -mem[64] + 100
                    _2104 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2104] = 26
                    mem[_2104 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2117 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2117 + idx + 68] = mem[_2104 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2117 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2117 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2564 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2564] = 26
                        mem[_2564 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2620 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2620 + idx + 68] = mem[_2564 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2620 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2620 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2831 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2831] = 26
                        mem[_2831 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2877 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2877 + idx + 68] = mem[_2831 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2877 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2877 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3217 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3217] = 26
                    mem[_3217 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3260 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3260 + idx + 68] = mem[_3217 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3260 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3260 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _2295 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2295] = 26
                    mem[_2295 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2328 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2328 + idx + 68] = mem[_2295 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2328 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2328 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2909 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2909] = 26
                        mem[_2909 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2979 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2979 + idx + 68] = mem[_2909 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2979 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2979 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _3214 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3214] = 26
                        mem[_3214 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3256 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3256 + idx + 68] = mem[_3214 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3256 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3256 + -mem[64] + 100
                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3618 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3618] = 26
                    mem[_3618 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3658 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3658 + idx + 68] = mem[_3618 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3658 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3658 + -mem[64] + 100
                _2296 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2296] = 26
                mem[_2296 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2329 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2329 + idx + 68] = mem[_2296 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2329 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2329 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2910 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2910] = 26
                    mem[_2910 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2980 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2980 + idx + 68] = mem[_2910 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2980 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2980 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _3215 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3215] = 26
                    mem[_3215 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3257 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3257 + idx + 68] = mem[_3215 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3257 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3257 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3619 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3619] = 26
                mem[_3619 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3660 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3660 + idx + 68] = mem[_3619 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3660 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3660 + -mem[64] + 100
            if not poolInfo[idx].field_768:
                _1774 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1774] = 30
                mem[_1774 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > block.number:
                    _1777 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1777 + idx + 68] = mem[_1774 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1777 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1777 + -mem[64] + 100
                if block.number < bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    _1839 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1839] = 26
                    mem[_1839 + 32] = 'SafeMath: division by zero'
                    _1861 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1861] = 30
                    mem[_1861 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > bonusEndBlock:
                        _1863 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1863 + idx + 68] = mem[_1861 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1863 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1863 + -mem[64] + 100
                    if bonusEndBlock < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        _1893 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1893] = 26
                        mem[_1893 + 32] = 'SafeMath: division by zero'
                        if not poolInfo[idx].field_768:
                            _2108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2108] = 26
                            mem[_2108 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2126 + idx + 68] = mem[_2108 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2126 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2126 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2585 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2585] = 26
                                mem[_2585 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2633 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2633 + idx + 68] = mem[_2585 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2633 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2633 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2852 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2852] = 26
                                mem[_2852 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2897 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2897 + idx + 68] = mem[_2852 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2897 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2897 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3237 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3237] = 26
                            mem[_3237 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3280 + idx + 68] = mem[_3237 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3280 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3280 + -mem[64] + 100
                        _2109 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2109] = 26
                        mem[_2109 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2127 + idx + 68] = mem[_2109 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2127 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2127 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2586] = 26
                            mem[_2586 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2634 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2634 + idx + 68] = mem[_2586 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2634 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2634 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2853 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2853] = 26
                            mem[_2853 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2898 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2898 + idx + 68] = mem[_2853 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2898 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2898 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3238] = 26
                        mem[_3238 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3282 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3282 + idx + 68] = mem[_3238 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3282 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3282 + -mem[64] + 100
                    if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1954 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1954] = 26
                    mem[_1954 + 32] = 'SafeMath: division by zero'
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -1:
                        revert with 'NH{q', 17
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        if not poolInfo[idx].field_768:
                            _2307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2307] = 26
                            mem[_2307 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2344 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2344 + idx + 68] = mem[_2307 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2344 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2344 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2939 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2939] = 26
                                mem[_2939 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2995 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2995 + idx + 68] = mem[_2939 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2995 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2995 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3235 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3235] = 26
                                mem[_3235 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3278 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3278 + idx + 68] = mem[_3235 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3278 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3278 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3636] = 26
                            mem[_3636 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3686 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3686 + idx + 68] = mem[_3636 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3686 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3686 + -mem[64] + 100
                        _2308 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2308] = 26
                        mem[_2308 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2345 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2345 + idx + 68] = mem[_2308 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2345 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2345 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2940 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2940] = 26
                            mem[_2940 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2996 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2996 + idx + 68] = mem[_2940 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2996 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2996 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3236 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3236] = 26
                            mem[_3236 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3279 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3279 + idx + 68] = mem[_3236 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3279 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3279 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3637 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3637] = 26
                        mem[_3637 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3688 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3688 + idx + 68] = mem[_3637 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3688 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3688 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2615 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2615] = 26
                            mem[_2615 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2658 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2658 + idx + 68] = mem[_2615 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2658 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2658 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _3330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3330] = 26
                                mem[_3330 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3394 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3394 + idx + 68] = mem[_3330 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3394 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3394 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3634 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3634] = 26
                                mem[_3634 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3684 + idx + 68] = mem[_3634 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3684 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3684 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3995 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3995] = 26
                            mem[_3995 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4043 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4043 + idx + 68] = mem[_3995 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4043 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4043 + -mem[64] + 100
                        _2616 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2616] = 26
                        mem[_2616 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2659 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2659 + idx + 68] = mem[_2616 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2659 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2659 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3331] = 26
                            mem[_3331 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3395 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3395 + idx + 68] = mem[_3331 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3395 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3395 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3635] = 26
                            mem[_3635 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3685 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3685 + idx + 68] = mem[_3635 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3685 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3685 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3996 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3996] = 26
                        mem[_3996 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4045 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4045 + idx + 68] = mem[_3996 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4045 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4045 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _2973 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2973] = 26
                        mem[_2973 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3026 + idx + 68] = mem[_2973 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3026 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3026 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3738 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3738] = 26
                            mem[_3738 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3800 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3800 + idx + 68] = mem[_3738 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3800 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3800 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _3993 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3993] = 26
                            mem[_3993 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4041 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4041 + idx + 68] = mem[_3993 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4041 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4041 + -mem[64] + 100
                        if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4295] = 26
                        mem[_4295 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4335 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4335 + idx + 68] = mem[_4295 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4335 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4335 + -mem[64] + 100
                    _2974 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2974] = 26
                    mem[_2974 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3027 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3027 + idx + 68] = mem[_2974 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3027 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3027 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3739] = 26
                        mem[_3739 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3801 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3801 + idx + 68] = mem[_3739 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3801 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3801 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _3994 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3994] = 26
                        mem[_3994 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4042 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4042 + idx + 68] = mem[_3994 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4042 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4042 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4296 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4296] = 26
                    mem[_4296 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4337 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4337 + idx + 68] = mem[_4296 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4337 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4337 + -mem[64] + 100
                if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1865 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1865] = 26
                mem[_1865 + 32] = 'SafeMath: division by zero'
                _1890 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1890] = 30
                mem[_1890 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _1897 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1897 + idx + 68] = mem[_1890 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1897 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1897 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _1953 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1953] = 26
                    mem[_1953 + 32] = 'SafeMath: division by zero'
                    if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                        revert with 'NH{q', 17
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        if not poolInfo[idx].field_768:
                            _2305 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2305] = 26
                            mem[_2305 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2342 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2342 + idx + 68] = mem[_2305 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2342 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2342 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2933 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2933] = 26
                                mem[_2933 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2993 + idx + 68] = mem[_2933 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2993 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2993 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3229] = 26
                                mem[_3229 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3274 + idx + 68] = mem[_3229 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3274 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3274 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3630] = 26
                            mem[_3630 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3678 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3678 + idx + 68] = mem[_3630 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3678 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3678 + -mem[64] + 100
                        _2306 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2306] = 26
                        mem[_2306 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2343 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2343 + idx + 68] = mem[_2306 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2343 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2343 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2934 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2934] = 26
                            mem[_2934 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2994 + idx + 68] = mem[_2934 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2994 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2994 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3230 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3230] = 26
                            mem[_3230 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3275 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3275 + idx + 68] = mem[_3230 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3275 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3275 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3631 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3631] = 26
                        mem[_3631 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3680 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3680 + idx + 68] = mem[_3631 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3680 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3680 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2613 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2613] = 26
                            mem[_2613 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2654 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2654 + idx + 68] = mem[_2613 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2654 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2654 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _3324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3324] = 26
                                mem[_3324 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3388 + idx + 68] = mem[_3324 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3388 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3388 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3628 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3628] = 26
                                mem[_3628 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3676 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3676 + idx + 68] = mem[_3628 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3676 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3676 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3991] = 26
                            mem[_3991 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4035 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4035 + idx + 68] = mem[_3991 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4035 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4035 + -mem[64] + 100
                        _2614 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2614] = 26
                        mem[_2614 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2655 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2655 + idx + 68] = mem[_2614 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2655 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2655 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3325 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3325] = 26
                            mem[_3325 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3389 + idx + 68] = mem[_3325 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3389 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3389 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3629 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3629] = 26
                            mem[_3629 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3677 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3677 + idx + 68] = mem[_3629 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3677 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3677 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3992 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3992] = 26
                        mem[_3992 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4037 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4037 + idx + 68] = mem[_3992 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4037 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4037 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _2971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2971] = 26
                        mem[_2971 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3021 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3021 + idx + 68] = mem[_2971 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3021 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3021 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3732] = 26
                            mem[_3732 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3790 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3790 + idx + 68] = mem[_3732 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3790 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3790 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _3989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3989] = 26
                            mem[_3989 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4033 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4033 + idx + 68] = mem[_3989 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4033 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4033 + -mem[64] + 100
                        if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4293 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4293] = 26
                        mem[_4293 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4329 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4329 + idx + 68] = mem[_4293 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4329 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4329 + -mem[64] + 100
                    _2972 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2972] = 26
                    mem[_2972 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3022 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3022 + idx + 68] = mem[_2972 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3022 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3022 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3733 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3733] = 26
                        mem[_3733 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3791 + idx + 68] = mem[_3733 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3791 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3791 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _3990 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3990] = 26
                        mem[_3990 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4034 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4034 + idx + 68] = mem[_3990 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4034 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4034 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4294 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4294] = 26
                    mem[_4294 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4331 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4331 + idx + 68] = mem[_4294 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4331 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4331 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2076 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2076] = 26
                mem[_2076 + 32] = 'SafeMath: division by zero'
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                    revert with 'NH{q', 17
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    if not poolInfo[idx].field_768:
                        _2611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2611] = 26
                        mem[_2611 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2652 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2652 + idx + 68] = mem[_2611 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2652 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2652 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3318 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3318] = 26
                            mem[_3318 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3386 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3386 + idx + 68] = mem[_3318 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3386 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3386 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3624] = 26
                            mem[_3624 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3672 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3672 + idx + 68] = mem[_3624 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3672 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3672 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3987] = 26
                        mem[_3987 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4029 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4029 + idx + 68] = mem[_3987 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4029 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4029 + -mem[64] + 100
                    _2612 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2612] = 26
                    mem[_2612 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2653 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2653 + idx + 68] = mem[_2612 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2653 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2653 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3319 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3319] = 26
                        mem[_3319 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3387 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3387 + idx + 68] = mem[_3319 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3387 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3387 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3625 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3625] = 26
                        mem[_3625 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3673 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3673 + idx + 68] = mem[_3625 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3673 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3673 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3988 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3988] = 26
                    mem[_3988 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4031 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4031 + idx + 68] = mem[_3988 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4031 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4031 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    if not poolInfo[idx].field_768:
                        _2969 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2969] = 26
                        mem[_2969 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3017 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3017 + idx + 68] = mem[_2969 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3017 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3017 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3730 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3730] = 26
                            mem[_3730 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3784 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3784 + idx + 68] = mem[_3730 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3784 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3784 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3985 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3985] = 26
                            mem[_3985 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4027 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4027 + idx + 68] = mem[_3985 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4027 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4027 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4291 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4291] = 26
                        mem[_4291 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4323 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4323 + idx + 68] = mem[_4291 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4323 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4323 + -mem[64] + 100
                    _2970 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2970] = 26
                    mem[_2970 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3018 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3018 + idx + 68] = mem[_2970 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3018 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3018 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3731 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3731] = 26
                        mem[_3731 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3785 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3785 + idx + 68] = mem[_3731 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3785 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3785 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3986 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3986] = 26
                        mem[_3986 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4028 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4028 + idx + 68] = mem[_3986 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4028 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4028 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4292 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4292] = 26
                    mem[_4292 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4325 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4325 + idx + 68] = mem[_4292 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4325 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4325 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3362 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3362] = 26
                    mem[_3362 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3424 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3424 + idx + 68] = mem[_3362 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3424 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3424 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4073 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4073] = 26
                        mem[_4073 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4125 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4125 + idx + 68] = mem[_4073 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4125 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4125 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _4289 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4289] = 26
                        mem[_4289 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4321 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4321 + idx + 68] = mem[_4289 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4321 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4321 + -mem[64] + 100
                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4801 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4801] = 26
                    mem[_4801 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4811 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4811 + idx + 68] = mem[_4801 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4811 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4811 + -mem[64] + 100
                _3363 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3363] = 26
                mem[_3363 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3425 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3425 + idx + 68] = mem[_3363 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3425 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3425 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4074 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4074] = 26
                    mem[_4074 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4126 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4126 + idx + 68] = mem[_4074 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4126 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4126 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
                emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6), this.address);
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    _4290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4290] = 26
                    mem[_4290 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4322 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4322 + idx + 68] = mem[_4290 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4322 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4322 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4802 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4802] = 26
                mem[_4802 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4812 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4812 + idx + 68] = mem[_4802 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4812 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4812 + -mem[64] + 100
            if 100 < sub_a054b70a:
                revert with 'NH{q', 17
            _1823 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1823] = 30
            mem[_1823 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                _1826 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1826 + idx + 68] = mem[_1823 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1826 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1826 + -mem[64] + 100
            if block.number < bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                _1851 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1851] = 26
                mem[_1851 + 32] = 'SafeMath: division by zero'
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _1889 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1889] = 30
                mem[_1889 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _1894 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1894 + idx + 68] = mem[_1889 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1894 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1894 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _1950 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1950] = 26
                    mem[_1950 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _2289 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2289] = 26
                        mem[_2289 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2326 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2326 + idx + 68] = mem[_2289 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2326 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2326 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2907] = 26
                            mem[_2907 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2975 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2975 + idx + 68] = mem[_2907 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2975 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2975 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3212 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3212] = 26
                            mem[_3212 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3254 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3254 + idx + 68] = mem[_3212 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3254 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3254 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3616 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3616] = 26
                        mem[_3616 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3654 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3654 + idx + 68] = mem[_3616 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3654 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3654 + -mem[64] + 100
                    _2290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2290] = 26
                    mem[_2290 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2327 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2327 + idx + 68] = mem[_2290 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2327 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2327 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2908 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2908] = 26
                        mem[_2908 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2976 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2976 + idx + 68] = mem[_2908 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2976 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2976 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3213 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3213] = 26
                        mem[_3213 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3255 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3255 + idx + 68] = mem[_3213 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3255 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3255 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3617 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3617] = 26
                    mem[_3617 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3656 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3656 + idx + 68] = mem[_3617 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3656 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3656 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2066 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2066] = 26
                mem[_2066 + 32] = 'SafeMath: division by zero'
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -1:
                    revert with 'NH{q', 17
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    if not poolInfo[idx].field_768:
                        _2589 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2589] = 26
                        mem[_2589 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2638 + idx + 68] = mem[_2589 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2638 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2638 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3298 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3298] = 26
                            mem[_3298 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3366 + idx + 68] = mem[_3298 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3366 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3366 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3614] = 26
                            mem[_3614 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3652 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3652 + idx + 68] = mem[_3614 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3652 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3652 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3981 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3981] = 26
                        mem[_3981 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4015 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4015 + idx + 68] = mem[_3981 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4015 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4015 + -mem[64] + 100
                    _2590 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2590] = 26
                    mem[_2590 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2639 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2639 + idx + 68] = mem[_2590 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2639 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2639 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3299] = 26
                        mem[_3299 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3367 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3367 + idx + 68] = mem[_3299 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3367 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3367 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3615] = 26
                        mem[_3615 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3653 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3653 + idx + 68] = mem[_3615 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3653 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3653 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3982 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3982] = 26
                    mem[_3982 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4017 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4017 + idx + 68] = mem[_3982 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4017 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4017 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2945 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2945] = 26
                        mem[_2945 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3007 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3007 + idx + 68] = mem[_2945 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3007 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3007 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3708] = 26
                            mem[_3708 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3768 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3768 + idx + 68] = mem[_3708 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3768 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3768 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3979 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3979] = 26
                            mem[_3979 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4013 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4013 + idx + 68] = mem[_3979 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4013 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4013 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4287 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4287] = 26
                        mem[_4287 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4315 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4315 + idx + 68] = mem[_4287 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4315 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4315 + -mem[64] + 100
                    _2946 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2946] = 26
                    mem[_2946 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3008 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3008 + idx + 68] = mem[_2946 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3008 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3008 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3709 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3709] = 26
                        mem[_3709 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3769 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3769 + idx + 68] = mem[_3709 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3769 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3769 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3980 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3980] = 26
                        mem[_3980 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4014 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4014 + idx + 68] = mem[_3980 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4014 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4014 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4288 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4288] = 26
                    mem[_4288 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4317 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4317 + idx + 68] = mem[_4288 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4317 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4317 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3340 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3340] = 26
                    mem[_3340 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3413 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3413 + idx + 68] = mem[_3340 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3413 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3413 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4061 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4061] = 26
                        mem[_4061 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4111 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4111 + idx + 68] = mem[_4061 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4111 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4111 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _4285 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4285] = 26
                        mem[_4285 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4313 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4313 + idx + 68] = mem[_4285 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4313 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4313 + -mem[64] + 100
                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4799 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4799] = 26
                    mem[_4799 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4809 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4809 + idx + 68] = mem[_4799 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4809 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4809 + -mem[64] + 100
                _3341 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3341] = 26
                mem[_3341 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3414 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3414 + idx + 68] = mem[_3341 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3414 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3414 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4062 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4062] = 26
                    mem[_4062 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4112 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4112 + idx + 68] = mem[_4062 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4112 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4112 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _4286 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4286] = 26
                    mem[_4286 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4314 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4314 + idx + 68] = mem[_4286 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4314 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4314 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4800 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4800] = 26
                mem[_4800 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4810 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4810 + idx + 68] = mem[_4800 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4810 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4810 + -mem[64] + 100
            if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1875 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1875] = 26
            mem[_1875 + 32] = 'SafeMath: division by zero'
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _1945 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1945] = 30
            mem[_1945 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _1955 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1955 + idx + 68] = mem[_1945 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1955 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1955 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _2065 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2065] = 26
                mem[_2065 + 32] = 'SafeMath: division by zero'
                if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                    revert with 'NH{q', 17
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    if not poolInfo[idx].field_768:
                        _2587 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2587] = 26
                        mem[_2587 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2636 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2636 + idx + 68] = mem[_2587 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2636 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2636 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3292 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3292] = 26
                            mem[_3292 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3364 + idx + 68] = mem[_3292 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3364 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3364 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3608 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3608] = 26
                            mem[_3608 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3648 + idx + 68] = mem[_3608 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3648 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3648 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3975 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3975] = 26
                        mem[_3975 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4007 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4007 + idx + 68] = mem[_3975 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4007 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4007 + -mem[64] + 100
                    _2588 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2588] = 26
                    mem[_2588 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2637 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2637 + idx + 68] = mem[_2588 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2637 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2637 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3293 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3293] = 26
                        mem[_3293 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3365 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3365 + idx + 68] = mem[_3293 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3365 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3365 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3609 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3609] = 26
                        mem[_3609 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3649 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3649 + idx + 68] = mem[_3609 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3649 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3649 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3976 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3976] = 26
                    mem[_3976 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4009 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4009 + idx + 68] = mem[_3976 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4009 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4009 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2943 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2943] = 26
                        mem[_2943 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3003 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3003 + idx + 68] = mem[_2943 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3003 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3003 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3702 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3702] = 26
                            mem[_3702 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3762 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3762 + idx + 68] = mem[_3702 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3762 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3762 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3973 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3973] = 26
                            mem[_3973 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4005 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4005 + idx + 68] = mem[_3973 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4005 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4005 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4283] = 26
                        mem[_4283 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4307 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4307 + idx + 68] = mem[_4283 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4307 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4307 + -mem[64] + 100
                    _2944 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2944] = 26
                    mem[_2944 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3004 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3004 + idx + 68] = mem[_2944 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3004 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3004 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3703] = 26
                        mem[_3703 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3763 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3763 + idx + 68] = mem[_3703 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3763 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3763 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3974 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3974] = 26
                        mem[_3974 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4006 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4006 + idx + 68] = mem[_3974 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4006 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4006 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4284 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4284] = 26
                    mem[_4284 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4309 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4309 + idx + 68] = mem[_4284 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4309 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4309 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3338 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3338] = 26
                    mem[_3338 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3408 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3408 + idx + 68] = mem[_3338 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3408 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3408 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4055 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4055] = 26
                        mem[_4055 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4101 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4101 + idx + 68] = mem[_4055 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4101 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4101 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _4281 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4281] = 26
                        mem[_4281 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4305 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4305 + idx + 68] = mem[_4281 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4305 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4305 + -mem[64] + 100
                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4797 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4797] = 26
                    mem[_4797 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4807 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4807 + idx + 68] = mem[_4797 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4807 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4807 + -mem[64] + 100
                _3339 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3339] = 26
                mem[_3339 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3409 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3409 + idx + 68] = mem[_3339 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3409 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3409 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4056 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4056] = 26
                    mem[_4056 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4102 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4102 + idx + 68] = mem[_4056 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4102 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4102 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _4282 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4282] = 26
                    mem[_4282 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4306 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4306 + idx + 68] = mem[_4282 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4306 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4306 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4798 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4798] = 26
                mem[_4798 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4808 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4808 + idx + 68] = mem[_4798 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4808 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4808 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _2247 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2247] = 26
            mem[_2247 + 32] = 'SafeMath: division by zero'
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                revert with 'NH{q', 17
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                if not poolInfo[idx].field_768:
                    _2941 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2941] = 26
                    mem[_2941 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3001 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3001 + idx + 68] = mem[_2941 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3001 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3001 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3696 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3696] = 26
                        mem[_3696 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3760 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3760 + idx + 68] = mem[_3696 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3760 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3760 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _3969 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3969] = 26
                        mem[_3969 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4001 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4001 + idx + 68] = mem[_3969 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4001 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4001 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4279] = 26
                    mem[_4279 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4301 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4301 + idx + 68] = mem[_4279 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4301 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4301 + -mem[64] + 100
                _2942 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2942] = 26
                mem[_2942 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3002 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3002 + idx + 68] = mem[_2942 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3002 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3002 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3697 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3697] = 26
                    mem[_3697 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3761 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3761 + idx + 68] = mem[_3697 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3761 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3761 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _3970 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3970] = 26
                    mem[_3970 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4002 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4002 + idx + 68] = mem[_3970 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4002 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4002 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4280 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4280] = 26
                mem[_4280 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4303 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4303 + idx + 68] = mem[_4280 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4303 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4303 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                if not poolInfo[idx].field_768:
                    _3336 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3336] = 26
                    mem[_3336 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3404 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3404 + idx + 68] = mem[_3336 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3404 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3404 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4053 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4053] = 26
                        mem[_4053 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4095 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4095 + idx + 68] = mem[_4053 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4095 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4095 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4277 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4277] = 26
                        mem[_4277 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4299 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4299 + idx + 68] = mem[_4277 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4299 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4299 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4795 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4795] = 26
                    mem[_4795 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4805 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4805 + idx + 68] = mem[_4795 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4805 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4805 + -mem[64] + 100
                _3337 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3337] = 26
                mem[_3337 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3405 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3405 + idx + 68] = mem[_3337 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3405 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3405 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4054 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4054] = 26
                    mem[_4054 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4096 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4096 + idx + 68] = mem[_4054 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4096 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4096 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4278 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4278] = 26
                    mem[_4278 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4300 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4300 + idx + 68] = mem[_4278 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4300 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4300 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4796 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4796] = 26
                mem[_4796 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4806 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4806 + idx + 68] = mem[_4796 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4806 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4806 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            if not poolInfo[idx].field_768:
                _3746 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3746] = 26
                mem[_3746 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _3812 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3812 + idx + 68] = mem[_3746 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3812 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3812 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4341 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4341] = 26
                    mem[_4341 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4377 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4377 + idx + 68] = mem[_4341 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4377 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4377 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4793 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4793] = 26
                    mem[_4793 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4803 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4803 + idx + 68] = mem[_4793 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4803 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4803 + -mem[64] + 100
                if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 17
                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5459 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5459] = 26
                mem[_5459 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5461 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5461 + idx + 68] = mem[_5459 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5461 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5461 + -mem[64] + 100
            _3747 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3747] = 26
            mem[_3747 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _3813 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3813 + idx + 68] = mem[_3747 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3813 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3813 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _4342 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4342] = 26
                mem[_4342 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4378 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4378 + idx + 68] = mem[_4342 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4378 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4378 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6), this.address);
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                _4794 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4794] = 26
                mem[_4794 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4804 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4804 + idx + 68] = mem[_4794 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4804 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4804 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _5460 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5460] = 26
            mem[_5460 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5463 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5463 + idx + 68] = mem[_5460 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5463 + 94] = 0
            revert with memory
              from mem[64]
               len _5463 + -mem[64] + 100
    if not arg4:
        if totalAllocPoint > -arg1 - 1:
            revert with 'NH{q', 17
        if totalAllocPoint + arg1 < totalAllocPoint:
            revert with 0, 'SafeMath: addition overflow'
        totalAllocPoint += arg1
    else:
        if sub_9e98edc6 > -arg1 - 1:
            revert with 'NH{q', 17
        if sub_9e98edc6 + arg1 < sub_9e98edc6:
            revert with 0, 'SafeMath: addition overflow'
        sub_9e98edc6 += arg1
    poolInfo.length++
    poolInfo[poolInfo.length].field_0 = arg2
    poolInfo[poolInfo.length].field_256 = arg1
    poolInfo[poolInfo.length].field_512 = 0
    poolInfo[poolInfo.length].field_768 = uint8(arg4)
    poolInfo[poolInfo.length].field_1024 = arg5
    if block.number > startBlock:
        poolInfo[poolInfo.length].field_1280 = block.number
    else:
        poolInfo[poolInfo.length].field_1280 = startBlock
    poolInfo[poolInfo.length].field_1536 = 0
}

function set(uint256 arg1, uint256 arg2, bool arg3, uint256 arg4) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    if owner != msg.sender:
        revert with 0, '!dev addr'
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    mem[0] = 7
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 7
            if block.number <= poolInfo[idx].field_1280:
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if not poolInfo[idx].field_512:
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if block.number <= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1915 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1915] = 30
                    mem[_1915 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1920 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1920 + idx + 68] = mem[_1915 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1920 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1920 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1944 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1944] = 26
                        mem[_1944 + 32] = 'SafeMath: division by zero'
                        if not poolInfo[idx].field_768:
                            _1991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1991] = 26
                            mem[_1991 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _1996 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_1996 + idx + 68] = mem[_1991 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1996 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1996 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2130 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2130] = 26
                                mem[_2130 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2149 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2149 + idx + 68] = mem[_2130 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2149 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2149 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2251] = 26
                                mem[_2251 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2274 + idx + 68] = mem[_2251 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2274 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2274 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2474 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2474] = 26
                            mem[_2474 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2508 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2508 + idx + 68] = mem[_2474 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2508 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2508 + -mem[64] + 100
                        _1992 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1992] = 26
                        mem[_1992 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _1997 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1997 + idx + 68] = mem[_1992 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1997 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1997 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2131] = 26
                            mem[_2131 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2150 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2150 + idx + 68] = mem[_2131 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2150 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2150 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2252 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2252] = 26
                            mem[_2252 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2275 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2275 + idx + 68] = mem[_2252 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2275 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2275 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2475] = 26
                        mem[_2475 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2510 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2510 + idx + 68] = mem[_2475 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2510 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2510 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_e600038d > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / block.number - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1978 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1978] = 26
                    mem[_1978 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        if not poolInfo[idx].field_768:
                            _2041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2041] = 26
                            mem[_2041 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2046 + idx + 68] = mem[_2041 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2046 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2046 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2286 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2286] = 26
                                mem[_2286 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2302 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2302 + idx + 68] = mem[_2286 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2302 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2302 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2472 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2472] = 26
                                mem[_2472 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2506 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2506 + idx + 68] = mem[_2472 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2506 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2506 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2788 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2788] = 26
                            mem[_2788 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2824 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2824 + idx + 68] = mem[_2788 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2824 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2824 + -mem[64] + 100
                        _2042 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2042] = 26
                        mem[_2042 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2047 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2047 + idx + 68] = mem[_2042 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2047 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2047 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2287 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2287] = 26
                            mem[_2287 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2303 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2303 + idx + 68] = mem[_2287 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2303 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2303 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2473 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2473] = 26
                            mem[_2473 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2507 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2507 + idx + 68] = mem[_2473 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2507 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2507 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2789] = 26
                        mem[_2789 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2826 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2826 + idx + 68] = mem[_2789 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2826 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2826 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2145 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2145] = 26
                            mem[_2145 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2154 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2154 + idx + 68] = mem[_2145 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2154 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2154 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2528] = 26
                                mem[_2528 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2562 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2562 + idx + 68] = mem[_2528 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2562 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2562 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2786 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2786] = 26
                                mem[_2786 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2822 + idx + 68] = mem[_2786 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2822 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2822 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3157] = 26
                            mem[_3157 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3203 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3203 + idx + 68] = mem[_3157 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3203 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3203 + -mem[64] + 100
                        _2146 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2146] = 26
                        mem[_2146 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2155 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2155 + idx + 68] = mem[_2146 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2155 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2155 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2529 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2529] = 26
                            mem[_2529 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2563 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2563 + idx + 68] = mem[_2529 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2563 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2563 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2787 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2787] = 26
                            mem[_2787 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2823 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2823 + idx + 68] = mem[_2787 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2823 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2823 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3158 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3158] = 26
                        mem[_3158 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3205 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3205 + idx + 68] = mem[_3158 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3205 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3205 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _2298 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2298] = 26
                        mem[_2298 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2317 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2317 + idx + 68] = mem[_2298 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2317 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2317 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2846 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2846] = 26
                            mem[_2846 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2892 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2892 + idx + 68] = mem[_2846 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2892 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2892 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _3155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3155] = 26
                            mem[_3155 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3201 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3201 + idx + 68] = mem[_3155 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3201 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3201 + -mem[64] + 100
                        if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3559] = 26
                        mem[_3559 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3605 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3605 + idx + 68] = mem[_3559 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3605 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3605 + -mem[64] + 100
                    _2299 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2299] = 26
                    mem[_2299 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2318 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2318 + idx + 68] = mem[_2299 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2318 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2318 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2847 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2847] = 26
                        mem[_2847 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2893 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2893 + idx + 68] = mem[_2847 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2893 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2893 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _3156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3156] = 26
                        mem[_3156 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3202 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3202 + idx + 68] = mem[_3156 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3202 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3202 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3560 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3560] = 26
                    mem[_3560 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3607 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3607 + idx + 68] = mem[_3560 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3607 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3607 + -mem[64] + 100
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _1926 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1926] = 30
                mem[_1926 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1931 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1931 + idx + 68] = mem[_1926 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1931 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1931 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1964 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1964] = 26
                    mem[_1964 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _2013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2013] = 26
                        mem[_2013 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2019 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2019 + idx + 68] = mem[_2013 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2019 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2019 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2201 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2201] = 26
                            mem[_2201 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2219 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2219 + idx + 68] = mem[_2201 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2219 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2219 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2342 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2342] = 26
                            mem[_2342 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2372 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2372 + idx + 68] = mem[_2342 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2372 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2372 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2607] = 26
                        mem[_2607 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2643 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2643 + idx + 68] = mem[_2607 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2643 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2643 + -mem[64] + 100
                    _2014 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2014] = 26
                    mem[_2014 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2020 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2020 + idx + 68] = mem[_2014 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2020 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2020 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2202 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2202] = 26
                        mem[_2202 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2220 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2220 + idx + 68] = mem[_2202 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2220 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2220 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2343 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2343] = 26
                        mem[_2343 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2373 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2373 + idx + 68] = mem[_2343 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2373 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2373 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2608 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2608] = 26
                    mem[_2608 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2645 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2645 + idx + 68] = mem[_2608 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2645 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2645 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1988 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1988] = 26
                mem[_1988 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    if not poolInfo[idx].field_768:
                        _2086 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2086] = 26
                        mem[_2086 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2096 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2096 + idx + 68] = mem[_2086 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2096 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2096 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2384 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2384] = 26
                            mem[_2384 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2413 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2413 + idx + 68] = mem[_2384 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2413 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2413 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2605 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2605] = 26
                            mem[_2605 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2641 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2641 + idx + 68] = mem[_2605 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2641 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2641 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2932 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2932] = 26
                        mem[_2932 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2978 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2978 + idx + 68] = mem[_2932 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2978 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2978 + -mem[64] + 100
                    _2087 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2087] = 26
                    mem[_2087 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2097 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2097 + idx + 68] = mem[_2087 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2097 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2097 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2385] = 26
                        mem[_2385 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2414 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2414 + idx + 68] = mem[_2385 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2414 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2414 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2606 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2606] = 26
                        mem[_2606 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2642 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2642 + idx + 68] = mem[_2606 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2642 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2642 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2933 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2933] = 26
                    mem[_2933 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2980 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2980 + idx + 68] = mem[_2933 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2980 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2980 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2212 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2212] = 26
                        mem[_2212 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2226 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2226 + idx + 68] = mem[_2212 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2226 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2226 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2659] = 26
                            mem[_2659 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2715 + idx + 68] = mem[_2659 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2715 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2715 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2930 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2930] = 26
                            mem[_2930 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2976 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2976 + idx + 68] = mem[_2930 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2976 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2976 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3306 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3306] = 26
                        mem[_3306 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3357 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3357 + idx + 68] = mem[_3306 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3357 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3357 + -mem[64] + 100
                    _2213 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2213] = 26
                    mem[_2213 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2227 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2227 + idx + 68] = mem[_2213 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2227 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2227 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2660 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2660] = 26
                        mem[_2660 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2716 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2716 + idx + 68] = mem[_2660 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2716 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2716 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2931 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2931] = 26
                        mem[_2931 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2977 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2977 + idx + 68] = mem[_2931 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2977 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2977 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3307 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3307] = 26
                    mem[_3307 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3359 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3359 + idx + 68] = mem[_3307 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3359 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3359 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _2396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2396] = 26
                    mem[_2396 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2431 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2431 + idx + 68] = mem[_2396 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2431 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2431 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2998 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2998] = 26
                        mem[_2998 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3071 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3071 + idx + 68] = mem[_2998 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3071 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3071 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _3304 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3304] = 26
                        mem[_3304 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3355 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3355 + idx + 68] = mem[_3304 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3355 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3355 + -mem[64] + 100
                    if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3701 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3701] = 26
                    mem[_3701 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3752 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3752 + idx + 68] = mem[_3701 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3752 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3752 + -mem[64] + 100
                _2397 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2397] = 26
                mem[_2397 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2432 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2432 + idx + 68] = mem[_2397 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2432 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2432 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2999 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2999] = 26
                    mem[_2999 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3072 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3072 + idx + 68] = mem[_2999 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3072 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3072 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _3305 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3305] = 26
                    mem[_3305 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3356 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3356 + idx + 68] = mem[_3305 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3356 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3356 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3702 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3702] = 26
                mem[_3702 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3754 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3754 + idx + 68] = mem[_3702 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3754 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3754 + -mem[64] + 100
            if poolInfo[idx].field_1280 >= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1917 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1917] = 30
                    mem[_1917 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1922 + idx + 68] = mem[_1917 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1922 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1922 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1948 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1948] = 26
                        mem[_1948 + 32] = 'SafeMath: division by zero'
                        if not poolInfo[idx].field_768:
                            _1994 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1994] = 26
                            mem[_1994 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2000 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2000 + idx + 68] = mem[_1994 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2000 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2000 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2140 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2140] = 26
                                mem[_2140 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2152 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2152 + idx + 68] = mem[_2140 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2152 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2152 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2262 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2262] = 26
                                mem[_2262 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2280 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2280 + idx + 68] = mem[_2262 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2280 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2280 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2490] = 26
                            mem[_2490 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2520 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2520 + idx + 68] = mem[_2490 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2520 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2520 + -mem[64] + 100
                        _1995 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1995] = 26
                        mem[_1995 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2001 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2001 + idx + 68] = mem[_1995 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2001 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2001 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2141 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2141] = 26
                            mem[_2141 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2153 + idx + 68] = mem[_2141 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2153 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2153 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2263 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2263] = 26
                            mem[_2263 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2281 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2281 + idx + 68] = mem[_2263 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2281 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2281 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2491 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2491] = 26
                        mem[_2491 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2522 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2522 + idx + 68] = mem[_2491 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2522 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2522 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / block.number - poolInfo[idx].field_1280 != sub_a054b70a:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1980 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1980] = 26
                    mem[_1980 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        if not poolInfo[idx].field_768:
                            _2044 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2044] = 26
                            mem[_2044 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2051 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2051 + idx + 68] = mem[_2044 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2051 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2051 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2294] = 26
                                mem[_2294 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2311 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2311 + idx + 68] = mem[_2294 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2311 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2311 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2488 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2488] = 26
                                mem[_2488 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2518 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2518 + idx + 68] = mem[_2488 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2518 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2518 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _2804 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2804] = 26
                            mem[_2804 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2840 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2840 + idx + 68] = mem[_2804 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2840 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2840 + -mem[64] + 100
                        _2045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2045] = 26
                        mem[_2045 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2052 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2052 + idx + 68] = mem[_2045 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2052 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2052 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2295 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2295] = 26
                            mem[_2295 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2312 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2312 + idx + 68] = mem[_2295 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2312 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2312 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2489 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2489] = 26
                            mem[_2489 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2519 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2519 + idx + 68] = mem[_2489 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2519 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2519 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2805] = 26
                        mem[_2805 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2842 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2842 + idx + 68] = mem[_2805 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2842 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2842 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2147 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2147] = 26
                            mem[_2147 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2159 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2159 + idx + 68] = mem[_2147 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2159 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2159 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2542 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2542] = 26
                                mem[_2542 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2573 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2573 + idx + 68] = mem[_2542 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2573 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2573 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2802] = 26
                                mem[_2802 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2838 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2838 + idx + 68] = mem[_2802 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2838 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2838 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3177 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3177] = 26
                            mem[_3177 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3217 + idx + 68] = mem[_3177 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3217 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3217 + -mem[64] + 100
                        _2148 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2148] = 26
                        mem[_2148 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2160 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2160 + idx + 68] = mem[_2148 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2160 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2160 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2543] = 26
                            mem[_2543 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2574 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2574 + idx + 68] = mem[_2543 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2574 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2574 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2803 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2803] = 26
                            mem[_2803 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2839 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2839 + idx + 68] = mem[_2803 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2839 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2839 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3178 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3178] = 26
                        mem[_3178 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3219 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3219 + idx + 68] = mem[_3178 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3219 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3219 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _2300 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2300] = 26
                        mem[_2300 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2326 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2326 + idx + 68] = mem[_2300 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2326 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2326 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2866 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2866] = 26
                            mem[_2866 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2904 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2904 + idx + 68] = mem[_2866 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2904 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2904 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _3175 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3175] = 26
                            mem[_3175 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3215 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3215 + idx + 68] = mem[_3175 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3215 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3215 + -mem[64] + 100
                        if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3579 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3579] = 26
                        mem[_3579 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3613 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3613 + idx + 68] = mem[_3579 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3613 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3613 + -mem[64] + 100
                    _2301 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2301] = 26
                    mem[_2301 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2327 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2327 + idx + 68] = mem[_2301 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2327 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2327 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2867 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2867] = 26
                        mem[_2867 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2905 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2905 + idx + 68] = mem[_2867 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2905 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2905 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _3176 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3176] = 26
                        mem[_3176 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3216 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3216 + idx + 68] = mem[_3176 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3216 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3216 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3580 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3580] = 26
                    mem[_3580 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3615 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3615 + idx + 68] = mem[_3580 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3615 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3615 + -mem[64] + 100
                if 100 < sub_a054b70a:
                    revert with 'NH{q', 17
                _1930 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1930] = 30
                mem[_1930 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1933 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1933 + idx + 68] = mem[_1930 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1933 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1933 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1966 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1966] = 26
                    mem[_1966 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _2016 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2016] = 26
                        mem[_2016 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2022 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2022 + idx + 68] = mem[_2016 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2022 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2022 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2208 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2208] = 26
                            mem[_2208 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2224 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2224 + idx + 68] = mem[_2208 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2224 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2224 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2351 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2351] = 26
                            mem[_2351 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2378 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2378 + idx + 68] = mem[_2351 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2378 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2378 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2619 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2619] = 26
                        mem[_2619 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2651 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2651 + idx + 68] = mem[_2619 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2651 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2651 + -mem[64] + 100
                    _2017 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2017] = 26
                    mem[_2017 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2023 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2023 + idx + 68] = mem[_2017 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2023 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2023 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2209 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2209] = 26
                        mem[_2209 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2225 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2225 + idx + 68] = mem[_2209 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2225 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2225 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2352 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2352] = 26
                        mem[_2352 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2379 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2379 + idx + 68] = mem[_2352 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2379 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2379 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2620 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2620] = 26
                    mem[_2620 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2653 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2653 + idx + 68] = mem[_2620 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2653 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2653 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_a054b70a + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1990 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1990] = 26
                mem[_1990 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    if not poolInfo[idx].field_768:
                        _2092 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2092] = 26
                        mem[_2092 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2100 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2100 + idx + 68] = mem[_2092 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2100 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2100 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2390] = 26
                            mem[_2390 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2425 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2425 + idx + 68] = mem[_2390 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2425 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2425 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2617] = 26
                            mem[_2617 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2649 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2649 + idx + 68] = mem[_2617 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2649 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2649 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2946 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2946] = 26
                        mem[_2946 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2992 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2992 + idx + 68] = mem[_2946 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2992 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2992 + -mem[64] + 100
                    _2093 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2093] = 26
                    mem[_2093 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2101 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2101 + idx + 68] = mem[_2093 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2101 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2101 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2391 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2391] = 26
                        mem[_2391 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2426 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2426 + idx + 68] = mem[_2391 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2426 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2426 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2618 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2618] = 26
                        mem[_2618 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2650 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2650 + idx + 68] = mem[_2618 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2650 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2650 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2947 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2947] = 26
                    mem[_2947 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2994 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2994 + idx + 68] = mem[_2947 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2994 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2994 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _2217 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2217] = 26
                        mem[_2217 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2230 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2230 + idx + 68] = mem[_2217 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2230 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2230 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2677 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2677] = 26
                            mem[_2677 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2733 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2733 + idx + 68] = mem[_2677 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2733 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2733 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2944] = 26
                            mem[_2944 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2990 + idx + 68] = mem[_2944 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2990 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2990 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3330 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3330] = 26
                        mem[_3330 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3372 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3372 + idx + 68] = mem[_3330 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3372 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3372 + -mem[64] + 100
                    _2218 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2218] = 26
                    mem[_2218 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2231 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2231 + idx + 68] = mem[_2218 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2231 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2231 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2678 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2678] = 26
                        mem[_2678 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2734 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2734 + idx + 68] = mem[_2678 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2734 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2734 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _2945 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2945] = 26
                        mem[_2945 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2991 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2991 + idx + 68] = mem[_2945 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2991 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2991 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3331 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3331] = 26
                    mem[_3331 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3374 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3374 + idx + 68] = mem[_3331 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3374 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3374 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _2409 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2409] = 26
                    mem[_2409 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2442 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2442 + idx + 68] = mem[_2409 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2442 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2442 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3023 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3023] = 26
                        mem[_3023 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3093 + idx + 68] = mem[_3023 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3093 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3093 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _3328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3328] = 26
                        mem[_3328 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3370 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3370 + idx + 68] = mem[_3328 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3370 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3370 + -mem[64] + 100
                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3732 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3732] = 26
                    mem[_3732 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3772 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3772 + idx + 68] = mem[_3732 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3772 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3772 + -mem[64] + 100
                _2410 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2410] = 26
                mem[_2410 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _2443 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2443 + idx + 68] = mem[_2410 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2443 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2443 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3024 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3024] = 26
                    mem[_3024 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3094 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3094 + idx + 68] = mem[_3024 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3094 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3094 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _3329 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3329] = 26
                    mem[_3329 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3371 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3371 + idx + 68] = mem[_3329 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3371 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3371 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3733 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3733] = 26
                mem[_3733 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _3774 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3774 + idx + 68] = mem[_3733 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3774 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3774 + -mem[64] + 100
            if not poolInfo[idx].field_768:
                _1916 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1916] = 30
                mem[_1916 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > block.number:
                    _1921 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1921 + idx + 68] = mem[_1916 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1921 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1921 + -mem[64] + 100
                if block.number < bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    _1947 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1947] = 26
                    mem[_1947 + 32] = 'SafeMath: division by zero'
                    _1975 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1975] = 30
                    mem[_1975 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > bonusEndBlock:
                        _1977 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1977 + idx + 68] = mem[_1975 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1977 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1977 + -mem[64] + 100
                    if bonusEndBlock < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        _2007 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2007] = 26
                        mem[_2007 + 32] = 'SafeMath: division by zero'
                        if not poolInfo[idx].field_768:
                            _2222 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2222] = 26
                            mem[_2222 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2240 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2240 + idx + 68] = mem[_2222 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2240 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2240 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _2699 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2699] = 26
                                mem[_2699 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _2747 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2747 + idx + 68] = mem[_2699 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2747 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2747 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _2966 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2966] = 26
                                mem[_2966 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3011 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3011 + idx + 68] = mem[_2966 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3011 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3011 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3351 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3351] = 26
                            mem[_3351 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3394 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3394 + idx + 68] = mem[_3351 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3394 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3394 + -mem[64] + 100
                        _2223 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2223] = 26
                        mem[_2223 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2241 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2241 + idx + 68] = mem[_2223 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2241 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2241 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _2700 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2700] = 26
                            mem[_2700 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2748 + idx + 68] = mem[_2700 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2748 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2748 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _2967 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2967] = 26
                            mem[_2967 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3012 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3012 + idx + 68] = mem[_2967 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3012 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3012 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3352 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3352] = 26
                        mem[_3352 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3396 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3396 + idx + 68] = mem[_3352 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3396 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3396 + -mem[64] + 100
                    if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2068 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2068] = 26
                    mem[_2068 + 32] = 'SafeMath: division by zero'
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -1:
                        revert with 'NH{q', 17
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        if not poolInfo[idx].field_768:
                            _2421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2421] = 26
                            mem[_2421 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2458 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2458 + idx + 68] = mem[_2421 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2458 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2458 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _3053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3053] = 26
                                mem[_3053 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3109 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3109 + idx + 68] = mem[_3053 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3109 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3109 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3349 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3349] = 26
                                mem[_3349 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3392 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3392 + idx + 68] = mem[_3349 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3392 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3392 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3750] = 26
                            mem[_3750 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3800 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3800 + idx + 68] = mem[_3750 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3800 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3800 + -mem[64] + 100
                        _2422 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2422] = 26
                        mem[_2422 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2459 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2459 + idx + 68] = mem[_2422 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2459 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2459 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3054 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3054] = 26
                            mem[_3054 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3110 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3110 + idx + 68] = mem[_3054 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3110 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3110 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3350] = 26
                            mem[_3350 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3393 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3393 + idx + 68] = mem[_3350 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3393 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3393 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3751 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3751] = 26
                        mem[_3751 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3802 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3802 + idx + 68] = mem[_3751 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3802 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3802 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2729] = 26
                            mem[_2729 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2772 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2772 + idx + 68] = mem[_2729 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2772 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2772 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _3444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3444] = 26
                                mem[_3444 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3508 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3508 + idx + 68] = mem[_3444 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3508 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3508 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3748] = 26
                                mem[_3748 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3798 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3798 + idx + 68] = mem[_3748 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3798 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3798 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4109 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4109] = 26
                            mem[_4109 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4157 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4157 + idx + 68] = mem[_4109 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4157 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4157 + -mem[64] + 100
                        _2730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2730] = 26
                        mem[_2730 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2773 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2773 + idx + 68] = mem[_2730 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2773 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2773 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3445] = 26
                            mem[_3445 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3509 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3509 + idx + 68] = mem[_3445 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3509 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3509 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3749] = 26
                            mem[_3749 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3799 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3799 + idx + 68] = mem[_3749 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3799 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3799 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4110] = 26
                        mem[_4110 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4159 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4159 + idx + 68] = mem[_4110 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4159 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4159 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _3087 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3087] = 26
                        mem[_3087 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3140 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3140 + idx + 68] = mem[_3087 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3140 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3140 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3852 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3852] = 26
                            mem[_3852 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3914 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3914 + idx + 68] = mem[_3852 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3914 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3914 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _4107 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4107] = 26
                            mem[_4107 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4155 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4155 + idx + 68] = mem[_4107 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4155 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4155 + -mem[64] + 100
                        if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4409 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4409] = 26
                        mem[_4409 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4449 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4449 + idx + 68] = mem[_4409 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4449 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4449 + -mem[64] + 100
                    _3088 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3088] = 26
                    mem[_3088 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3141 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3141 + idx + 68] = mem[_3088 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3141 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3141 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3853 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3853] = 26
                        mem[_3853 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3915 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3915 + idx + 68] = mem[_3853 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3915 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3915 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _4108 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4108] = 26
                        mem[_4108 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4156 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4156 + idx + 68] = mem[_4108 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4156 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4156 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4410 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4410] = 26
                    mem[_4410 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4451 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4451 + idx + 68] = mem[_4410 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4451 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4451 + -mem[64] + 100
                if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1979 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1979] = 26
                mem[_1979 + 32] = 'SafeMath: division by zero'
                _2004 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2004] = 30
                mem[_2004 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _2011 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2011 + idx + 68] = mem[_2004 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2011 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2011 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _2067 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2067] = 26
                    mem[_2067 + 32] = 'SafeMath: division by zero'
                    if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                        revert with 'NH{q', 17
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        if not poolInfo[idx].field_768:
                            _2419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2419] = 26
                            mem[_2419 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2456 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2456 + idx + 68] = mem[_2419 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2456 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2456 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _3047 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3047] = 26
                                mem[_3047 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3107 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3107 + idx + 68] = mem[_3047 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3107 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3107 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3343 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3343] = 26
                                mem[_3343 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3388 + idx + 68] = mem[_3343 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3388 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3388 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _3744 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3744] = 26
                            mem[_3744 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3792 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3792 + idx + 68] = mem[_3744 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3792 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3792 + -mem[64] + 100
                        _2420 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2420] = 26
                        mem[_2420 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2457 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2457 + idx + 68] = mem[_2420 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2457 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2457 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3048] = 26
                            mem[_3048 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3108 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3108 + idx + 68] = mem[_3048 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3108 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3108 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3344 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3344] = 26
                            mem[_3344 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3389 + idx + 68] = mem[_3344 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3389 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3389 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3745 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3745] = 26
                        mem[_3745 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3794 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3794 + idx + 68] = mem[_3745 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3794 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3794 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        if not poolInfo[idx].field_768:
                            _2727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2727] = 26
                            mem[_2727 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2768 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2768 + idx + 68] = mem[_2727 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2768 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2768 + -mem[64] + 100
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                mem[mem[64]] = 0
                                emit Mint(0, this.address);
                                _3438 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3438] = 26
                                mem[_3438 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3502 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3502 + idx + 68] = mem[_3438 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3502 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3502 + -mem[64] + 100
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sushiAddress)
                            call sushiAddress.mint(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0 / totalAllocPoint
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                _3742 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3742] = 26
                                mem[_3742 + 32] = 'SafeMath: division by zero'
                                if poolInfo[idx].field_512 > 0:
                                    if not poolInfo[idx].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                    poolInfo[idx].field_1280 = block.number
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    continue 
                                _3790 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3790 + idx + 68] = mem[_3742 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3790 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _3790 + -mem[64] + 100
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 'NH{q', 17
                            if not 0 / totalAllocPoint:
                                revert with 'NH{q', 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _4105 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4105] = 26
                            mem[_4105 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4149 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4149 + idx + 68] = mem[_4105 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4149 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4149 + -mem[64] + 100
                        _2728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2728] = 26
                        mem[_2728 + 32] = 'SafeMath: division by zero'
                        if sub_9e98edc6 <= 0:
                            _2769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2769 + idx + 68] = mem[_2728 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2769 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2769 + -mem[64] + 100
                        if not sub_9e98edc6:
                            revert with 'NH{q', 18
                        if not 0 / sub_9e98edc6:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3439 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3439] = 26
                            mem[_3439 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3503 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3503 + idx + 68] = mem[_3439 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3503 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3503 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / sub_9e98edc6
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / sub_9e98edc6
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / sub_9e98edc6
                        emit Mint((0 / sub_9e98edc6), this.address);
                        if not 0 / sub_9e98edc6:
                            _3743 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3743] = 26
                            mem[_3743 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3791 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3791 + idx + 68] = mem[_3743 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3791 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3791 + -mem[64] + 100
                        if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                            revert with 'NH{q', 17
                        if not 0 / sub_9e98edc6:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4106] = 26
                        mem[_4106 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4151 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4151 + idx + 68] = mem[_4106 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4151 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4151 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not poolInfo[idx].field_768:
                        _3085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3085] = 26
                        mem[_3085 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3135 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3135 + idx + 68] = mem[_3085 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3135 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3135 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3846 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3846] = 26
                            mem[_3846 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3904 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3904 + idx + 68] = mem[_3846 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3904 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3904 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                        emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            _4103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4103] = 26
                            mem[_4103 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4147 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4147 + idx + 68] = mem[_4103 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4147 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4147 + -mem[64] + 100
                        if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4407] = 26
                        mem[_4407 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4443 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4443 + idx + 68] = mem[_4407 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4443 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4443 + -mem[64] + 100
                    _3086 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3086] = 26
                    mem[_3086 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3136 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3136 + idx + 68] = mem[_3086 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3136 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3136 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3847 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3847] = 26
                        mem[_3847 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3905 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3905 + idx + 68] = mem[_3847 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3905 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3905 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                    emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        _4104 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4104] = 26
                        mem[_4104 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4148 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4148 + idx + 68] = mem[_4104 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4148 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4148 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4408 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4408] = 26
                    mem[_4408 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4445 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4445 + idx + 68] = mem[_4408 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4445 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4445 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2190 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2190] = 26
                mem[_2190 + 32] = 'SafeMath: division by zero'
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                    revert with 'NH{q', 17
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    if not poolInfo[idx].field_768:
                        _2725 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2725] = 26
                        mem[_2725 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2766 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2766 + idx + 68] = mem[_2725 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2766 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2766 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3432] = 26
                            mem[_3432 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3500 + idx + 68] = mem[_3432 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3500 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3500 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3738 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3738] = 26
                            mem[_3738 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3786 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3786 + idx + 68] = mem[_3738 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3786 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3786 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4101 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4101] = 26
                        mem[_4101 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4143 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4143 + idx + 68] = mem[_4101 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4143 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4143 + -mem[64] + 100
                    _2726 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2726] = 26
                    mem[_2726 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2767 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2767 + idx + 68] = mem[_2726 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2767 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2767 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3433 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3433] = 26
                        mem[_3433 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3501 + idx + 68] = mem[_3433 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3501 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3501 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3739] = 26
                        mem[_3739 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3787 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3787 + idx + 68] = mem[_3739 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3787 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3787 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4102 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4102] = 26
                    mem[_4102 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4145 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4145 + idx + 68] = mem[_4102 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4145 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4145 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    if not poolInfo[idx].field_768:
                        _3083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3083] = 26
                        mem[_3083 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3131 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3131 + idx + 68] = mem[_3083 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3131 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3131 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3844] = 26
                            mem[_3844 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3898 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3898 + idx + 68] = mem[_3844 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3898 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3898 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _4099 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4099] = 26
                            mem[_4099 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4141 + idx + 68] = mem[_4099 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4141 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4141 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4405 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4405] = 26
                        mem[_4405 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4437 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4437 + idx + 68] = mem[_4405 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4437 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4437 + -mem[64] + 100
                    _3084 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3084] = 26
                    mem[_3084 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3132 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3132 + idx + 68] = mem[_3084 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3132 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3132 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3845 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3845] = 26
                        mem[_3845 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3899 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3899 + idx + 68] = mem[_3845 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3899 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3899 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _4100 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4100] = 26
                        mem[_4100 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4142 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4142 + idx + 68] = mem[_4100 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4142 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4142 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4406 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4406] = 26
                    mem[_4406 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4439 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4439 + idx + 68] = mem[_4406 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4439 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4439 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3476 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3476] = 26
                    mem[_3476 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3538 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3538 + idx + 68] = mem[_3476 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3538 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3538 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4187 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4187] = 26
                        mem[_4187 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4239 + idx + 68] = mem[_4187 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4239 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4239 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                    emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        _4403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4403] = 26
                        mem[_4403 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4435 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4435 + idx + 68] = mem[_4403 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4435 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4435 + -mem[64] + 100
                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4917 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4917] = 26
                    mem[_4917 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4927 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4927 + idx + 68] = mem[_4917 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4927 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4927 + -mem[64] + 100
                _3477 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3477] = 26
                mem[_3477 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3539 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3539 + idx + 68] = mem[_3477 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3539 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3539 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4188 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4188] = 26
                    mem[_4188 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4240 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4240 + idx + 68] = mem[_4188 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4240 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4240 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
                emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6), this.address);
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    _4404 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4404] = 26
                    mem[_4404 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4436 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4436 + idx + 68] = mem[_4404 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4436 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4436 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4918 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4918] = 26
                mem[_4918 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4928 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4928 + idx + 68] = mem[_4918 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4928 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4928 + -mem[64] + 100
            if 100 < sub_a054b70a:
                revert with 'NH{q', 17
            _1929 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1929] = 30
            mem[_1929 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                _1932 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1932 + idx + 68] = mem[_1929 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1932 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1932 + -mem[64] + 100
            if block.number < bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                _1965 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1965] = 26
                mem[_1965 + 32] = 'SafeMath: division by zero'
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _2003 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2003] = 30
                mem[_2003 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _2008 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2008 + idx + 68] = mem[_2003 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2008 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _2008 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _2064 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2064] = 26
                    mem[_2064 + 32] = 'SafeMath: division by zero'
                    if not poolInfo[idx].field_768:
                        _2403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2403] = 26
                        mem[_2403 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2440 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2440 + idx + 68] = mem[_2403 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2440 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2440 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3021 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3021] = 26
                            mem[_3021 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3089 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3089 + idx + 68] = mem[_3021 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3089 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3089 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3326] = 26
                            mem[_3326 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3368 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3368 + idx + 68] = mem[_3326 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3368 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3368 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _3730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3730] = 26
                        mem[_3730 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3768 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3768 + idx + 68] = mem[_3730 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3768 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3768 + -mem[64] + 100
                    _2404 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2404] = 26
                    mem[_2404 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2441 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2441 + idx + 68] = mem[_2404 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2441 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2441 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3022 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3022] = 26
                        mem[_3022 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3090 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3090 + idx + 68] = mem[_3022 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3090 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3090 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3327] = 26
                        mem[_3327 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3369 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3369 + idx + 68] = mem[_3327 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3369 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3369 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3731 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3731] = 26
                    mem[_3731 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3770 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3770 + idx + 68] = mem[_3731 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3770 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3770 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2180 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2180] = 26
                mem[_2180 + 32] = 'SafeMath: division by zero'
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -1:
                    revert with 'NH{q', 17
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    if not poolInfo[idx].field_768:
                        _2703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2703] = 26
                        mem[_2703 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2752 + idx + 68] = mem[_2703 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2752 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2752 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3412 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3412] = 26
                            mem[_3412 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3480 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3480 + idx + 68] = mem[_3412 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3480 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3480 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3728] = 26
                            mem[_3728 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3766 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3766 + idx + 68] = mem[_3728 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3766 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3766 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4095 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4095] = 26
                        mem[_4095 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4129 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4129 + idx + 68] = mem[_4095 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4129 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4129 + -mem[64] + 100
                    _2704 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2704] = 26
                    mem[_2704 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2753 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2753 + idx + 68] = mem[_2704 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2753 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2753 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3413 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3413] = 26
                        mem[_3413 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3481 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3481 + idx + 68] = mem[_3413 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3481 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3481 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3729 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3729] = 26
                        mem[_3729 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3767 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3767 + idx + 68] = mem[_3729 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3767 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3767 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4096 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4096] = 26
                    mem[_4096 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4131 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4131 + idx + 68] = mem[_4096 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4131 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4131 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _3059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3059] = 26
                        mem[_3059 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3121 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3121 + idx + 68] = mem[_3059 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3121 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3121 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3822] = 26
                            mem[_3822 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3882 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3882 + idx + 68] = mem[_3822 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3882 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3882 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _4093 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4093] = 26
                            mem[_4093 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4127 + idx + 68] = mem[_4093 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4127 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4127 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4401 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4401] = 26
                        mem[_4401 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4429 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4429 + idx + 68] = mem[_4401 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4429 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4429 + -mem[64] + 100
                    _3060 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3060] = 26
                    mem[_3060 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3122 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3122 + idx + 68] = mem[_3060 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3122 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3122 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3823 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3823] = 26
                        mem[_3823 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3883 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3883 + idx + 68] = mem[_3823 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3883 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3883 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _4094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4094] = 26
                        mem[_4094 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4128 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4128 + idx + 68] = mem[_4094 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4128 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4128 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4402 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4402] = 26
                    mem[_4402 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4431 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4431 + idx + 68] = mem[_4402 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4431 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4431 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3454] = 26
                    mem[_3454 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3527 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3527 + idx + 68] = mem[_3454 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3527 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3527 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4175] = 26
                        mem[_4175 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4225 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4225 + idx + 68] = mem[_4175 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4225 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4225 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _4399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4399] = 26
                        mem[_4399 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4427 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4427 + idx + 68] = mem[_4399 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4427 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4427 + -mem[64] + 100
                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4915 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4915] = 26
                    mem[_4915 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4925 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4925 + idx + 68] = mem[_4915 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4925 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4925 + -mem[64] + 100
                _3455 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3455] = 26
                mem[_3455 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3528 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3528 + idx + 68] = mem[_3455 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3528 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3528 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4176 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4176] = 26
                    mem[_4176 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4226 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4226 + idx + 68] = mem[_4176 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4226 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4226 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _4400 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4400] = 26
                    mem[_4400 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4428 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4428 + idx + 68] = mem[_4400 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4428 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4428 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4916 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4916] = 26
                mem[_4916 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4926 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4926 + idx + 68] = mem[_4916 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4926 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4926 + -mem[64] + 100
            if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1989 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1989] = 26
            mem[_1989 + 32] = 'SafeMath: division by zero'
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _2059 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2059] = 30
            mem[_2059 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _2069 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2069 + idx + 68] = mem[_2059 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2069 + 98] = 0
                revert with memory
                  from mem[64]
                   len _2069 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _2179 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2179] = 26
                mem[_2179 + 32] = 'SafeMath: division by zero'
                if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                    revert with 'NH{q', 17
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    if not poolInfo[idx].field_768:
                        _2701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2701] = 26
                        mem[_2701 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2750 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2750 + idx + 68] = mem[_2701 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2750 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2750 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3406 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3406] = 26
                            mem[_3406 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3478 + idx + 68] = mem[_3406 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3478 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3478 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _3722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3722] = 26
                            mem[_3722 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3762 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3762 + idx + 68] = mem[_3722 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3762 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3762 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4089] = 26
                        mem[_4089 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4121 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4121 + idx + 68] = mem[_4089 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4121 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4121 + -mem[64] + 100
                    _2702 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2702] = 26
                    mem[_2702 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _2751 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2751 + idx + 68] = mem[_2702 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2751 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2751 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3407] = 26
                        mem[_3407 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3479 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3479 + idx + 68] = mem[_3407 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3479 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3479 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _3723 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3723] = 26
                        mem[_3723 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3763 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3763 + idx + 68] = mem[_3723 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3763 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3763 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4090 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4090] = 26
                    mem[_4090 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4123 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4123 + idx + 68] = mem[_4090 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4123 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4123 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    if not poolInfo[idx].field_768:
                        _3057 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3057] = 26
                        mem[_3057 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _3117 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3117 + idx + 68] = mem[_3057 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3117 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3117 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _3816 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3816] = 26
                            mem[_3816 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _3876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3876 + idx + 68] = mem[_3816 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3876 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3876 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.mint(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _4087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4087] = 26
                            mem[_4087 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _4119 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_4119 + idx + 68] = mem[_4087 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4119 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4119 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _4397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4397] = 26
                        mem[_4397 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4421 + idx + 68] = mem[_4397 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4421 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4421 + -mem[64] + 100
                    _3058 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3058] = 26
                    mem[_3058 + 32] = 'SafeMath: division by zero'
                    if sub_9e98edc6 <= 0:
                        _3118 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3118 + idx + 68] = mem[_3058 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3118 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3118 + -mem[64] + 100
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    if not 0 / sub_9e98edc6:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3817 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3817] = 26
                        mem[_3817 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3877 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3877 + idx + 68] = mem[_3817 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3877 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3877 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / sub_9e98edc6
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / sub_9e98edc6
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / sub_9e98edc6
                    emit Mint((0 / sub_9e98edc6), this.address);
                    if not 0 / sub_9e98edc6:
                        _4088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4088] = 26
                        mem[_4088 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4120 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4120 + idx + 68] = mem[_4088 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4120 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4120 + -mem[64] + 100
                    if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                        revert with 'NH{q', 17
                    if not 0 / sub_9e98edc6:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4398 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4398] = 26
                    mem[_4398 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4423 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4423 + idx + 68] = mem[_4398 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4423 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4423 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not poolInfo[idx].field_768:
                    _3452 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3452] = 26
                    mem[_3452 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3522 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3522 + idx + 68] = mem[_3452 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3522 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3522 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4169 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4169] = 26
                        mem[_4169 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4215 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4215 + idx + 68] = mem[_4169 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4215 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4215 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _4395 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4395] = 26
                        mem[_4395 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4419 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4419 + idx + 68] = mem[_4395 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4419 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4419 + -mem[64] + 100
                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4913 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4913] = 26
                    mem[_4913 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4923 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4923 + idx + 68] = mem[_4913 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4923 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4923 + -mem[64] + 100
                _3453 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3453] = 26
                mem[_3453 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3523 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3523 + idx + 68] = mem[_3453 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3523 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3523 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4170 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4170] = 26
                    mem[_4170 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4216 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4216 + idx + 68] = mem[_4170 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4216 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4216 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    _4396 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4396] = 26
                    mem[_4396 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4420 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4420 + idx + 68] = mem[_4396 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4420 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4420 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4914 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4914] = 26
                mem[_4914 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4924 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4924 + idx + 68] = mem[_4914 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4924 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4924 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _2361 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2361] = 26
            mem[_2361 + 32] = 'SafeMath: division by zero'
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                revert with 'NH{q', 17
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                if not poolInfo[idx].field_768:
                    _3055 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3055] = 26
                    mem[_3055 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3115 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3115 + idx + 68] = mem[_3055 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3115 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3115 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _3810 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3810] = 26
                        mem[_3810 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _3874 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3874 + idx + 68] = mem[_3810 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3874 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3874 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4083] = 26
                        mem[_4083 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4115 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4115 + idx + 68] = mem[_4083 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4115 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4115 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4393 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4393] = 26
                    mem[_4393 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4415 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4415 + idx + 68] = mem[_4393 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4415 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4415 + -mem[64] + 100
                _3056 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3056] = 26
                mem[_3056 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3116 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3116 + idx + 68] = mem[_3056 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3116 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3116 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _3811 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3811] = 26
                    mem[_3811 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _3875 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3875 + idx + 68] = mem[_3811 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3875 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3875 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4084 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4084] = 26
                    mem[_4084 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4116 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4116 + idx + 68] = mem[_4084 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4116 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4116 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4394 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4394] = 26
                mem[_4394 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4417 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4417 + idx + 68] = mem[_4394 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4417 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4417 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                if not poolInfo[idx].field_768:
                    _3450 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3450] = 26
                    mem[_3450 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _3518 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3518 + idx + 68] = mem[_3450 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3518 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3518 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _4167 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4167] = 26
                        mem[_4167 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4209 + idx + 68] = mem[_4167 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4209 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4209 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.mint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _4391 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4391] = 26
                        mem[_4391 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _4413 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_4413 + idx + 68] = mem[_4391 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4413 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4413 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4911 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4911] = 26
                    mem[_4911 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4921 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4921 + idx + 68] = mem[_4911 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4921 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4921 + -mem[64] + 100
                _3451 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3451] = 26
                mem[_3451 + 32] = 'SafeMath: division by zero'
                if sub_9e98edc6 <= 0:
                    _3519 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3519 + idx + 68] = mem[_3451 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3519 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3519 + -mem[64] + 100
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                if not 0 / sub_9e98edc6:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4168 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4168] = 26
                    mem[_4168 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4210 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4210 + idx + 68] = mem[_4168 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4210 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4210 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / sub_9e98edc6
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), 0 / sub_9e98edc6
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / sub_9e98edc6
                emit Mint((0 / sub_9e98edc6), this.address);
                if not 0 / sub_9e98edc6:
                    _4392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4392] = 26
                    mem[_4392 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4414 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4414 + idx + 68] = mem[_4392 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4414 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4414 + -mem[64] + 100
                if 0 / sub_9e98edc6 and 10^12 > -1 / 0 / sub_9e98edc6:
                    revert with 'NH{q', 17
                if not 0 / sub_9e98edc6:
                    revert with 'NH{q', 18
                if 10^12 * 0 / sub_9e98edc6 / 0 / sub_9e98edc6 != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4912 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4912] = 26
                mem[_4912 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / sub_9e98edc6 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4922 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4922 + idx + 68] = mem[_4912 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4922 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4922 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            if not poolInfo[idx].field_768:
                _3860 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3860] = 26
                mem[_3860 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _3926 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3926 + idx + 68] = mem[_3860 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3926 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3926 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _4455 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4455] = 26
                    mem[_4455 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4491 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4491 + idx + 68] = mem[_4455 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4491 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4491 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.mint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _4909 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4909] = 26
                    mem[_4909 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _4919 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4919 + idx + 68] = mem[_4909 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4919 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _4919 + -mem[64] + 100
                if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 17
                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5579 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5579] = 26
                mem[_5579 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _5581 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_5581 + idx + 68] = mem[_5579 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5581 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5581 + -mem[64] + 100
            _3861 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3861] = 26
            mem[_3861 + 32] = 'SafeMath: division by zero'
            if sub_9e98edc6 <= 0:
                _3927 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3927 + idx + 68] = mem[_3861 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3927 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3927 + -mem[64] + 100
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _4456 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4456] = 26
                mem[_4456 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4492 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4492 + idx + 68] = mem[_4456 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4492 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4492 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            require ext_code.size(sushiAddress)
            call sushiAddress.mint(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6
            emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6), this.address);
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                _4910 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4910] = 26
                mem[_4910 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _4920 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4920 + idx + 68] = mem[_4910 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4920 + 94] = 0
                revert with memory
                  from mem[64]
                   len _4920 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6:
                revert with 'NH{q', 18
            if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _5580 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5580] = 26
            mem[_5580 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / sub_9e98edc6 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _5583 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_5583 + idx + 68] = mem[_5580 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5583 + 94] = 0
            revert with memory
              from mem[64]
               len _5583 + -mem[64] + 100
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    if not poolInfo[arg1].field_768:
        if poolInfo[arg1].field_256 > totalAllocPoint:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if totalAllocPoint < poolInfo[arg1].field_256:
            revert with 'NH{q', 17
        if totalAllocPoint - poolInfo[arg1].field_256 > -arg2 - 1:
            revert with 'NH{q', 17
        if arg2 < 0:
            revert with 0, 'SafeMath: addition overflow'
        totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    else:
        if poolInfo[arg1].field_256 > sub_9e98edc6:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if sub_9e98edc6 < poolInfo[arg1].field_256:
            revert with 'NH{q', 17
        if sub_9e98edc6 - poolInfo[arg1].field_256 > -arg2 - 1:
            revert with 'NH{q', 17
        if arg2 < 0:
            revert with 0, 'SafeMath: addition overflow'
        sub_9e98edc6 = sub_9e98edc6 - poolInfo[arg1].field_256 + arg2
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    poolInfo[arg1].field_256 = arg2
    poolInfo[arg1].field_1024 = arg4
}



}

contract main {




// =====================  Runtime code  =====================


uint8 stor0;
uint8 stor0; offset 8
uint16 stor0;
uint256 totalShares;
uint256 totalReleased;
mapping of uint256 shares;
mapping of uint256 released;
array of address payee;
mapping of uint256 totalReleased;
mapping of uint256 released;
address stor101;
address routerAddress;
address uniswapV2PairAddress;
address sub_0584aecfAddress;
uint256 stor104;
address stor105;
address tokenAddress;
uint256 sub_fd53fce0;
address sub_11eb47dcAddress;
array of address stor30148980456718914367279254941528755963179627010946392082519497346671089299886;

function sub_0584aecf(?) {
    return address(sub_0584aecfAddress)
}

function sub_11eb47dc(?) {
    return sub_11eb47dcAddress
}

function routerAddress() {
    return routerAddress
}

function totalShares() {
    return totalShares
}

function released(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return released[address(arg1)][address(arg2)]
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function payee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 >= payee.length:
        revert with 0, 50
    return payee[arg1]
}

function released(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return released[address(arg1)]
}

function tokenAddress() {
    return tokenAddress
}

function shares(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return shares[address(arg1)]
}

function totalReleased(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return totalReleased[address(arg1)]
}

function totalReleased() {
    return totalReleased
}

function sub_fd53fce0(?) {
    return sub_fd53fce0
}

function updateSwapFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
    if arg1 > 100 * 10^6:
        revert with 0, 'FEES: swap exceeding 100%'
    sub_fd53fce0 = arg1
}

function sub_6a63f5ee(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
    if not address(arg1):
        revert with 0, 'UPD_WALL: zero addr'
    sub_11eb47dcAddress = address(arg1)
}

function wrappedNative() {
    require ext_code.size(stor101)
    staticcall stor101.WAVAX() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function setToken(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
    if not arg1:
        revert with 0, 'NEW_TOKEN: zero addr'
    tokenAddress = arg1
    stor105 = arg1
    require ext_code.size(stor101)
    staticcall stor101.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor101)
    staticcall stor101.WAVAX() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
         gas gas_remaining wei
        args tokenAddress, address(ext_call.return_data[0])
    if ext_call.success:
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor101)
    staticcall stor101.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor101)
    staticcall stor101.WAVAX() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args tokenAddress, address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    uniswapV2PairAddress = ext_call.return_data[12 len 20]
}

function updateUniswapV2Router(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
    if stor101 == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TKN: The router already has that address'
    routerAddress = arg1
    stor101 = arg1
    require ext_code.size(arg1)
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor101)
    staticcall stor101.WAVAX() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
         gas gas_remaining wei
        args tokenAddress, address(ext_call.return_data[0])
    if ext_call.success:
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor101)
    staticcall stor101.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor101)
    staticcall stor101.WAVAX() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
            gas gas_remaining wei
           args tokenAddress, address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    uniswapV2PairAddress = ext_call.return_data[12 len 20]
}

function release(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not shares[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'PaymentSplitter: account has no shares'
    if eth.balance(this.address) > !totalReleased:
        revert with 0, 17
    if eth.balance(this.address) + totalReleased and shares[address(arg1)] > -1 / eth.balance(this.address) + totalReleased:
        revert with 0, 17
    if not totalShares:
        revert with 0, 18
    if (eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares < released[address(arg1)]:
        revert with 0, 17
    if not ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'PaymentSplitter: account is not due payment'
    if released[address(arg1)] > !(((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]):
        revert with 0, 17
    released[address(arg1)] = (eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares
    if totalReleased > !(((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]):
        revert with 0, 17
    totalReleased = totalReleased + ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]
    if eth.balance(this.address) < ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]:
        revert with 0, 'Address: insufficient balance'
    call arg1 with:
       value ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)] wei
         gas gas_remaining wei
    if not return_data.size:
        if not ext_call.success:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'Address: unable to send value, recipient may have reverted'
    else:
        if not ext_call.success:
            revert with 0, 'Address: unable to send value, recipient may have reverted'
    ('bool', 'ext_call.success')
    emit PaymentReleased(address(arg1), ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]);
}

function release(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not shares[address(arg2)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'PaymentSplitter: account has no shares'
    mem[100] = this.address
    require ext_code.size(arg1)
    staticcall arg1.balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > !totalReleased[address(arg1)]:
        revert with 0, 17
    if ext_call.return_data[0] + totalReleased[address(arg1)] and shares[address(arg2)] > -1 / ext_call.return_data[0] + totalReleased[address(arg1)]:
        revert with 0, 17
    if not totalShares:
        revert with 0, 18
    if (ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares < released[address(arg1)][address(arg2)]:
        revert with 0, 17
    if not ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]:
        revert with 0, 'PaymentSplitter: account is not due payment'
    if released[address(arg1)][address(arg2)] > !(((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]):
        revert with 0, 17
    released[address(arg1)][address(arg2)] = (ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares
    if totalReleased[address(arg1)] > !(((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]):
        revert with 0, 17
    totalReleased[address(arg1)] = totalReleased[address(arg1)] + ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]
    mem[ceil32(return_data.size) + 132] = arg2
    mem[ceil32(return_data.size) + 164] = ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = address(arg2) << 64
    mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
    mem[ceil32(return_data.size) + 196] = 32
    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
    if eth.balance(this.address) < 0:
        revert with 0, 'Address: insufficient balance for call'
    if not ext_code.size(arg1):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(return_data.size) + 260 len 96] = transfer(address arg1, uint256 arg2), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], 0
    mem[ceil32(return_data.size) + 328] = 0
    call arg1 with:
       funct Mask(32, 224, transfer(address arg1, uint256 arg2), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, transfer(address arg1, uint256 arg2), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
            if not uint32(this.address), mem[132 len 28]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
            if not mem[ceil32(return_data.size) + 292]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    emit ERC20PaymentReleased(address(arg2), ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], arg1);
}

function initialize(address arg1, uint256 arg2, address arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg3 == arg3
    if uint8(stor0.field_8):
        if ext_code.size(this.address):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
        if uint8(stor0.field_8):
            if not arg1:
                revert with 0, 'ROUTER ZERO'
            mem[128] = msg.sender
            mem[160] = 1
            mem[192] = 1
            if not uint8(stor0.field_8):
                revert with 0, 'Initializable: contract is not initializing'
            idx = 0
            while idx < 1:
                if idx >= 1:
                    revert with 0, 50
                if idx >= 1:
                    revert with 0, 50
                _141 = mem[(32 * idx) + 192]
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, 'PaymentSplitter: account is the zero address'
                if mem[(32 * idx) + 192] <= 0:
                    revert with 0, 'PaymentSplitter: shares are 0'
                if shares[mem[(32 * idx) + 140 len 20]]:
                    revert with 0, 'PaymentSplitter: account already has shares'
                payee.length++
                stor42A7[stor55.length] = mem[(32 * idx) + 140 len 20]
                mem[0] = mem[(32 * idx) + 140 len 20]
                mem[32] = 53
                shares[address(mem[(32 * idx) + 128])] = mem[(32 * idx) + 192]
                if totalShares > !mem[(32 * idx) + 192]:
                    revert with 0, 17
                totalShares += mem[(32 * idx) + 192]
                mem[224] = mem[(32 * idx) + 140 len 20]
                mem[256] = _141
                emit PayeeAdded(mem[224], _141);
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
        else:
            uint16(stor0.field_0) = 257
            if not arg1:
                revert with 0, 'ROUTER ZERO'
            mem[128] = msg.sender
            mem[160] = 1
            mem[192] = 1
            if not uint8(stor0.field_8):
                revert with 0, 'Initializable: contract is not initializing'
            idx = 0
            while idx < 1:
                if idx >= 1:
                    revert with 0, 50
                if idx >= 1:
                    revert with 0, 50
                _142 = mem[(32 * idx) + 192]
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, 'PaymentSplitter: account is the zero address'
                if mem[(32 * idx) + 192] <= 0:
                    revert with 0, 'PaymentSplitter: shares are 0'
                if shares[mem[(32 * idx) + 140 len 20]]:
                    revert with 0, 'PaymentSplitter: account already has shares'
                payee.length++
                stor42A7[stor55.length] = mem[(32 * idx) + 140 len 20]
                mem[0] = mem[(32 * idx) + 140 len 20]
                mem[32] = 53
                shares[address(mem[(32 * idx) + 128])] = mem[(32 * idx) + 192]
                if totalShares > !mem[(32 * idx) + 192]:
                    revert with 0, 17
                totalShares += mem[(32 * idx) + 192]
                mem[224] = mem[(32 * idx) + 140 len 20]
                mem[256] = _142
                emit PayeeAdded(mem[224], _142);
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
    else:
        if uint8(stor0.field_0):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
        if uint8(stor0.field_8):
            if not arg1:
                revert with 0, 'ROUTER ZERO'
            mem[128] = msg.sender
            mem[160] = 1
            mem[192] = 1
            if not uint8(stor0.field_8):
                revert with 0, 'Initializable: contract is not initializing'
            idx = 0
            while idx < 1:
                if idx >= 1:
                    revert with 0, 50
                if idx >= 1:
                    revert with 0, 50
                _143 = mem[(32 * idx) + 192]
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, 'PaymentSplitter: account is the zero address'
                if mem[(32 * idx) + 192] <= 0:
                    revert with 0, 'PaymentSplitter: shares are 0'
                if shares[mem[(32 * idx) + 140 len 20]]:
                    revert with 0, 'PaymentSplitter: account already has shares'
                payee.length++
                stor42A7[stor55.length] = mem[(32 * idx) + 140 len 20]
                mem[0] = mem[(32 * idx) + 140 len 20]
                mem[32] = 53
                shares[address(mem[(32 * idx) + 128])] = mem[(32 * idx) + 192]
                if totalShares > !mem[(32 * idx) + 192]:
                    revert with 0, 17
                totalShares += mem[(32 * idx) + 192]
                mem[224] = mem[(32 * idx) + 140 len 20]
                mem[256] = _143
                emit PayeeAdded(mem[224], _143);
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
        else:
            uint16(stor0.field_0) = 257
            if not arg1:
                revert with 0, 'ROUTER ZERO'
            mem[128] = msg.sender
            mem[160] = 1
            mem[192] = 1
            if not uint8(stor0.field_8):
                revert with 0, 'Initializable: contract is not initializing'
            idx = 0
            while idx < 1:
                if idx >= 1:
                    revert with 0, 50
                if idx >= 1:
                    revert with 0, 50
                _144 = mem[(32 * idx) + 192]
                if not mem[(32 * idx) + 140 len 20]:
                    revert with 0, 'PaymentSplitter: account is the zero address'
                if mem[(32 * idx) + 192] <= 0:
                    revert with 0, 'PaymentSplitter: shares are 0'
                if shares[mem[(32 * idx) + 140 len 20]]:
                    revert with 0, 'PaymentSplitter: account already has shares'
                payee.length++
                stor42A7[stor55.length] = mem[(32 * idx) + 140 len 20]
                mem[0] = mem[(32 * idx) + 140 len 20]
                mem[32] = 53
                shares[address(mem[(32 * idx) + 128])] = mem[(32 * idx) + 192]
                if totalShares > !mem[(32 * idx) + 192]:
                    revert with 0, 17
                totalShares += mem[(32 * idx) + 192]
                mem[224] = mem[(32 * idx) + 140 len 20]
                mem[256] = _144
                emit PayeeAdded(mem[224], _144);
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
    routerAddress = arg1
    stor101 = arg1
    uint256(stor104) = msg.sender or Mask(96, 160, uint256(stor104))
    sub_fd53fce0 = arg2
    sub_11eb47dcAddress = arg3
    if not uint8(stor0.field_8):
        uint8(stor0.field_8) = 0
}

function sub_bd747678(?) {
    require calldata.size - 4 >= 96
    require arg1 == bool(arg1)
    require arg2 == address(arg2)
    require ext_code.size(stor101)
    staticcall stor101.WAVAX() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(arg2) == ext_call.return_data[12 len 20]:
        mem[ceil32(return_data.size) + 96] = 2
        if not arg1:
            mem[ceil32(return_data.size) + 128] = tokenAddress
            mem[ceil32(return_data.size) + 160] = address(arg2)
            mem[ceil32(return_data.size) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 196] = arg3
            mem[ceil32(return_data.size) + 228] = 64
            mem[ceil32(return_data.size) + 260] = 2
            idx = 0
            s = ceil32(return_data.size) + 128
            t = ceil32(return_data.size) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _86 = mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32
            require mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < ceil32(return_data.size) + return_data.size + 192
            _90 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
            mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            require return_data.size >= _86 + (32 * _90) + 32
            mem[(2 * ceil32(return_data.size)) + 224 len 32 * _90] = mem[ceil32(return_data.size) + _86 + 224 len 32 * _90]
            if 0 >= _90:
                revert with 0, 50
        else:
            mem[ceil32(return_data.size) + 128] = address(arg2)
            mem[ceil32(return_data.size) + 160] = tokenAddress
            mem[ceil32(return_data.size) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 196] = arg3
            mem[ceil32(return_data.size) + 228] = 64
            mem[ceil32(return_data.size) + 260] = 2
            idx = 0
            s = ceil32(return_data.size) + 128
            t = ceil32(return_data.size) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _87 = mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32
            require mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < ceil32(return_data.size) + return_data.size + 192
            _91 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
            mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            require return_data.size >= _87 + (32 * _91) + 32
            mem[(2 * ceil32(return_data.size)) + 224 len 32 * _91] = mem[ceil32(return_data.size) + _87 + 224 len 32 * _91]
            if 0 >= _91:
                revert with 0, 50
        if 100 * 10^6 > !sub_fd53fce0:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(2 * ceil32(return_data.size)) + 224]:
            revert with 0, 17
        mem[mem[64]] = (100 * 10^6 * mem[(2 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(2 * ceil32(return_data.size)) + 224]) / 100 * 10^6
    else:
        mem[ceil32(return_data.size) + 96] = 3
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[ceil32(return_data.size) + 160] = ext_call.return_data[12 len 20]
        if not arg1:
            mem[ceil32(return_data.size) + 128] = tokenAddress
            mem[ceil32(return_data.size) + 192] = address(arg2)
            mem[(2 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 228] = arg3
            mem[(2 * ceil32(return_data.size)) + 260] = 64
            mem[(2 * ceil32(return_data.size)) + 292] = 3
            idx = 0
            s = ceil32(return_data.size) + 128
            t = (2 * ceil32(return_data.size)) + 324
            while idx < mem[ceil32(return_data.size) + 96]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, 64, mem[(2 * ceil32(return_data.size)) + 292 len (32 * mem[ceil32(return_data.size) + 96]) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _84 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
            _88 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            require return_data.size >= _84 + (32 * _88) + 32
            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _88] = mem[(2 * ceil32(return_data.size)) + _84 + 256 len 32 * _88]
            if 0 >= _88:
                revert with 0, 50
        else:
            mem[ceil32(return_data.size) + 128] = address(arg2)
            mem[ceil32(return_data.size) + 192] = tokenAddress
            mem[(2 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 228] = arg3
            mem[(2 * ceil32(return_data.size)) + 260] = 64
            mem[(2 * ceil32(return_data.size)) + 292] = 3
            idx = 0
            s = ceil32(return_data.size) + 128
            t = (2 * ceil32(return_data.size)) + 324
            while idx < mem[ceil32(return_data.size) + 96]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, 64, mem[(2 * ceil32(return_data.size)) + 292 len (32 * mem[ceil32(return_data.size) + 96]) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _85 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
            _89 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            require return_data.size >= _85 + (32 * _89) + 32
            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _89] = mem[(2 * ceil32(return_data.size)) + _85 + 256 len 32 * _89]
            if 0 >= _89:
                revert with 0, 50
        if 100 * 10^6 > !sub_fd53fce0:
            revert with 0, 17
        if mem[(4 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 256]:
            revert with 0, 17
        mem[mem[64]] = (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 256]) / 100 * 10^6
    return memory
      from mem[64]
       len 32
}

function sub_f5c13653(?) {
    require calldata.size - 4 >= 96
    require arg1 == bool(arg1)
    require arg2 == address(arg2)
    require ext_code.size(stor101)
    staticcall stor101.WAVAX() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(arg2) == ext_call.return_data[12 len 20]:
        mem[ceil32(return_data.size) + 96] = 2
        if not arg1:
            mem[ceil32(return_data.size) + 128] = tokenAddress
            mem[ceil32(return_data.size) + 160] = address(arg2)
            mem[ceil32(return_data.size) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 196] = arg3
            mem[ceil32(return_data.size) + 228] = 64
            mem[ceil32(return_data.size) + 260] = 2
            idx = 0
            s = ceil32(return_data.size) + 128
            t = ceil32(return_data.size) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _90 = mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32
            require mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < ceil32(return_data.size) + return_data.size + 192
            _94 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
            mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            require return_data.size >= _90 + (32 * _94) + 32
            mem[(2 * ceil32(return_data.size)) + 224 len 32 * _94] = mem[ceil32(return_data.size) + _90 + 224 len 32 * _94]
            if _94 < 1:
                revert with 0, 17
            if _94 - 1 >= _94:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _94 - 1) + (2 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _94 - 1) + (2 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            mem[mem[64]] = (100 * 10^6 * mem[(32 * _94 - 1) + (2 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _94 - 1) + (2 * ceil32(return_data.size)) + 224]) / 100 * 10^6
        else:
            mem[ceil32(return_data.size) + 128] = address(arg2)
            mem[ceil32(return_data.size) + 160] = tokenAddress
            mem[ceil32(return_data.size) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[ceil32(return_data.size) + 196] = arg3
            mem[ceil32(return_data.size) + 228] = 64
            mem[ceil32(return_data.size) + 260] = 2
            idx = 0
            s = ceil32(return_data.size) + 128
            t = ceil32(return_data.size) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(return_data.size) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _91 = mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32
            require mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < ceil32(return_data.size) + return_data.size + 192
            _95 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
            mem[(2 * ceil32(return_data.size)) + 192] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
            require return_data.size >= _91 + (32 * _95) + 32
            mem[(2 * ceil32(return_data.size)) + 224 len 32 * _95] = mem[ceil32(return_data.size) + _91 + 224 len 32 * _95]
            if _95 < 1:
                revert with 0, 17
            if _95 - 1 >= _95:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _95 - 1) + (2 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _95 - 1) + (2 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            mem[mem[64]] = (100 * 10^6 * mem[(32 * _95 - 1) + (2 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _95 - 1) + (2 * ceil32(return_data.size)) + 224]) / 100 * 10^6
    else:
        mem[ceil32(return_data.size) + 96] = 3
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[ceil32(return_data.size) + 160] = ext_call.return_data[12 len 20]
        if not arg1:
            mem[ceil32(return_data.size) + 128] = tokenAddress
            mem[ceil32(return_data.size) + 192] = address(arg2)
            mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 228] = arg3
            mem[(2 * ceil32(return_data.size)) + 260] = 64
            mem[(2 * ceil32(return_data.size)) + 292] = 3
            idx = 0
            s = ceil32(return_data.size) + 128
            t = (2 * ceil32(return_data.size)) + 324
            while idx < mem[ceil32(return_data.size) + 96]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, 64, mem[(2 * ceil32(return_data.size)) + 292 len (32 * mem[ceil32(return_data.size) + 96]) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _88 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
            _92 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            require return_data.size >= _88 + (32 * _92) + 32
            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _92] = mem[(2 * ceil32(return_data.size)) + _88 + 256 len 32 * _92]
            if _92 < 1:
                revert with 0, 17
            if _92 - 1 >= _92:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _92 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _92 - 1) + (4 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            mem[mem[64]] = (100 * 10^6 * mem[(32 * _92 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _92 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6
        else:
            mem[ceil32(return_data.size) + 128] = address(arg2)
            mem[ceil32(return_data.size) + 192] = tokenAddress
            mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 228] = arg3
            mem[(2 * ceil32(return_data.size)) + 260] = 64
            mem[(2 * ceil32(return_data.size)) + 292] = 3
            idx = 0
            s = ceil32(return_data.size) + 128
            t = (2 * ceil32(return_data.size)) + 324
            while idx < mem[ceil32(return_data.size) + 96]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args arg3, 64, mem[(2 * ceil32(return_data.size)) + 292 len (32 * mem[ceil32(return_data.size) + 96]) + 32]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _89 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
            _93 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
            require return_data.size >= _89 + (32 * _93) + 32
            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _93] = mem[(2 * ceil32(return_data.size)) + _89 + 256 len 32 * _93]
            if _93 < 1:
                revert with 0, 17
            if _93 - 1 >= _93:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _93 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _93 - 1) + (4 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            mem[mem[64]] = (100 * 10^6 * mem[(32 * _93 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _93 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6
    return memory
      from mem[64]
       len 32
}

function sub_ed9705da(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    if msg.sender == tokenAddress:
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
            mem[(2 * ceil32(return_data.size)) + 192] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = arg2
            mem[(2 * ceil32(return_data.size)) + 228] = 128
            mem[(2 * ceil32(return_data.size)) + 324] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 356
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(2 * ceil32(return_data.size)) + 260] = address(arg1)
            mem[(2 * ceil32(return_data.size)) + 292] = arg3
            require ext_code.size(stor101)
            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
               value msg.value wei
                 gas gas_remaining wei
                args arg2, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 356 len 64]), address(arg1), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _114 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _118 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require return_data.size >= _114 + (32 * _118) + 32
            mem[(4 * ceil32(return_data.size)) + 224 len 32 * _118] = mem[(2 * ceil32(return_data.size)) + _114 + 224 len 32 * _118]
            if 0 >= _118:
                revert with 0, 50
            if mem[(4 * ceil32(return_data.size)) + 224] and sub_fd53fce0 > -1 / mem[(4 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value mem[(4 * ceil32(return_data.size)) + 224] * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if msg.value < mem[(4 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            if msg.value - mem[(4 * ceil32(return_data.size)) + 224] < mem[(4 * ceil32(return_data.size)) + 224] * sub_fd53fce0 / 100 * 10^6:
                revert with 0, 17
            call address(arg1) with:
               value msg.value - mem[(4 * ceil32(return_data.size)) + 224] - (mem[(4 * ceil32(return_data.size)) + 224] * sub_fd53fce0 / 100 * 10^6) wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = mem[(4 * ceil32(return_data.size)) + 224]
        else:
            mem[(2 * ceil32(return_data.size)) + 96] = 3
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
            mem[(4 * ceil32(return_data.size)) + 224] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 228] = arg2
            mem[(4 * ceil32(return_data.size)) + 260] = 128
            mem[(4 * ceil32(return_data.size)) + 356] = 3
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = address(arg1)
            mem[(4 * ceil32(return_data.size)) + 324] = arg3
            require ext_code.size(stor101)
            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
               value msg.value wei
                 gas gas_remaining wei
                args arg2, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 388 len 96]), address(arg1), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _113 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
            _117 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225
            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
            require return_data.size >= _113 + (32 * _117) + 32
            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _117] = mem[(4 * ceil32(return_data.size)) + _113 + 256 len 32 * _117]
            if 0 >= _117:
                revert with 0, 50
            if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value mem[(6 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if msg.value < mem[(6 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            if msg.value - mem[(6 * ceil32(return_data.size)) + 256] < mem[(6 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6:
                revert with 0, 17
            call address(arg1) with:
               value msg.value - mem[(6 * ceil32(return_data.size)) + 256] - (mem[(6 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6) wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = mem[(6 * ceil32(return_data.size)) + 256]
    else:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
            mem[(2 * ceil32(return_data.size)) + 192] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = arg2
            mem[(2 * ceil32(return_data.size)) + 228] = 128
            mem[(2 * ceil32(return_data.size)) + 324] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 356
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(2 * ceil32(return_data.size)) + 260] = address(arg1)
            mem[(2 * ceil32(return_data.size)) + 292] = arg3
            require ext_code.size(stor101)
            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
               value msg.value wei
                 gas gas_remaining wei
                args arg2, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 356 len 64]), address(arg1), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _116 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _120 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
            require return_data.size >= _116 + (32 * _120) + 32
            mem[(4 * ceil32(return_data.size)) + 224 len 32 * _120] = mem[(2 * ceil32(return_data.size)) + _116 + 224 len 32 * _120]
            if 0 >= _120:
                revert with 0, 50
            if mem[(4 * ceil32(return_data.size)) + 224] and sub_fd53fce0 > -1 / mem[(4 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value mem[(4 * ceil32(return_data.size)) + 224] * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if msg.value < mem[(4 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            if msg.value - mem[(4 * ceil32(return_data.size)) + 224] < mem[(4 * ceil32(return_data.size)) + 224] * sub_fd53fce0 / 100 * 10^6:
                revert with 0, 17
            call address(arg1) with:
               value msg.value - mem[(4 * ceil32(return_data.size)) + 224] - (mem[(4 * ceil32(return_data.size)) + 224] * sub_fd53fce0 / 100 * 10^6) wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = mem[(4 * ceil32(return_data.size)) + 224]
        else:
            mem[(2 * ceil32(return_data.size)) + 96] = 3
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
            mem[(4 * ceil32(return_data.size)) + 224] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 228] = arg2
            mem[(4 * ceil32(return_data.size)) + 260] = 128
            mem[(4 * ceil32(return_data.size)) + 356] = 3
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = address(arg1)
            mem[(4 * ceil32(return_data.size)) + 324] = arg3
            require ext_code.size(stor101)
            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
               value msg.value wei
                 gas gas_remaining wei
                args arg2, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 388 len 96]), address(arg1), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _115 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32
            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
            _119 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225
            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
            require return_data.size >= _115 + (32 * _119) + 32
            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _119] = mem[(4 * ceil32(return_data.size)) + _115 + 256 len 32 * _119]
            if 0 >= _119:
                revert with 0, 50
            if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value mem[(6 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if msg.value < mem[(6 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            if msg.value - mem[(6 * ceil32(return_data.size)) + 256] < mem[(6 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6:
                revert with 0, 17
            call address(arg1) with:
               value msg.value - mem[(6 * ceil32(return_data.size)) + 256] - (mem[(6 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6) wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = mem[(6 * ceil32(return_data.size)) + 256]
    mem[mem[64] + 64] = arg2
    emit 0xa979c0b1: mem[mem[64]], tokenAddress, arg2
}

function sub_8f6e53b7(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    if msg.sender == tokenAddress:
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = msg.value
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args msg.value, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _302 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _306 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]
            require return_data.size >= _302 + (32 * _306) + 32
            mem[(4 * ceil32(return_data.size)) + 224 len 32 * _306] = mem[(2 * ceil32(return_data.size)) + _302 + 224 len 32 * _306]
            if _306 < 1:
                revert with 0, 17
            if _306 - 1 >= _306:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _306 - 1) + (4 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _306 - 1) + (4 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            if (100 * 10^6 * mem[(32 * _306 - 1) + (4 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _306 - 1) + (4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg2:
                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
            if msg.value and sub_fd53fce0 > -1 / msg.value:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _566 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _570 = mem[_566]
            require mem[_566] == mem[_566 + 12 len 20]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _582 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_582] == mem[_582 + 12 len 20]
            if address(_570) == mem[_582 + 12 len 20]:
                _596 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_596]:
                    revert with 0, 50
                mem[_596 + 32] = address(_570)
                if 1 >= mem[_596]:
                    revert with 0, 50
                mem[_596 + 64] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_596 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_596 + 100] = arg2
                mem[_596 + 132] = 128
                mem[_596 + 228] = mem[_596]
                idx = 0
                s = _596 + 32
                t = _596 + 260
                while idx < mem[_596]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_596 + 164] = address(arg1)
                mem[_596 + 196] = arg3
                require ext_code.size(stor101)
                call stor101.mem[mem[64] len 4] with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _596 + (32 * mem[_596]) + -mem[64] + 256]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _764 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _772 = mem[_764]
                require mem[_764] <= test266151307()
                require _764 + mem[_764] + 31 < _764 + return_data.size
                _780 = mem[_764 + mem[_764]]
                if mem[_764 + mem[_764]] > test266151307():
                    revert with 0, 65
                if _764 + ceil32(return_data.size) + ceil32(32 * mem[_764 + mem[_764]]) + 1 > test266151307() or ceil32(32 * mem[_764 + mem[_764]]) + 1 < 0:
                    revert with 0, 65
                mem[64] = _764 + ceil32(return_data.size) + ceil32(32 * mem[_764 + mem[_764]]) + 1
                mem[_764 + ceil32(return_data.size)] = _780
                require return_data.size >= _772 + (32 * _780) + 32
                mem[_764 + ceil32(return_data.size) + 32 len 32 * _780] = mem[_764 + _772 + 32 len 32 * _780]
                if _780 < 1:
                    revert with 0, 17
                if _780 - 1 >= _780:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _780 - 1) + _764 + ceil32(return_data.size) + 32]
            else:
                _593 = mem[64]
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64] + 128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size) + 128
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_593]:
                    revert with 0, 50
                mem[_593 + 64] = ext_call.return_data[12 len 20]
                if 0 >= mem[_593]:
                    revert with 0, 50
                mem[_593 + 32] = address(_570)
                if 2 >= mem[_593]:
                    revert with 0, 50
                mem[_593 + 96] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_593 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_593 + ceil32(return_data.size) + 132] = arg2
                mem[_593 + ceil32(return_data.size) + 164] = 128
                mem[_593 + ceil32(return_data.size) + 260] = mem[_593]
                idx = 0
                s = _593 + 32
                t = _593 + ceil32(return_data.size) + 292
                while idx < mem[_593]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_593 + ceil32(return_data.size) + 196] = address(arg1)
                mem[_593 + ceil32(return_data.size) + 228] = arg3
                require ext_code.size(stor101)
                call stor101.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args arg2, 128, address(arg1), arg3, mem[_593 + ceil32(return_data.size) + 260 len (32 * mem[_593]) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_593 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = _593 + (2 * ceil32(return_data.size)) + 128
                require return_data.size >= 32
                _771 = mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32
                require mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require _593 + ceil32(return_data.size) + mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 159 < _593 + ceil32(return_data.size) + return_data.size + 128
                _779 = mem[_593 + ceil32(return_data.size) + mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                if mem[_593 + ceil32(return_data.size) + mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if _593 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_593 + ceil32(return_data.size) + mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_593 + ceil32(return_data.size) + mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 1 < 0:
                    revert with 0, 65
                mem[_593 + (2 * ceil32(return_data.size)) + 128] = mem[_593 + ceil32(return_data.size) + mem[_593 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                require return_data.size >= _771 + (32 * _779) + 32
                mem[_593 + (2 * ceil32(return_data.size)) + 160 len 32 * _779] = mem[_593 + ceil32(return_data.size) + _771 + 160 len 32 * _779]
                if _779 < 1:
                    revert with 0, 17
                if _779 - 1 >= _779:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _779 - 1) + _593 + (2 * ceil32(return_data.size)) + 160]
        else:
            mem[(2 * ceil32(return_data.size)) + 96] = 3
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
            mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 228] = msg.value
            mem[(4 * ceil32(return_data.size)) + 260] = 64
            mem[(4 * ceil32(return_data.size)) + 292] = 3
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 324
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args msg.value, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _301 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32
            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
            _305 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225
            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
            require return_data.size >= _301 + (32 * _305) + 32
            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _305] = mem[(4 * ceil32(return_data.size)) + _301 + 256 len 32 * _305]
            if _305 < 1:
                revert with 0, 17
            if _305 - 1 >= _305:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _305 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _305 - 1) + (6 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            if (100 * 10^6 * mem[(32 * _305 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _305 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg2:
                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
            if msg.value and sub_fd53fce0 > -1 / msg.value:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _565 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _569 = mem[_565]
            require mem[_565] == mem[_565 + 12 len 20]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _581 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_581] == mem[_581 + 12 len 20]
            if address(_569) == mem[_581 + 12 len 20]:
                _592 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_592]:
                    revert with 0, 50
                mem[_592 + 32] = address(_569)
                if 1 >= mem[_592]:
                    revert with 0, 50
                mem[_592 + 64] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_592 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_592 + 100] = arg2
                mem[_592 + 132] = 128
                mem[_592 + 228] = mem[_592]
                idx = 0
                s = _592 + 32
                t = _592 + 260
                while idx < mem[_592]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_592 + 164] = address(arg1)
                mem[_592 + 196] = arg3
                require ext_code.size(stor101)
                call stor101.mem[mem[64] len 4] with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _592 + (32 * mem[_592]) + -mem[64] + 256]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _762 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _770 = mem[_762]
                require mem[_762] <= test266151307()
                require _762 + mem[_762] + 31 < _762 + return_data.size
                _778 = mem[_762 + mem[_762]]
                if mem[_762 + mem[_762]] > test266151307():
                    revert with 0, 65
                if _762 + ceil32(return_data.size) + ceil32(32 * mem[_762 + mem[_762]]) + 1 > test266151307() or ceil32(32 * mem[_762 + mem[_762]]) + 1 < 0:
                    revert with 0, 65
                mem[64] = _762 + ceil32(return_data.size) + ceil32(32 * mem[_762 + mem[_762]]) + 1
                mem[_762 + ceil32(return_data.size)] = _778
                require return_data.size >= _770 + (32 * _778) + 32
                mem[_762 + ceil32(return_data.size) + 32 len 32 * _778] = mem[_762 + _770 + 32 len 32 * _778]
                if _778 < 1:
                    revert with 0, 17
                if _778 - 1 >= _778:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _778 - 1) + _762 + ceil32(return_data.size) + 32]
            else:
                _589 = mem[64]
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64] + 128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size) + 128
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_589]:
                    revert with 0, 50
                mem[_589 + 64] = ext_call.return_data[12 len 20]
                if 0 >= mem[_589]:
                    revert with 0, 50
                mem[_589 + 32] = address(_569)
                if 2 >= mem[_589]:
                    revert with 0, 50
                mem[_589 + 96] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_589 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_589 + ceil32(return_data.size) + 132] = arg2
                mem[_589 + ceil32(return_data.size) + 164] = 128
                mem[_589 + ceil32(return_data.size) + 260] = mem[_589]
                idx = 0
                s = _589 + 32
                t = _589 + ceil32(return_data.size) + 292
                while idx < mem[_589]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_589 + ceil32(return_data.size) + 196] = address(arg1)
                mem[_589 + ceil32(return_data.size) + 228] = arg3
                require ext_code.size(stor101)
                call stor101.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args arg2, 128, address(arg1), arg3, mem[_589 + ceil32(return_data.size) + 260 len (32 * mem[_589]) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_589 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = _589 + (2 * ceil32(return_data.size)) + 128
                require return_data.size >= 32
                _769 = mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32
                require mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require _589 + ceil32(return_data.size) + mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 159 < _589 + ceil32(return_data.size) + return_data.size + 128
                _777 = mem[_589 + ceil32(return_data.size) + mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                if mem[_589 + ceil32(return_data.size) + mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if _589 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_589 + ceil32(return_data.size) + mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_589 + ceil32(return_data.size) + mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 1 < 0:
                    revert with 0, 65
                mem[64] = _589 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_589 + ceil32(return_data.size) + mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129
                mem[_589 + (2 * ceil32(return_data.size)) + 128] = mem[_589 + ceil32(return_data.size) + mem[_589 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                require return_data.size >= _769 + (32 * _777) + 32
                mem[_589 + (2 * ceil32(return_data.size)) + 160 len 32 * _777] = mem[_589 + ceil32(return_data.size) + _769 + 160 len 32 * _777]
                if _777 < 1:
                    revert with 0, 17
                if _777 - 1 >= _777:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _777 - 1) + _589 + (2 * ceil32(return_data.size)) + 160]
    else:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(stor101)
        staticcall stor101.WAVAX() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
            mem[(2 * ceil32(return_data.size)) + 96] = 2
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
            mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(2 * ceil32(return_data.size)) + 196] = msg.value
            mem[(2 * ceil32(return_data.size)) + 228] = 64
            mem[(2 * ceil32(return_data.size)) + 260] = 2
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (2 * ceil32(return_data.size)) + 292
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args msg.value, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _304 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32
            require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
            _308 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]
            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192] > test266151307():
                revert with 0, 65
            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]) + 193
            mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, msg.value) >> 32 + 192]
            require return_data.size >= _304 + (32 * _308) + 32
            mem[(4 * ceil32(return_data.size)) + 224 len 32 * _308] = mem[(2 * ceil32(return_data.size)) + _304 + 224 len 32 * _308]
            if _308 < 1:
                revert with 0, 17
            if _308 - 1 >= _308:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _308 - 1) + (4 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _308 - 1) + (4 * ceil32(return_data.size)) + 224]:
                revert with 0, 17
            if (100 * 10^6 * mem[(32 * _308 - 1) + (4 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _308 - 1) + (4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg2:
                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
            if msg.value and sub_fd53fce0 > -1 / msg.value:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _568 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _572 = mem[_568]
            require mem[_568] == mem[_568 + 12 len 20]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _584 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_584] == mem[_584 + 12 len 20]
            if address(_572) == mem[_584 + 12 len 20]:
                _604 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_604]:
                    revert with 0, 50
                mem[_604 + 32] = address(_572)
                if 1 >= mem[_604]:
                    revert with 0, 50
                mem[_604 + 64] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_604 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_604 + 100] = arg2
                mem[_604 + 132] = 128
                mem[_604 + 228] = mem[_604]
                idx = 0
                s = _604 + 32
                t = _604 + 260
                while idx < mem[_604]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_604 + 164] = address(arg1)
                mem[_604 + 196] = arg3
                require ext_code.size(stor101)
                call stor101.mem[mem[64] len 4] with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _604 + (32 * mem[_604]) + -mem[64] + 256]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _768 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _776 = mem[_768]
                require mem[_768] <= test266151307()
                require _768 + mem[_768] + 31 < _768 + return_data.size
                _784 = mem[_768 + mem[_768]]
                if mem[_768 + mem[_768]] > test266151307():
                    revert with 0, 65
                if _768 + ceil32(return_data.size) + ceil32(32 * mem[_768 + mem[_768]]) + 1 > test266151307() or ceil32(32 * mem[_768 + mem[_768]]) + 1 < 0:
                    revert with 0, 65
                mem[64] = _768 + ceil32(return_data.size) + ceil32(32 * mem[_768 + mem[_768]]) + 1
                mem[_768 + ceil32(return_data.size)] = _784
                require return_data.size >= _776 + (32 * _784) + 32
                mem[_768 + ceil32(return_data.size) + 32 len 32 * _784] = mem[_768 + _776 + 32 len 32 * _784]
                if _784 < 1:
                    revert with 0, 17
                if _784 - 1 >= _784:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _784 - 1) + _768 + ceil32(return_data.size) + 32]
            else:
                _601 = mem[64]
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64] + 128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size) + 128
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_601]:
                    revert with 0, 50
                mem[_601 + 64] = ext_call.return_data[12 len 20]
                if 0 >= mem[_601]:
                    revert with 0, 50
                mem[_601 + 32] = address(_572)
                if 2 >= mem[_601]:
                    revert with 0, 50
                mem[_601 + 96] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_601 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_601 + ceil32(return_data.size) + 132] = arg2
                mem[_601 + ceil32(return_data.size) + 164] = 128
                mem[_601 + ceil32(return_data.size) + 260] = mem[_601]
                idx = 0
                s = _601 + 32
                t = _601 + ceil32(return_data.size) + 292
                while idx < mem[_601]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_601 + ceil32(return_data.size) + 196] = address(arg1)
                mem[_601 + ceil32(return_data.size) + 228] = arg3
                require ext_code.size(stor101)
                call stor101.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args arg2, 128, address(arg1), arg3, mem[_601 + ceil32(return_data.size) + 260 len (32 * mem[_601]) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_601 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = _601 + (2 * ceil32(return_data.size)) + 128
                require return_data.size >= 32
                _775 = mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32
                require mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                require _601 + ceil32(return_data.size) + mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 159 < _601 + ceil32(return_data.size) + return_data.size + 128
                _783 = mem[_601 + ceil32(return_data.size) + mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                if mem[_601 + ceil32(return_data.size) + mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128] > test266151307():
                    revert with 0, 65
                if _601 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_601 + ceil32(return_data.size) + mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_601 + ceil32(return_data.size) + mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 1 < 0:
                    revert with 0, 65
                mem[64] = _601 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_601 + ceil32(return_data.size) + mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129
                mem[_601 + (2 * ceil32(return_data.size)) + 128] = mem[_601 + ceil32(return_data.size) + mem[_601 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                require return_data.size >= _775 + (32 * _783) + 32
                mem[_601 + (2 * ceil32(return_data.size)) + 160 len 32 * _783] = mem[_601 + ceil32(return_data.size) + _775 + 160 len 32 * _783]
                if _783 < 1:
                    revert with 0, 17
                if _783 - 1 >= _783:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _783 - 1) + _601 + (2 * ceil32(return_data.size)) + 160]
        else:
            mem[(2 * ceil32(return_data.size)) + 96] = 3
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
            mem[(2 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
            mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 228] = msg.value
            mem[(4 * ceil32(return_data.size)) + 260] = 64
            mem[(4 * ceil32(return_data.size)) + 292] = 3
            idx = 0
            s = (2 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 324
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(stor101)
            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                    gas gas_remaining wei
                   args msg.value, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _303 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32
            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
            _307 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 1 < 0:
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225
            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
            require return_data.size >= _303 + (32 * _307) + 32
            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _307] = mem[(4 * ceil32(return_data.size)) + _303 + 256 len 32 * _307]
            if _307 < 1:
                revert with 0, 17
            if _307 - 1 >= _307:
                revert with 0, 50
            if 100 * 10^6 < sub_fd53fce0:
                revert with 0, 17
            if mem[(32 * _307 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _307 - 1) + (6 * ceil32(return_data.size)) + 256]:
                revert with 0, 17
            if (100 * 10^6 * mem[(32 * _307 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _307 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg2:
                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
            if msg.value and sub_fd53fce0 > -1 / msg.value:
                revert with 0, 17
            call sub_11eb47dcAddress with:
               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _567 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _571 = mem[_567]
            require mem[_567] == mem[_567 + 12 len 20]
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _583 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_583] == mem[_583 + 12 len 20]
            if address(_571) == mem[_583 + 12 len 20]:
                _600 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_600]:
                    revert with 0, 50
                mem[_600 + 32] = address(_571)
                if 1 >= mem[_600]:
                    revert with 0, 50
                mem[_600 + 64] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_600 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_600 + 100] = arg2
                mem[_600 + 132] = 128
                mem[_600 + 228] = mem[_600]
                idx = 0
                s = _600 + 32
                t = _600 + 260
                while idx < mem[_600]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_600 + 164] = address(arg1)
                mem[_600 + 196] = arg3
                require ext_code.size(stor101)
                call stor101.mem[mem[64] len 4] with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _600 + (32 * mem[_600]) + -mem[64] + 256]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _766 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _774 = mem[_766]
                require mem[_766] <= test266151307()
                require _766 + mem[_766] + 31 < _766 + return_data.size
                _782 = mem[_766 + mem[_766]]
                if mem[_766 + mem[_766]] > test266151307():
                    revert with 0, 65
                if _766 + ceil32(return_data.size) + ceil32(32 * mem[_766 + mem[_766]]) + 1 > test266151307() or ceil32(32 * mem[_766 + mem[_766]]) + 1 < 0:
                    revert with 0, 65
                mem[64] = _766 + ceil32(return_data.size) + ceil32(32 * mem[_766 + mem[_766]]) + 1
                mem[_766 + ceil32(return_data.size)] = _782
                require return_data.size >= _774 + (32 * _782) + 32
                mem[_766 + ceil32(return_data.size) + 32 len 32 * _782] = mem[_766 + _774 + 32 len 32 * _782]
                if _782 < 1:
                    revert with 0, 17
                if _782 - 1 >= _782:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _782 - 1) + _766 + ceil32(return_data.size) + 32]
            else:
                _597 = mem[64]
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64] + 128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size) + 128
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_597]:
                    revert with 0, 50
                mem[_597 + 64] = ext_call.return_data[12 len 20]
                if 0 >= mem[_597]:
                    revert with 0, 50
                mem[_597 + 32] = address(_571)
                if 2 >= mem[_597]:
                    revert with 0, 50
                mem[_597 + 96] = tokenAddress
                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                    revert with 0, 17
                mem[_597 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                mem[_597 + ceil32(return_data.size) + 132] = arg2
                mem[_597 + ceil32(return_data.size) + 164] = 128
                mem[_597 + ceil32(return_data.size) + 260] = mem[_597]
                idx = 0
                s = _597 + 32
                t = _597 + ceil32(return_data.size) + 292
                while idx < mem[_597]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_597 + ceil32(return_data.size) + 196] = address(arg1)
                mem[_597 + ceil32(return_data.size) + 228] = arg3
                require ext_code.size(stor101)
                call stor101.mem[mem[64] len 4] with:
                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _597 + ceil32(return_data.size) + (32 * mem[_597]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _765 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _773 = mem[_765]
                require mem[_765] <= test266151307()
                require _765 + mem[_765] + 31 < _765 + return_data.size
                _781 = mem[_765 + mem[_765]]
                if mem[_765 + mem[_765]] > test266151307():
                    revert with 0, 65
                if _765 + ceil32(return_data.size) + ceil32(32 * mem[_765 + mem[_765]]) + 1 > test266151307() or ceil32(32 * mem[_765 + mem[_765]]) + 1 < 0:
                    revert with 0, 65
                mem[64] = _765 + ceil32(return_data.size) + ceil32(32 * mem[_765 + mem[_765]]) + 1
                mem[_765 + ceil32(return_data.size)] = _781
                require return_data.size >= _773 + (32 * _781) + 32
                mem[_765 + ceil32(return_data.size) + 32 len 32 * _781] = mem[_765 + _773 + 32 len 32 * _781]
                if _781 < 1:
                    revert with 0, 17
                if _781 - 1 >= _781:
                    revert with 0, 50
                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _781 - 1) + _765 + ceil32(return_data.size) + 32]
}

function sub_6e54a8a0(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if tokenAddress != msg.sender:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(address(arg2))
        staticcall address(arg2).allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg3:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _628 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _636 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _628 + (32 * _636) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _636] = mem[(2 * ceil32(return_data.size)) + _628 + 224 len 32 * _636]
                if _636 < 1:
                    revert with 0, 17
                if _636 - 1 >= _636:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _636 - 1) + (4 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _636 - 1) + (4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _636 - 1) + (4 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _636 - 1) + (4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1172 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1172] == bool(mem[_1172])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1204 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1204] == mem[_1204 + 12 len 20]
                if address(arg2) == mem[_1204 + 12 len 20]:
                    _1238 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1238]:
                        revert with 0, 50
                    mem[_1238 + 32] = address(arg2)
                    if 1 >= mem[_1238]:
                        revert with 0, 50
                    mem[_1238 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1238 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1238 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1238 + 132] = arg4
                    mem[_1238 + 164] = 160
                    mem[_1238 + 260] = mem[_1238]
                    idx = 0
                    s = _1238 + 32
                    t = _1238 + 292
                    while idx < mem[_1238]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1238 + 196] = address(arg1)
                    mem[_1238 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1238 + (32 * mem[_1238]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1602 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1618 = mem[_1602]
                    require mem[_1602] <= test266151307()
                    require _1602 + mem[_1602] + 31 < _1602 + return_data.size
                    _1634 = mem[_1602 + mem[_1602]]
                    if mem[_1602 + mem[_1602]] > test266151307():
                        revert with 0, 65
                    if _1602 + ceil32(return_data.size) + ceil32(32 * mem[_1602 + mem[_1602]]) + 1 > test266151307() or ceil32(32 * mem[_1602 + mem[_1602]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1602 + ceil32(return_data.size) + ceil32(32 * mem[_1602 + mem[_1602]]) + 1
                    mem[_1602 + ceil32(return_data.size)] = _1634
                    require return_data.size >= _1618 + (32 * _1634) + 32
                    mem[_1602 + ceil32(return_data.size) + 32 len 32 * _1634] = mem[_1602 + _1618 + 32 len 32 * _1634]
                    if _1634 < 1:
                        revert with 0, 17
                    if _1634 - 1 >= _1634:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1634 - 1) + _1602 + ceil32(return_data.size) + 32]
                else:
                    _1235 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1235]:
                        revert with 0, 50
                    mem[_1235 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1235]:
                        revert with 0, 50
                    mem[_1235 + 32] = address(arg2)
                    if 2 >= mem[_1235]:
                        revert with 0, 50
                    mem[_1235 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1235 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1235 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1235 + ceil32(return_data.size) + 164] = arg4
                    mem[_1235 + ceil32(return_data.size) + 196] = 160
                    mem[_1235 + ceil32(return_data.size) + 292] = mem[_1235]
                    idx = 0
                    s = _1235 + 32
                    t = _1235 + ceil32(return_data.size) + 324
                    while idx < mem[_1235]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1235 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1235 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1235 + ceil32(return_data.size) + (32 * mem[_1235]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1601 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1617 = mem[_1601]
                    require mem[_1601] <= test266151307()
                    require _1601 + mem[_1601] + 31 < _1601 + return_data.size
                    _1633 = mem[_1601 + mem[_1601]]
                    if mem[_1601 + mem[_1601]] > test266151307():
                        revert with 0, 65
                    if _1601 + ceil32(return_data.size) + ceil32(32 * mem[_1601 + mem[_1601]]) + 1 > test266151307() or ceil32(32 * mem[_1601 + mem[_1601]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1601 + ceil32(return_data.size) + ceil32(32 * mem[_1601 + mem[_1601]]) + 1
                    mem[_1601 + ceil32(return_data.size)] = _1633
                    require return_data.size >= _1617 + (32 * _1633) + 32
                    mem[_1601 + ceil32(return_data.size) + 32 len 32 * _1633] = mem[_1601 + _1617 + 32 len 32 * _1633]
                    if _1633 < 1:
                        revert with 0, 17
                    if _1633 - 1 >= _1633:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1633 - 1) + _1601 + ceil32(return_data.size) + 32]
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _627 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _635 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _627 + (32 * _635) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _635] = mem[(4 * ceil32(return_data.size)) + _627 + 256 len 32 * _635]
                if _635 < 1:
                    revert with 0, 17
                if _635 - 1 >= _635:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _635 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _635 - 1) + (6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _635 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _635 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1171 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1171] == bool(mem[_1171])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1203 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1203] == mem[_1203 + 12 len 20]
                if address(arg2) == mem[_1203 + 12 len 20]:
                    _1234 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1234]:
                        revert with 0, 50
                    mem[_1234 + 32] = address(arg2)
                    if 1 >= mem[_1234]:
                        revert with 0, 50
                    mem[_1234 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1234 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1234 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1234 + 132] = arg4
                    mem[_1234 + 164] = 160
                    mem[_1234 + 260] = mem[_1234]
                    idx = 0
                    s = _1234 + 32
                    t = _1234 + 292
                    while idx < mem[_1234]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1234 + 196] = address(arg1)
                    mem[_1234 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1234 + (32 * mem[_1234]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1600 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1616 = mem[_1600]
                    require mem[_1600] <= test266151307()
                    require _1600 + mem[_1600] + 31 < _1600 + return_data.size
                    _1632 = mem[_1600 + mem[_1600]]
                    if mem[_1600 + mem[_1600]] > test266151307():
                        revert with 0, 65
                    if _1600 + ceil32(return_data.size) + ceil32(32 * mem[_1600 + mem[_1600]]) + 1 > test266151307() or ceil32(32 * mem[_1600 + mem[_1600]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1600 + ceil32(return_data.size) + ceil32(32 * mem[_1600 + mem[_1600]]) + 1
                    mem[_1600 + ceil32(return_data.size)] = _1632
                    require return_data.size >= _1616 + (32 * _1632) + 32
                    mem[_1600 + ceil32(return_data.size) + 32 len 32 * _1632] = mem[_1600 + _1616 + 32 len 32 * _1632]
                    if _1632 < 1:
                        revert with 0, 17
                    if _1632 - 1 >= _1632:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1632 - 1) + _1600 + ceil32(return_data.size) + 32]
                else:
                    _1231 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1231]:
                        revert with 0, 50
                    mem[_1231 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1231]:
                        revert with 0, 50
                    mem[_1231 + 32] = address(arg2)
                    if 2 >= mem[_1231]:
                        revert with 0, 50
                    mem[_1231 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1231 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1231 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1231 + ceil32(return_data.size) + 164] = arg4
                    mem[_1231 + ceil32(return_data.size) + 196] = 160
                    mem[_1231 + ceil32(return_data.size) + 292] = mem[_1231]
                    idx = 0
                    s = _1231 + 32
                    t = _1231 + ceil32(return_data.size) + 324
                    while idx < mem[_1231]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1231 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1231 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1231 + ceil32(return_data.size) + (32 * mem[_1231]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1599 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1615 = mem[_1599]
                    require mem[_1599] <= test266151307()
                    require _1599 + mem[_1599] + 31 < _1599 + return_data.size
                    _1631 = mem[_1599 + mem[_1599]]
                    if mem[_1599 + mem[_1599]] > test266151307():
                        revert with 0, 65
                    if _1599 + ceil32(return_data.size) + ceil32(32 * mem[_1599 + mem[_1599]]) + 1 > test266151307() or ceil32(32 * mem[_1599 + mem[_1599]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1599 + ceil32(return_data.size) + ceil32(32 * mem[_1599 + mem[_1599]]) + 1
                    mem[_1599 + ceil32(return_data.size)] = _1631
                    require return_data.size >= _1615 + (32 * _1631) + 32
                    mem[_1599 + ceil32(return_data.size) + 32 len 32 * _1631] = mem[_1599 + _1615 + 32 len 32 * _1631]
                    if _1631 < 1:
                        revert with 0, 17
                    if _1631 - 1 >= _1631:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1631 - 1) + _1599 + ceil32(return_data.size) + 32]
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg3
            require ext_code.size(address(arg2))
            call address(arg2).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg3
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _630 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _638 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _630 + (32 * _638) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _638] = mem[(4 * ceil32(return_data.size)) + _630 + 224 len 32 * _638]
                if _638 < 1:
                    revert with 0, 17
                if _638 - 1 >= _638:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _638 - 1) + (6 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _638 - 1) + (6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _638 - 1) + (6 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _638 - 1) + (6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1174 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1174] == bool(mem[_1174])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1206 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1206] == mem[_1206 + 12 len 20]
                if address(arg2) == mem[_1206 + 12 len 20]:
                    _1246 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1246]:
                        revert with 0, 50
                    mem[_1246 + 32] = address(arg2)
                    if 1 >= mem[_1246]:
                        revert with 0, 50
                    mem[_1246 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1246 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1246 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1246 + 132] = arg4
                    mem[_1246 + 164] = 160
                    mem[_1246 + 260] = mem[_1246]
                    idx = 0
                    s = _1246 + 32
                    t = _1246 + 292
                    while idx < mem[_1246]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1246 + 196] = address(arg1)
                    mem[_1246 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1246 + (32 * mem[_1246]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1606 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1622 = mem[_1606]
                    require mem[_1606] <= test266151307()
                    require _1606 + mem[_1606] + 31 < _1606 + return_data.size
                    _1638 = mem[_1606 + mem[_1606]]
                    if mem[_1606 + mem[_1606]] > test266151307():
                        revert with 0, 65
                    if _1606 + ceil32(return_data.size) + ceil32(32 * mem[_1606 + mem[_1606]]) + 1 > test266151307() or ceil32(32 * mem[_1606 + mem[_1606]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1606 + ceil32(return_data.size) + ceil32(32 * mem[_1606 + mem[_1606]]) + 1
                    mem[_1606 + ceil32(return_data.size)] = _1638
                    require return_data.size >= _1622 + (32 * _1638) + 32
                    mem[_1606 + ceil32(return_data.size) + 32 len 32 * _1638] = mem[_1606 + _1622 + 32 len 32 * _1638]
                    if _1638 < 1:
                        revert with 0, 17
                    if _1638 - 1 >= _1638:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1638 - 1) + _1606 + ceil32(return_data.size) + 32]
                else:
                    _1243 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1243]:
                        revert with 0, 50
                    mem[_1243 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1243]:
                        revert with 0, 50
                    mem[_1243 + 32] = address(arg2)
                    if 2 >= mem[_1243]:
                        revert with 0, 50
                    mem[_1243 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1243 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1243 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1243 + ceil32(return_data.size) + 164] = arg4
                    mem[_1243 + ceil32(return_data.size) + 196] = 160
                    mem[_1243 + ceil32(return_data.size) + 292] = mem[_1243]
                    idx = 0
                    s = _1243 + 32
                    t = _1243 + ceil32(return_data.size) + 324
                    while idx < mem[_1243]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1243 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1243 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1243 + ceil32(return_data.size) + 292 len (32 * mem[_1243]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1243 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1243 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    _1621 = mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                    require mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                    require _1243 + ceil32(return_data.size) + mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1243 + ceil32(return_data.size) + return_data.size + 128
                    _1637 = mem[_1243 + ceil32(return_data.size) + mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    if mem[_1243 + ceil32(return_data.size) + mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if _1243 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1243 + ceil32(return_data.size) + mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1243 + ceil32(return_data.size) + mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1243 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1243 + ceil32(return_data.size) + mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                    mem[_1243 + (2 * ceil32(return_data.size)) + 128] = mem[_1243 + ceil32(return_data.size) + mem[_1243 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    require return_data.size >= _1621 + (32 * _1637) + 32
                    mem[_1243 + (2 * ceil32(return_data.size)) + 160 len 32 * _1637] = mem[_1243 + ceil32(return_data.size) + _1621 + 160 len 32 * _1637]
                    if _1637 < 1:
                        revert with 0, 17
                    if _1637 - 1 >= _1637:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1637 - 1) + _1243 + (2 * ceil32(return_data.size)) + 160]
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(6 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _629 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _637 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _629 + (32 * _637) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _637] = mem[(6 * ceil32(return_data.size)) + _629 + 256 len 32 * _637]
                if _637 < 1:
                    revert with 0, 17
                if _637 - 1 >= _637:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _637 - 1) + (7 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _637 - 1) + (7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _637 - 1) + (7 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _637 - 1) + (7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1173 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1173] == bool(mem[_1173])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1205 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1205] == mem[_1205 + 12 len 20]
                if address(arg2) == mem[_1205 + 12 len 20]:
                    _1242 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1242]:
                        revert with 0, 50
                    mem[_1242 + 32] = address(arg2)
                    if 1 >= mem[_1242]:
                        revert with 0, 50
                    mem[_1242 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1242 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1242 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1242 + 132] = arg4
                    mem[_1242 + 164] = 160
                    mem[_1242 + 260] = mem[_1242]
                    idx = 0
                    s = _1242 + 32
                    t = _1242 + 292
                    while idx < mem[_1242]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1242 + 196] = address(arg1)
                    mem[_1242 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1242 + (32 * mem[_1242]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1604 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1620 = mem[_1604]
                    require mem[_1604] <= test266151307()
                    require _1604 + mem[_1604] + 31 < _1604 + return_data.size
                    _1636 = mem[_1604 + mem[_1604]]
                    if mem[_1604 + mem[_1604]] > test266151307():
                        revert with 0, 65
                    if _1604 + ceil32(return_data.size) + ceil32(32 * mem[_1604 + mem[_1604]]) + 1 > test266151307() or ceil32(32 * mem[_1604 + mem[_1604]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1604 + ceil32(return_data.size) + ceil32(32 * mem[_1604 + mem[_1604]]) + 1
                    mem[_1604 + ceil32(return_data.size)] = _1636
                    require return_data.size >= _1620 + (32 * _1636) + 32
                    mem[_1604 + ceil32(return_data.size) + 32 len 32 * _1636] = mem[_1604 + _1620 + 32 len 32 * _1636]
                    if _1636 < 1:
                        revert with 0, 17
                    if _1636 - 1 >= _1636:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1636 - 1) + _1604 + ceil32(return_data.size) + 32]
                else:
                    _1239 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1239]:
                        revert with 0, 50
                    mem[_1239 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1239]:
                        revert with 0, 50
                    mem[_1239 + 32] = address(arg2)
                    if 2 >= mem[_1239]:
                        revert with 0, 50
                    mem[_1239 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1239 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1239 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1239 + ceil32(return_data.size) + 164] = arg4
                    mem[_1239 + ceil32(return_data.size) + 196] = 160
                    mem[_1239 + ceil32(return_data.size) + 292] = mem[_1239]
                    idx = 0
                    s = _1239 + 32
                    t = _1239 + ceil32(return_data.size) + 324
                    while idx < mem[_1239]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1239 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1239 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1239 + ceil32(return_data.size) + 292 len (32 * mem[_1239]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1239 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1239 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    _1619 = mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                    require mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                    require _1239 + ceil32(return_data.size) + mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1239 + ceil32(return_data.size) + return_data.size + 128
                    _1635 = mem[_1239 + ceil32(return_data.size) + mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    if mem[_1239 + ceil32(return_data.size) + mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if _1239 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1239 + ceil32(return_data.size) + mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1239 + ceil32(return_data.size) + mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                        revert with 0, 65
                    mem[_1239 + (2 * ceil32(return_data.size)) + 128] = mem[_1239 + ceil32(return_data.size) + mem[_1239 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    require return_data.size >= _1619 + (32 * _1635) + 32
                    mem[_1239 + (2 * ceil32(return_data.size)) + 160 len 32 * _1635] = mem[_1239 + ceil32(return_data.size) + _1619 + 160 len 32 * _1635]
                    if _1635 < 1:
                        revert with 0, 17
                    if _1635 - 1 >= _1635:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1635 - 1) + _1239 + (2 * ceil32(return_data.size)) + 160]
    else:
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(address(arg2))
        staticcall address(arg2).allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg3:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _624 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _632 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _624 + (32 * _632) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _632] = mem[(2 * ceil32(return_data.size)) + _624 + 224 len 32 * _632]
                if _632 < 1:
                    revert with 0, 17
                if _632 - 1 >= _632:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _632 - 1) + (4 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _632 - 1) + (4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _632 - 1) + (4 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _632 - 1) + (4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1168 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1168] == bool(mem[_1168])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1200 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1200] == mem[_1200 + 12 len 20]
                if address(arg2) == mem[_1200 + 12 len 20]:
                    _1222 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1222]:
                        revert with 0, 50
                    mem[_1222 + 32] = address(arg2)
                    if 1 >= mem[_1222]:
                        revert with 0, 50
                    mem[_1222 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1222 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1222 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1222 + 132] = arg4
                    mem[_1222 + 164] = 160
                    mem[_1222 + 260] = mem[_1222]
                    idx = 0
                    s = _1222 + 32
                    t = _1222 + 292
                    while idx < mem[_1222]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1222 + 196] = address(arg1)
                    mem[_1222 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1222 + (32 * mem[_1222]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1594 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1610 = mem[_1594]
                    require mem[_1594] <= test266151307()
                    require _1594 + mem[_1594] + 31 < _1594 + return_data.size
                    _1626 = mem[_1594 + mem[_1594]]
                    if mem[_1594 + mem[_1594]] > test266151307():
                        revert with 0, 65
                    if _1594 + ceil32(return_data.size) + ceil32(32 * mem[_1594 + mem[_1594]]) + 1 > test266151307() or ceil32(32 * mem[_1594 + mem[_1594]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1594 + ceil32(return_data.size) + ceil32(32 * mem[_1594 + mem[_1594]]) + 1
                    mem[_1594 + ceil32(return_data.size)] = _1626
                    require return_data.size >= _1610 + (32 * _1626) + 32
                    mem[_1594 + ceil32(return_data.size) + 32 len 32 * _1626] = mem[_1594 + _1610 + 32 len 32 * _1626]
                    if _1626 < 1:
                        revert with 0, 17
                    if _1626 - 1 >= _1626:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1626 - 1) + _1594 + ceil32(return_data.size) + 32]
                else:
                    _1219 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1219]:
                        revert with 0, 50
                    mem[_1219 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1219]:
                        revert with 0, 50
                    mem[_1219 + 32] = address(arg2)
                    if 2 >= mem[_1219]:
                        revert with 0, 50
                    mem[_1219 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1219 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1219 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1219 + ceil32(return_data.size) + 164] = arg4
                    mem[_1219 + ceil32(return_data.size) + 196] = 160
                    mem[_1219 + ceil32(return_data.size) + 292] = mem[_1219]
                    idx = 0
                    s = _1219 + 32
                    t = _1219 + ceil32(return_data.size) + 324
                    while idx < mem[_1219]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1219 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1219 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1219 + ceil32(return_data.size) + 292 len (32 * mem[_1219]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1219 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1219 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    _1609 = mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                    require mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                    require _1219 + ceil32(return_data.size) + mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1219 + ceil32(return_data.size) + return_data.size + 128
                    _1625 = mem[_1219 + ceil32(return_data.size) + mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    if mem[_1219 + ceil32(return_data.size) + mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if _1219 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1219 + ceil32(return_data.size) + mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1219 + ceil32(return_data.size) + mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1219 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1219 + ceil32(return_data.size) + mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                    mem[_1219 + (2 * ceil32(return_data.size)) + 128] = mem[_1219 + ceil32(return_data.size) + mem[_1219 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    require return_data.size >= _1609 + (32 * _1625) + 32
                    mem[_1219 + (2 * ceil32(return_data.size)) + 160 len 32 * _1625] = mem[_1219 + ceil32(return_data.size) + _1609 + 160 len 32 * _1625]
                    if _1625 < 1:
                        revert with 0, 17
                    if _1625 - 1 >= _1625:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1625 - 1) + _1219 + (2 * ceil32(return_data.size)) + 160]
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _623 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _631 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _623 + (32 * _631) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _631] = mem[(4 * ceil32(return_data.size)) + _623 + 256 len 32 * _631]
                if _631 < 1:
                    revert with 0, 17
                if _631 - 1 >= _631:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _631 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _631 - 1) + (6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _631 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _631 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1167 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1167] == bool(mem[_1167])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1199 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1199] == mem[_1199 + 12 len 20]
                if address(arg2) == mem[_1199 + 12 len 20]:
                    _1218 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1218]:
                        revert with 0, 50
                    mem[_1218 + 32] = address(arg2)
                    if 1 >= mem[_1218]:
                        revert with 0, 50
                    mem[_1218 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1218 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1218 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1218 + 132] = arg4
                    mem[_1218 + 164] = 160
                    mem[_1218 + 260] = mem[_1218]
                    idx = 0
                    s = _1218 + 32
                    t = _1218 + 292
                    while idx < mem[_1218]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1218 + 196] = address(arg1)
                    mem[_1218 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1218 + (32 * mem[_1218]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1592 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1608 = mem[_1592]
                    require mem[_1592] <= test266151307()
                    require _1592 + mem[_1592] + 31 < _1592 + return_data.size
                    _1624 = mem[_1592 + mem[_1592]]
                    if mem[_1592 + mem[_1592]] > test266151307():
                        revert with 0, 65
                    if _1592 + ceil32(return_data.size) + ceil32(32 * mem[_1592 + mem[_1592]]) + 1 > test266151307() or ceil32(32 * mem[_1592 + mem[_1592]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1592 + ceil32(return_data.size) + ceil32(32 * mem[_1592 + mem[_1592]]) + 1
                    mem[_1592 + ceil32(return_data.size)] = _1624
                    require return_data.size >= _1608 + (32 * _1624) + 32
                    mem[_1592 + ceil32(return_data.size) + 32 len 32 * _1624] = mem[_1592 + _1608 + 32 len 32 * _1624]
                    if _1624 < 1:
                        revert with 0, 17
                    if _1624 - 1 >= _1624:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1624 - 1) + _1592 + ceil32(return_data.size) + 32]
                else:
                    _1215 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1215]:
                        revert with 0, 50
                    mem[_1215 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1215]:
                        revert with 0, 50
                    mem[_1215 + 32] = address(arg2)
                    if 2 >= mem[_1215]:
                        revert with 0, 50
                    mem[_1215 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1215 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1215 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1215 + ceil32(return_data.size) + 164] = arg4
                    mem[_1215 + ceil32(return_data.size) + 196] = 160
                    mem[_1215 + ceil32(return_data.size) + 292] = mem[_1215]
                    idx = 0
                    s = _1215 + 32
                    t = _1215 + ceil32(return_data.size) + 324
                    while idx < mem[_1215]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1215 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1215 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1215 + ceil32(return_data.size) + (32 * mem[_1215]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1591 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1607 = mem[_1591]
                    require mem[_1591] <= test266151307()
                    require _1591 + mem[_1591] + 31 < _1591 + return_data.size
                    _1623 = mem[_1591 + mem[_1591]]
                    if mem[_1591 + mem[_1591]] > test266151307():
                        revert with 0, 65
                    if _1591 + ceil32(return_data.size) + ceil32(32 * mem[_1591 + mem[_1591]]) + 1 > test266151307() or ceil32(32 * mem[_1591 + mem[_1591]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1591 + ceil32(return_data.size) + ceil32(32 * mem[_1591 + mem[_1591]]) + 1
                    mem[_1591 + ceil32(return_data.size)] = _1623
                    require return_data.size >= _1607 + (32 * _1623) + 32
                    mem[_1591 + ceil32(return_data.size) + 32 len 32 * _1623] = mem[_1591 + _1607 + 32 len 32 * _1623]
                    if _1623 < 1:
                        revert with 0, 17
                    if _1623 - 1 >= _1623:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1623 - 1) + _1591 + ceil32(return_data.size) + 32]
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg3
            require ext_code.size(address(arg2))
            call address(arg2).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg3
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _626 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _634 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _626 + (32 * _634) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _634] = mem[(4 * ceil32(return_data.size)) + _626 + 224 len 32 * _634]
                if _634 < 1:
                    revert with 0, 17
                if _634 - 1 >= _634:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _634 - 1) + (6 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _634 - 1) + (6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _634 - 1) + (6 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _634 - 1) + (6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1170 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1170] == bool(mem[_1170])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1202 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1202] == mem[_1202 + 12 len 20]
                if address(arg2) == mem[_1202 + 12 len 20]:
                    _1230 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1230]:
                        revert with 0, 50
                    mem[_1230 + 32] = address(arg2)
                    if 1 >= mem[_1230]:
                        revert with 0, 50
                    mem[_1230 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1230 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1230 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1230 + 132] = arg4
                    mem[_1230 + 164] = 160
                    mem[_1230 + 260] = mem[_1230]
                    idx = 0
                    s = _1230 + 32
                    t = _1230 + 292
                    while idx < mem[_1230]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1230 + 196] = address(arg1)
                    mem[_1230 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1230 + (32 * mem[_1230]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1598 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1614 = mem[_1598]
                    require mem[_1598] <= test266151307()
                    require _1598 + mem[_1598] + 31 < _1598 + return_data.size
                    _1630 = mem[_1598 + mem[_1598]]
                    if mem[_1598 + mem[_1598]] > test266151307():
                        revert with 0, 65
                    if _1598 + ceil32(return_data.size) + ceil32(32 * mem[_1598 + mem[_1598]]) + 1 > test266151307() or ceil32(32 * mem[_1598 + mem[_1598]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1598 + ceil32(return_data.size) + ceil32(32 * mem[_1598 + mem[_1598]]) + 1
                    mem[_1598 + ceil32(return_data.size)] = _1630
                    require return_data.size >= _1614 + (32 * _1630) + 32
                    mem[_1598 + ceil32(return_data.size) + 32 len 32 * _1630] = mem[_1598 + _1614 + 32 len 32 * _1630]
                    if _1630 < 1:
                        revert with 0, 17
                    if _1630 - 1 >= _1630:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1630 - 1) + _1598 + ceil32(return_data.size) + 32]
                else:
                    _1227 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1227]:
                        revert with 0, 50
                    mem[_1227 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1227]:
                        revert with 0, 50
                    mem[_1227 + 32] = address(arg2)
                    if 2 >= mem[_1227]:
                        revert with 0, 50
                    mem[_1227 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1227 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1227 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1227 + ceil32(return_data.size) + 164] = arg4
                    mem[_1227 + ceil32(return_data.size) + 196] = 160
                    mem[_1227 + ceil32(return_data.size) + 292] = mem[_1227]
                    idx = 0
                    s = _1227 + 32
                    t = _1227 + ceil32(return_data.size) + 324
                    while idx < mem[_1227]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1227 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1227 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1227 + ceil32(return_data.size) + 292 len (32 * mem[_1227]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1227 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1227 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    _1613 = mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                    require mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                    require _1227 + ceil32(return_data.size) + mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1227 + ceil32(return_data.size) + return_data.size + 128
                    _1629 = mem[_1227 + ceil32(return_data.size) + mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    if mem[_1227 + ceil32(return_data.size) + mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if _1227 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1227 + ceil32(return_data.size) + mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1227 + ceil32(return_data.size) + mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1227 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1227 + ceil32(return_data.size) + mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                    mem[_1227 + (2 * ceil32(return_data.size)) + 128] = mem[_1227 + ceil32(return_data.size) + mem[_1227 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                    require return_data.size >= _1613 + (32 * _1629) + 32
                    mem[_1227 + (2 * ceil32(return_data.size)) + 160 len 32 * _1629] = mem[_1227 + ceil32(return_data.size) + _1613 + 160 len 32 * _1629]
                    if _1629 < 1:
                        revert with 0, 17
                    if _1629 - 1 >= _1629:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1629 - 1) + _1227 + (2 * ceil32(return_data.size)) + 160]
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(6 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _625 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _633 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _625 + (32 * _633) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _633] = mem[(6 * ceil32(return_data.size)) + _625 + 256 len 32 * _633]
                if _633 < 1:
                    revert with 0, 17
                if _633 - 1 >= _633:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _633 - 1) + (7 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _633 - 1) + (7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _633 - 1) + (7 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _633 - 1) + (7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(address(arg2))
                call address(arg2).transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1169 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1169] == bool(mem[_1169])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1201 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1201] == mem[_1201 + 12 len 20]
                if address(arg2) == mem[_1201 + 12 len 20]:
                    _1226 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1226]:
                        revert with 0, 50
                    mem[_1226 + 32] = address(arg2)
                    if 1 >= mem[_1226]:
                        revert with 0, 50
                    mem[_1226 + 64] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1226 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1226 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1226 + 132] = arg4
                    mem[_1226 + 164] = 160
                    mem[_1226 + 260] = mem[_1226]
                    idx = 0
                    s = _1226 + 32
                    t = _1226 + 292
                    while idx < mem[_1226]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1226 + 196] = address(arg1)
                    mem[_1226 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1226 + (32 * mem[_1226]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1596 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1612 = mem[_1596]
                    require mem[_1596] <= test266151307()
                    require _1596 + mem[_1596] + 31 < _1596 + return_data.size
                    _1628 = mem[_1596 + mem[_1596]]
                    if mem[_1596 + mem[_1596]] > test266151307():
                        revert with 0, 65
                    if _1596 + ceil32(return_data.size) + ceil32(32 * mem[_1596 + mem[_1596]]) + 1 > test266151307() or ceil32(32 * mem[_1596 + mem[_1596]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1596 + ceil32(return_data.size) + ceil32(32 * mem[_1596 + mem[_1596]]) + 1
                    mem[_1596 + ceil32(return_data.size)] = _1628
                    require return_data.size >= _1612 + (32 * _1628) + 32
                    mem[_1596 + ceil32(return_data.size) + 32 len 32 * _1628] = mem[_1596 + _1612 + 32 len 32 * _1628]
                    if _1628 < 1:
                        revert with 0, 17
                    if _1628 - 1 >= _1628:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1628 - 1) + _1596 + ceil32(return_data.size) + 32]
                else:
                    _1223 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1223]:
                        revert with 0, 50
                    mem[_1223 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1223]:
                        revert with 0, 50
                    mem[_1223 + 32] = address(arg2)
                    if 2 >= mem[_1223]:
                        revert with 0, 50
                    mem[_1223 + 96] = tokenAddress
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[_1223 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1223 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                    mem[_1223 + ceil32(return_data.size) + 164] = arg4
                    mem[_1223 + ceil32(return_data.size) + 196] = 160
                    mem[_1223 + ceil32(return_data.size) + 292] = mem[_1223]
                    idx = 0
                    s = _1223 + 32
                    t = _1223 + ceil32(return_data.size) + 324
                    while idx < mem[_1223]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1223 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1223 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1223 + ceil32(return_data.size) + (32 * mem[_1223]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1595 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1611 = mem[_1595]
                    require mem[_1595] <= test266151307()
                    require _1595 + mem[_1595] + 31 < _1595 + return_data.size
                    _1627 = mem[_1595 + mem[_1595]]
                    if mem[_1595 + mem[_1595]] > test266151307():
                        revert with 0, 65
                    if _1595 + ceil32(return_data.size) + ceil32(32 * mem[_1595 + mem[_1595]]) + 1 > test266151307() or ceil32(32 * mem[_1595 + mem[_1595]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1595 + ceil32(return_data.size) + ceil32(32 * mem[_1595 + mem[_1595]]) + 1
                    mem[_1595 + ceil32(return_data.size)] = _1627
                    require return_data.size >= _1611 + (32 * _1627) + 32
                    mem[_1595 + ceil32(return_data.size) + 32 len 32 * _1627] = mem[_1595 + _1611 + 32 len 32 * _1627]
                    if _1627 < 1:
                        revert with 0, 17
                    if _1627 - 1 >= _1627:
                        revert with 0, 50
                    emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _1627 - 1) + _1595 + ceil32(return_data.size) + 32]
}

function sub_74cefd8a(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if msg.sender == tokenAddress:
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(address(arg2))
        staticcall address(arg2).allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg4:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _696 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _704 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _696 + (32 * _704) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _704] = mem[(2 * ceil32(return_data.size)) + _696 + 224 len 32 * _704]
                if 0 >= _704:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(4 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1304 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1304] == mem[_1304 + 12 len 20]
                if address(arg2) == mem[_1304 + 12 len 20]:
                    _1326 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1326]:
                        revert with 0, 50
                    mem[_1326 + 32] = address(arg2)
                    if 1 >= mem[_1326]:
                        revert with 0, 50
                    mem[_1326 + 64] = tokenAddress
                    mem[_1326 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1326 + 100] = arg3
                    mem[_1326 + 132] = arg4
                    mem[_1326 + 164] = 160
                    mem[_1326 + 260] = mem[_1326]
                    idx = 0
                    s = _1326 + 32
                    t = _1326 + 292
                    while idx < mem[_1326]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1326 + 196] = address(arg1)
                    mem[_1326 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1326 + (32 * mem[_1326]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1810 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1826 = mem[_1810]
                    require mem[_1810] <= test266151307()
                    require _1810 + mem[_1810] + 31 < _1810 + return_data.size
                    _1842 = mem[_1810 + mem[_1810]]
                    if mem[_1810 + mem[_1810]] > test266151307():
                        revert with 0, 65
                    if _1810 + ceil32(return_data.size) + ceil32(32 * mem[_1810 + mem[_1810]]) + 1 > test266151307() or ceil32(32 * mem[_1810 + mem[_1810]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1810 + ceil32(return_data.size) + ceil32(32 * mem[_1810 + mem[_1810]]) + 1
                    mem[_1810 + ceil32(return_data.size)] = _1842
                    require return_data.size >= _1826 + (32 * _1842) + 32
                    mem[_1810 + ceil32(return_data.size) + 32 len 32 * _1842] = mem[_1810 + _1826 + 32 len 32 * _1842]
                    if 0 >= _1842:
                        revert with 0, 50
                    _2146 = mem[_1810 + ceil32(return_data.size) + 32]
                    if mem[_1810 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1810 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2146 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2146 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2194 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2194] == bool(mem[_2194])
                    if arg4 < _2146:
                        revert with 0, 17
                    if arg4 - _2146 < _2146 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2146 - (_2146 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2146 - (_2146 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2258 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2258] == bool(mem[_2258])
                    emit 0xfedb587d: address(arg2), _2146, tokenAddress, arg3
                else:
                    _1323 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1323]:
                        revert with 0, 50
                    mem[_1323 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1323]:
                        revert with 0, 50
                    mem[_1323 + 32] = address(arg2)
                    if 2 >= mem[_1323]:
                        revert with 0, 50
                    mem[_1323 + 96] = tokenAddress
                    mem[_1323 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1323 + ceil32(return_data.size) + 132] = arg3
                    mem[_1323 + ceil32(return_data.size) + 164] = arg4
                    mem[_1323 + ceil32(return_data.size) + 196] = 160
                    mem[_1323 + ceil32(return_data.size) + 292] = mem[_1323]
                    idx = 0
                    s = _1323 + 32
                    t = _1323 + ceil32(return_data.size) + 324
                    while idx < mem[_1323]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1323 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1323 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg3, arg4, 160, address(arg1), arg5, mem[_1323 + ceil32(return_data.size) + 292 len (32 * mem[_1323]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1323 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1323 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    _1825 = mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32
                    require mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                    require _1323 + ceil32(return_data.size) + mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _1323 + ceil32(return_data.size) + return_data.size + 128
                    _1841 = mem[_1323 + ceil32(return_data.size) + mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                    if mem[_1323 + ceil32(return_data.size) + mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if _1323 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1323 + ceil32(return_data.size) + mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1323 + ceil32(return_data.size) + mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1323 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1323 + ceil32(return_data.size) + mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                    mem[_1323 + (2 * ceil32(return_data.size)) + 128] = mem[_1323 + ceil32(return_data.size) + mem[_1323 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                    require return_data.size >= _1825 + (32 * _1841) + 32
                    mem[_1323 + (2 * ceil32(return_data.size)) + 160 len 32 * _1841] = mem[_1323 + ceil32(return_data.size) + _1825 + 160 len 32 * _1841]
                    if 0 >= _1841:
                        revert with 0, 50
                    _2145 = mem[_1323 + (2 * ceil32(return_data.size)) + 160]
                    if mem[_1323 + (2 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_1323 + (2 * ceil32(return_data.size)) + 160]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2145 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2145 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2193 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2193] == bool(mem[_2193])
                    if arg4 < _2145:
                        revert with 0, 17
                    if arg4 - _2145 < _2145 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2145 - (_2145 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2145 - (_2145 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2257 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2257] == bool(mem[_2257])
                    emit 0xfedb587d: address(arg2), _2145, tokenAddress, arg3
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _695 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _703 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _695 + (32 * _703) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _703] = mem[(4 * ceil32(return_data.size)) + _695 + 256 len 32 * _703]
                if 0 >= _703:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1303 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1303] == mem[_1303 + 12 len 20]
                if address(arg2) == mem[_1303 + 12 len 20]:
                    _1322 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1322]:
                        revert with 0, 50
                    mem[_1322 + 32] = address(arg2)
                    if 1 >= mem[_1322]:
                        revert with 0, 50
                    mem[_1322 + 64] = tokenAddress
                    mem[_1322 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1322 + 100] = arg3
                    mem[_1322 + 132] = arg4
                    mem[_1322 + 164] = 160
                    mem[_1322 + 260] = mem[_1322]
                    idx = 0
                    s = _1322 + 32
                    t = _1322 + 292
                    while idx < mem[_1322]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1322 + 196] = address(arg1)
                    mem[_1322 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1322 + (32 * mem[_1322]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1808 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1824 = mem[_1808]
                    require mem[_1808] <= test266151307()
                    require _1808 + mem[_1808] + 31 < _1808 + return_data.size
                    _1840 = mem[_1808 + mem[_1808]]
                    if mem[_1808 + mem[_1808]] > test266151307():
                        revert with 0, 65
                    if _1808 + ceil32(return_data.size) + ceil32(32 * mem[_1808 + mem[_1808]]) + 1 > test266151307() or ceil32(32 * mem[_1808 + mem[_1808]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1808 + ceil32(return_data.size) + ceil32(32 * mem[_1808 + mem[_1808]]) + 1
                    mem[_1808 + ceil32(return_data.size)] = _1840
                    require return_data.size >= _1824 + (32 * _1840) + 32
                    mem[_1808 + ceil32(return_data.size) + 32 len 32 * _1840] = mem[_1808 + _1824 + 32 len 32 * _1840]
                    if 0 >= _1840:
                        revert with 0, 50
                    _2144 = mem[_1808 + ceil32(return_data.size) + 32]
                    if mem[_1808 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1808 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2144 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2144 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2192 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2192] == bool(mem[_2192])
                    if arg4 < _2144:
                        revert with 0, 17
                    if arg4 - _2144 < _2144 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2144 - (_2144 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2144 - (_2144 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2256 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2256] == bool(mem[_2256])
                    emit 0xfedb587d: address(arg2), _2144, tokenAddress, arg3
                else:
                    _1319 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1319]:
                        revert with 0, 50
                    mem[_1319 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1319]:
                        revert with 0, 50
                    mem[_1319 + 32] = address(arg2)
                    if 2 >= mem[_1319]:
                        revert with 0, 50
                    mem[_1319 + 96] = tokenAddress
                    mem[_1319 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1319 + ceil32(return_data.size) + 132] = arg3
                    mem[_1319 + ceil32(return_data.size) + 164] = arg4
                    mem[_1319 + ceil32(return_data.size) + 196] = 160
                    mem[_1319 + ceil32(return_data.size) + 292] = mem[_1319]
                    idx = 0
                    s = _1319 + 32
                    t = _1319 + ceil32(return_data.size) + 324
                    while idx < mem[_1319]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1319 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1319 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1319 + ceil32(return_data.size) + (32 * mem[_1319]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1807 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1823 = mem[_1807]
                    require mem[_1807] <= test266151307()
                    require _1807 + mem[_1807] + 31 < _1807 + return_data.size
                    _1839 = mem[_1807 + mem[_1807]]
                    if mem[_1807 + mem[_1807]] > test266151307():
                        revert with 0, 65
                    if _1807 + ceil32(return_data.size) + ceil32(32 * mem[_1807 + mem[_1807]]) + 1 > test266151307() or ceil32(32 * mem[_1807 + mem[_1807]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1807 + ceil32(return_data.size) + ceil32(32 * mem[_1807 + mem[_1807]]) + 1
                    mem[_1807 + ceil32(return_data.size)] = _1839
                    require return_data.size >= _1823 + (32 * _1839) + 32
                    mem[_1807 + ceil32(return_data.size) + 32 len 32 * _1839] = mem[_1807 + _1823 + 32 len 32 * _1839]
                    if 0 >= _1839:
                        revert with 0, 50
                    _2143 = mem[_1807 + ceil32(return_data.size) + 32]
                    if mem[_1807 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1807 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2143 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2143 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2191 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2191] == bool(mem[_2191])
                    if arg4 < _2143:
                        revert with 0, 17
                    if arg4 - _2143 < _2143 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2143 - (_2143 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2143 - (_2143 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2255 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2255] == bool(mem[_2255])
                    emit 0xfedb587d: address(arg2), _2143, tokenAddress, arg3
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg4
            require ext_code.size(address(arg2))
            call address(arg2).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg4
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _698 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _706 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _698 + (32 * _706) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _706] = mem[(4 * ceil32(return_data.size)) + _698 + 224 len 32 * _706]
                if 0 >= _706:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1306 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1306] == mem[_1306 + 12 len 20]
                if address(arg2) == mem[_1306 + 12 len 20]:
                    _1334 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1334]:
                        revert with 0, 50
                    mem[_1334 + 32] = address(arg2)
                    if 1 >= mem[_1334]:
                        revert with 0, 50
                    mem[_1334 + 64] = tokenAddress
                    mem[_1334 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1334 + 100] = arg3
                    mem[_1334 + 132] = arg4
                    mem[_1334 + 164] = 160
                    mem[_1334 + 260] = mem[_1334]
                    idx = 0
                    s = _1334 + 32
                    t = _1334 + 292
                    while idx < mem[_1334]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1334 + 196] = address(arg1)
                    mem[_1334 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1334 + (32 * mem[_1334]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1814 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1830 = mem[_1814]
                    require mem[_1814] <= test266151307()
                    require _1814 + mem[_1814] + 31 < _1814 + return_data.size
                    _1846 = mem[_1814 + mem[_1814]]
                    if mem[_1814 + mem[_1814]] > test266151307():
                        revert with 0, 65
                    if _1814 + ceil32(return_data.size) + ceil32(32 * mem[_1814 + mem[_1814]]) + 1 > test266151307() or ceil32(32 * mem[_1814 + mem[_1814]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1814 + ceil32(return_data.size) + ceil32(32 * mem[_1814 + mem[_1814]]) + 1
                    mem[_1814 + ceil32(return_data.size)] = _1846
                    require return_data.size >= _1830 + (32 * _1846) + 32
                    mem[_1814 + ceil32(return_data.size) + 32 len 32 * _1846] = mem[_1814 + _1830 + 32 len 32 * _1846]
                    if 0 >= _1846:
                        revert with 0, 50
                    _2150 = mem[_1814 + ceil32(return_data.size) + 32]
                    if mem[_1814 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1814 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2150 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2150 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2198 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2198] == bool(mem[_2198])
                    if arg4 < _2150:
                        revert with 0, 17
                    if arg4 - _2150 < _2150 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2150 - (_2150 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2150 - (_2150 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2262 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2262] == bool(mem[_2262])
                    emit 0xfedb587d: address(arg2), _2150, tokenAddress, arg3
                else:
                    _1331 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1331]:
                        revert with 0, 50
                    mem[_1331 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1331]:
                        revert with 0, 50
                    mem[_1331 + 32] = address(arg2)
                    if 2 >= mem[_1331]:
                        revert with 0, 50
                    mem[_1331 + 96] = tokenAddress
                    mem[_1331 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1331 + ceil32(return_data.size) + 132] = arg3
                    mem[_1331 + ceil32(return_data.size) + 164] = arg4
                    mem[_1331 + ceil32(return_data.size) + 196] = 160
                    mem[_1331 + ceil32(return_data.size) + 292] = mem[_1331]
                    idx = 0
                    s = _1331 + 32
                    t = _1331 + ceil32(return_data.size) + 324
                    while idx < mem[_1331]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1331 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1331 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1331 + ceil32(return_data.size) + (32 * mem[_1331]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1813 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1829 = mem[_1813]
                    require mem[_1813] <= test266151307()
                    require _1813 + mem[_1813] + 31 < _1813 + return_data.size
                    _1845 = mem[_1813 + mem[_1813]]
                    if mem[_1813 + mem[_1813]] > test266151307():
                        revert with 0, 65
                    if _1813 + ceil32(return_data.size) + ceil32(32 * mem[_1813 + mem[_1813]]) + 1 > test266151307() or ceil32(32 * mem[_1813 + mem[_1813]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1813 + ceil32(return_data.size) + ceil32(32 * mem[_1813 + mem[_1813]]) + 1
                    mem[_1813 + ceil32(return_data.size)] = _1845
                    require return_data.size >= _1829 + (32 * _1845) + 32
                    mem[_1813 + ceil32(return_data.size) + 32 len 32 * _1845] = mem[_1813 + _1829 + 32 len 32 * _1845]
                    if 0 >= _1845:
                        revert with 0, 50
                    _2149 = mem[_1813 + ceil32(return_data.size) + 32]
                    if mem[_1813 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1813 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2149 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2149 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2197 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2197] == bool(mem[_2197])
                    if arg4 < _2149:
                        revert with 0, 17
                    if arg4 - _2149 < _2149 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2149 - (_2149 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2149 - (_2149 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2261 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2261] == bool(mem[_2261])
                    emit 0xfedb587d: address(arg2), _2149, tokenAddress, arg3
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(6 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _697 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _705 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _697 + (32 * _705) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _705] = mem[(6 * ceil32(return_data.size)) + _697 + 256 len 32 * _705]
                if 0 >= _705:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(7 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(7 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1305 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1305] == mem[_1305 + 12 len 20]
                if address(arg2) == mem[_1305 + 12 len 20]:
                    _1330 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1330]:
                        revert with 0, 50
                    mem[_1330 + 32] = address(arg2)
                    if 1 >= mem[_1330]:
                        revert with 0, 50
                    mem[_1330 + 64] = tokenAddress
                    mem[_1330 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1330 + 100] = arg3
                    mem[_1330 + 132] = arg4
                    mem[_1330 + 164] = 160
                    mem[_1330 + 260] = mem[_1330]
                    idx = 0
                    s = _1330 + 32
                    t = _1330 + 292
                    while idx < mem[_1330]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1330 + 196] = address(arg1)
                    mem[_1330 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1330 + (32 * mem[_1330]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1812 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1828 = mem[_1812]
                    require mem[_1812] <= test266151307()
                    require _1812 + mem[_1812] + 31 < _1812 + return_data.size
                    _1844 = mem[_1812 + mem[_1812]]
                    if mem[_1812 + mem[_1812]] > test266151307():
                        revert with 0, 65
                    if _1812 + ceil32(return_data.size) + ceil32(32 * mem[_1812 + mem[_1812]]) + 1 > test266151307() or ceil32(32 * mem[_1812 + mem[_1812]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1812 + ceil32(return_data.size) + ceil32(32 * mem[_1812 + mem[_1812]]) + 1
                    mem[_1812 + ceil32(return_data.size)] = _1844
                    require return_data.size >= _1828 + (32 * _1844) + 32
                    mem[_1812 + ceil32(return_data.size) + 32 len 32 * _1844] = mem[_1812 + _1828 + 32 len 32 * _1844]
                    if 0 >= _1844:
                        revert with 0, 50
                    _2148 = mem[_1812 + ceil32(return_data.size) + 32]
                    if mem[_1812 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1812 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2148 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2148 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2196 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2196] == bool(mem[_2196])
                    if arg4 < _2148:
                        revert with 0, 17
                    if arg4 - _2148 < _2148 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2148 - (_2148 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2148 - (_2148 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2260 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2260] == bool(mem[_2260])
                    emit 0xfedb587d: address(arg2), _2148, tokenAddress, arg3
                else:
                    _1327 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1327]:
                        revert with 0, 50
                    mem[_1327 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1327]:
                        revert with 0, 50
                    mem[_1327 + 32] = address(arg2)
                    if 2 >= mem[_1327]:
                        revert with 0, 50
                    mem[_1327 + 96] = tokenAddress
                    mem[_1327 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1327 + ceil32(return_data.size) + 132] = arg3
                    mem[_1327 + ceil32(return_data.size) + 164] = arg4
                    mem[_1327 + ceil32(return_data.size) + 196] = 160
                    mem[_1327 + ceil32(return_data.size) + 292] = mem[_1327]
                    idx = 0
                    s = _1327 + 32
                    t = _1327 + ceil32(return_data.size) + 324
                    while idx < mem[_1327]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1327 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1327 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg3, arg4, 160, address(arg1), arg5, mem[_1327 + ceil32(return_data.size) + 292 len (32 * mem[_1327]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1327 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1327 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    _1827 = mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32
                    require mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                    require _1327 + ceil32(return_data.size) + mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _1327 + ceil32(return_data.size) + return_data.size + 128
                    _1843 = mem[_1327 + ceil32(return_data.size) + mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                    if mem[_1327 + ceil32(return_data.size) + mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if _1327 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1327 + ceil32(return_data.size) + mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1327 + ceil32(return_data.size) + mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1327 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1327 + ceil32(return_data.size) + mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                    mem[_1327 + (2 * ceil32(return_data.size)) + 128] = mem[_1327 + ceil32(return_data.size) + mem[_1327 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                    require return_data.size >= _1827 + (32 * _1843) + 32
                    mem[_1327 + (2 * ceil32(return_data.size)) + 160 len 32 * _1843] = mem[_1327 + ceil32(return_data.size) + _1827 + 160 len 32 * _1843]
                    if 0 >= _1843:
                        revert with 0, 50
                    _2147 = mem[_1327 + (2 * ceil32(return_data.size)) + 160]
                    if mem[_1327 + (2 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_1327 + (2 * ceil32(return_data.size)) + 160]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2147 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2147 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2195 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2195] == bool(mem[_2195])
                    if arg4 < _2147:
                        revert with 0, 17
                    if arg4 - _2147 < _2147 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2147 - (_2147 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2147 - (_2147 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2259 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2259] == bool(mem[_2259])
                    emit 0xfedb587d: address(arg2), _2147, tokenAddress, arg3
    else:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(address(arg2))
        staticcall address(arg2).allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg4:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _700 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _708 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _700 + (32 * _708) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _708] = mem[(2 * ceil32(return_data.size)) + _700 + 224 len 32 * _708]
                if 0 >= _708:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(4 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1308 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1308] == mem[_1308 + 12 len 20]
                if address(arg2) == mem[_1308 + 12 len 20]:
                    _1342 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1342]:
                        revert with 0, 50
                    mem[_1342 + 32] = address(arg2)
                    if 1 >= mem[_1342]:
                        revert with 0, 50
                    mem[_1342 + 64] = tokenAddress
                    mem[_1342 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1342 + 100] = arg3
                    mem[_1342 + 132] = arg4
                    mem[_1342 + 164] = 160
                    mem[_1342 + 260] = mem[_1342]
                    idx = 0
                    s = _1342 + 32
                    t = _1342 + 292
                    while idx < mem[_1342]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1342 + 196] = address(arg1)
                    mem[_1342 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1342 + (32 * mem[_1342]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1818 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1834 = mem[_1818]
                    require mem[_1818] <= test266151307()
                    require _1818 + mem[_1818] + 31 < _1818 + return_data.size
                    _1850 = mem[_1818 + mem[_1818]]
                    if mem[_1818 + mem[_1818]] > test266151307():
                        revert with 0, 65
                    if _1818 + ceil32(return_data.size) + ceil32(32 * mem[_1818 + mem[_1818]]) + 1 > test266151307() or ceil32(32 * mem[_1818 + mem[_1818]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1818 + ceil32(return_data.size) + ceil32(32 * mem[_1818 + mem[_1818]]) + 1
                    mem[_1818 + ceil32(return_data.size)] = _1850
                    require return_data.size >= _1834 + (32 * _1850) + 32
                    mem[_1818 + ceil32(return_data.size) + 32 len 32 * _1850] = mem[_1818 + _1834 + 32 len 32 * _1850]
                    if 0 >= _1850:
                        revert with 0, 50
                    _2154 = mem[_1818 + ceil32(return_data.size) + 32]
                    if mem[_1818 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1818 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2154 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2154 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2202 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2202] == bool(mem[_2202])
                    if arg4 < _2154:
                        revert with 0, 17
                    if arg4 - _2154 < _2154 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2154 - (_2154 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2154 - (_2154 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2266 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2266] == bool(mem[_2266])
                    emit 0xfedb587d: address(arg2), _2154, tokenAddress, arg3
                else:
                    _1339 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1339]:
                        revert with 0, 50
                    mem[_1339 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1339]:
                        revert with 0, 50
                    mem[_1339 + 32] = address(arg2)
                    if 2 >= mem[_1339]:
                        revert with 0, 50
                    mem[_1339 + 96] = tokenAddress
                    mem[_1339 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1339 + ceil32(return_data.size) + 132] = arg3
                    mem[_1339 + ceil32(return_data.size) + 164] = arg4
                    mem[_1339 + ceil32(return_data.size) + 196] = 160
                    mem[_1339 + ceil32(return_data.size) + 292] = mem[_1339]
                    idx = 0
                    s = _1339 + 32
                    t = _1339 + ceil32(return_data.size) + 324
                    while idx < mem[_1339]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1339 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1339 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg3, arg4, 160, address(arg1), arg5, mem[_1339 + ceil32(return_data.size) + 292 len (32 * mem[_1339]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1339 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1339 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    _1833 = mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32
                    require mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                    require _1339 + ceil32(return_data.size) + mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _1339 + ceil32(return_data.size) + return_data.size + 128
                    _1849 = mem[_1339 + ceil32(return_data.size) + mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                    if mem[_1339 + ceil32(return_data.size) + mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                        revert with 0, 65
                    if _1339 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1339 + ceil32(return_data.size) + mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1339 + ceil32(return_data.size) + mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1339 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1339 + ceil32(return_data.size) + mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                    mem[_1339 + (2 * ceil32(return_data.size)) + 128] = mem[_1339 + ceil32(return_data.size) + mem[_1339 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                    require return_data.size >= _1833 + (32 * _1849) + 32
                    mem[_1339 + (2 * ceil32(return_data.size)) + 160 len 32 * _1849] = mem[_1339 + ceil32(return_data.size) + _1833 + 160 len 32 * _1849]
                    if 0 >= _1849:
                        revert with 0, 50
                    _2153 = mem[_1339 + (2 * ceil32(return_data.size)) + 160]
                    if mem[_1339 + (2 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_1339 + (2 * ceil32(return_data.size)) + 160]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2153 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2153 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2201 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2201] == bool(mem[_2201])
                    if arg4 < _2153:
                        revert with 0, 17
                    if arg4 - _2153 < _2153 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2153 - (_2153 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2153 - (_2153 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2265 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2265] == bool(mem[_2265])
                    emit 0xfedb587d: address(arg2), _2153, tokenAddress, arg3
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _699 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _707 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _699 + (32 * _707) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _707] = mem[(4 * ceil32(return_data.size)) + _699 + 256 len 32 * _707]
                if 0 >= _707:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1307 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1307] == mem[_1307 + 12 len 20]
                if address(arg2) == mem[_1307 + 12 len 20]:
                    _1338 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1338]:
                        revert with 0, 50
                    mem[_1338 + 32] = address(arg2)
                    if 1 >= mem[_1338]:
                        revert with 0, 50
                    mem[_1338 + 64] = tokenAddress
                    mem[_1338 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1338 + 100] = arg3
                    mem[_1338 + 132] = arg4
                    mem[_1338 + 164] = 160
                    mem[_1338 + 260] = mem[_1338]
                    idx = 0
                    s = _1338 + 32
                    t = _1338 + 292
                    while idx < mem[_1338]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1338 + 196] = address(arg1)
                    mem[_1338 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1338 + (32 * mem[_1338]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1816 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1832 = mem[_1816]
                    require mem[_1816] <= test266151307()
                    require _1816 + mem[_1816] + 31 < _1816 + return_data.size
                    _1848 = mem[_1816 + mem[_1816]]
                    if mem[_1816 + mem[_1816]] > test266151307():
                        revert with 0, 65
                    if _1816 + ceil32(return_data.size) + ceil32(32 * mem[_1816 + mem[_1816]]) + 1 > test266151307() or ceil32(32 * mem[_1816 + mem[_1816]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1816 + ceil32(return_data.size) + ceil32(32 * mem[_1816 + mem[_1816]]) + 1
                    mem[_1816 + ceil32(return_data.size)] = _1848
                    require return_data.size >= _1832 + (32 * _1848) + 32
                    mem[_1816 + ceil32(return_data.size) + 32 len 32 * _1848] = mem[_1816 + _1832 + 32 len 32 * _1848]
                    if 0 >= _1848:
                        revert with 0, 50
                    _2152 = mem[_1816 + ceil32(return_data.size) + 32]
                    if mem[_1816 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1816 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2152 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2152 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2200 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2200] == bool(mem[_2200])
                    if arg4 < _2152:
                        revert with 0, 17
                    if arg4 - _2152 < _2152 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2152 - (_2152 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2152 - (_2152 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2264 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2264] == bool(mem[_2264])
                    emit 0xfedb587d: address(arg2), _2152, tokenAddress, arg3
                else:
                    _1335 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1335]:
                        revert with 0, 50
                    mem[_1335 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1335]:
                        revert with 0, 50
                    mem[_1335 + 32] = address(arg2)
                    if 2 >= mem[_1335]:
                        revert with 0, 50
                    mem[_1335 + 96] = tokenAddress
                    mem[_1335 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1335 + ceil32(return_data.size) + 132] = arg3
                    mem[_1335 + ceil32(return_data.size) + 164] = arg4
                    mem[_1335 + ceil32(return_data.size) + 196] = 160
                    mem[_1335 + ceil32(return_data.size) + 292] = mem[_1335]
                    idx = 0
                    s = _1335 + 32
                    t = _1335 + ceil32(return_data.size) + 324
                    while idx < mem[_1335]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1335 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1335 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1335 + ceil32(return_data.size) + (32 * mem[_1335]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1815 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1831 = mem[_1815]
                    require mem[_1815] <= test266151307()
                    require _1815 + mem[_1815] + 31 < _1815 + return_data.size
                    _1847 = mem[_1815 + mem[_1815]]
                    if mem[_1815 + mem[_1815]] > test266151307():
                        revert with 0, 65
                    if _1815 + ceil32(return_data.size) + ceil32(32 * mem[_1815 + mem[_1815]]) + 1 > test266151307() or ceil32(32 * mem[_1815 + mem[_1815]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1815 + ceil32(return_data.size) + ceil32(32 * mem[_1815 + mem[_1815]]) + 1
                    mem[_1815 + ceil32(return_data.size)] = _1847
                    require return_data.size >= _1831 + (32 * _1847) + 32
                    mem[_1815 + ceil32(return_data.size) + 32 len 32 * _1847] = mem[_1815 + _1831 + 32 len 32 * _1847]
                    if 0 >= _1847:
                        revert with 0, 50
                    _2151 = mem[_1815 + ceil32(return_data.size) + 32]
                    if mem[_1815 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1815 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2151 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2151 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2199 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2199] == bool(mem[_2199])
                    if arg4 < _2151:
                        revert with 0, 17
                    if arg4 - _2151 < _2151 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2151 - (_2151 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2151 - (_2151 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2263 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2263] == bool(mem[_2263])
                    emit 0xfedb587d: address(arg2), _2151, tokenAddress, arg3
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg4
            require ext_code.size(address(arg2))
            call address(arg2).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg4
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _702 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _710 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _702 + (32 * _710) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _710] = mem[(4 * ceil32(return_data.size)) + _702 + 224 len 32 * _710]
                if 0 >= _710:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1310 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1310] == mem[_1310 + 12 len 20]
                if address(arg2) == mem[_1310 + 12 len 20]:
                    _1350 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1350]:
                        revert with 0, 50
                    mem[_1350 + 32] = address(arg2)
                    if 1 >= mem[_1350]:
                        revert with 0, 50
                    mem[_1350 + 64] = tokenAddress
                    mem[_1350 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1350 + 100] = arg3
                    mem[_1350 + 132] = arg4
                    mem[_1350 + 164] = 160
                    mem[_1350 + 260] = mem[_1350]
                    idx = 0
                    s = _1350 + 32
                    t = _1350 + 292
                    while idx < mem[_1350]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1350 + 196] = address(arg1)
                    mem[_1350 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1350 + (32 * mem[_1350]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1822 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1838 = mem[_1822]
                    require mem[_1822] <= test266151307()
                    require _1822 + mem[_1822] + 31 < _1822 + return_data.size
                    _1854 = mem[_1822 + mem[_1822]]
                    if mem[_1822 + mem[_1822]] > test266151307():
                        revert with 0, 65
                    if _1822 + ceil32(return_data.size) + ceil32(32 * mem[_1822 + mem[_1822]]) + 1 > test266151307() or ceil32(32 * mem[_1822 + mem[_1822]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1822 + ceil32(return_data.size) + ceil32(32 * mem[_1822 + mem[_1822]]) + 1
                    mem[_1822 + ceil32(return_data.size)] = _1854
                    require return_data.size >= _1838 + (32 * _1854) + 32
                    mem[_1822 + ceil32(return_data.size) + 32 len 32 * _1854] = mem[_1822 + _1838 + 32 len 32 * _1854]
                    if 0 >= _1854:
                        revert with 0, 50
                    _2158 = mem[_1822 + ceil32(return_data.size) + 32]
                    if mem[_1822 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1822 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2158 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2158 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2206 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2206] == bool(mem[_2206])
                    if arg4 < _2158:
                        revert with 0, 17
                    if arg4 - _2158 < _2158 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2158 - (_2158 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2158 - (_2158 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2270 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2270] == bool(mem[_2270])
                    emit 0xfedb587d: address(arg2), _2158, tokenAddress, arg3
                else:
                    _1347 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1347]:
                        revert with 0, 50
                    mem[_1347 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1347]:
                        revert with 0, 50
                    mem[_1347 + 32] = address(arg2)
                    if 2 >= mem[_1347]:
                        revert with 0, 50
                    mem[_1347 + 96] = tokenAddress
                    mem[_1347 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1347 + ceil32(return_data.size) + 132] = arg3
                    mem[_1347 + ceil32(return_data.size) + 164] = arg4
                    mem[_1347 + ceil32(return_data.size) + 196] = 160
                    mem[_1347 + ceil32(return_data.size) + 292] = mem[_1347]
                    idx = 0
                    s = _1347 + 32
                    t = _1347 + ceil32(return_data.size) + 324
                    while idx < mem[_1347]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1347 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1347 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1347 + ceil32(return_data.size) + (32 * mem[_1347]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1821 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1837 = mem[_1821]
                    require mem[_1821] <= test266151307()
                    require _1821 + mem[_1821] + 31 < _1821 + return_data.size
                    _1853 = mem[_1821 + mem[_1821]]
                    if mem[_1821 + mem[_1821]] > test266151307():
                        revert with 0, 65
                    if _1821 + ceil32(return_data.size) + ceil32(32 * mem[_1821 + mem[_1821]]) + 1 > test266151307() or ceil32(32 * mem[_1821 + mem[_1821]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1821 + ceil32(return_data.size) + ceil32(32 * mem[_1821 + mem[_1821]]) + 1
                    mem[_1821 + ceil32(return_data.size)] = _1853
                    require return_data.size >= _1837 + (32 * _1853) + 32
                    mem[_1821 + ceil32(return_data.size) + 32 len 32 * _1853] = mem[_1821 + _1837 + 32 len 32 * _1853]
                    if 0 >= _1853:
                        revert with 0, 50
                    _2157 = mem[_1821 + ceil32(return_data.size) + 32]
                    if mem[_1821 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1821 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2157 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2157 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2205 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2205] == bool(mem[_2205])
                    if arg4 < _2157:
                        revert with 0, 17
                    if arg4 - _2157 < _2157 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2157 - (_2157 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2157 - (_2157 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2269 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2269] == bool(mem[_2269])
                    emit 0xfedb587d: address(arg2), _2157, tokenAddress, arg3
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                mem[(6 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _701 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _709 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _701 + (32 * _709) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _709] = mem[(6 * ceil32(return_data.size)) + _701 + 256 len 32 * _709]
                if 0 >= _709:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(7 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(7 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1309 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1309] == mem[_1309 + 12 len 20]
                if address(arg2) == mem[_1309 + 12 len 20]:
                    _1346 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1346]:
                        revert with 0, 50
                    mem[_1346 + 32] = address(arg2)
                    if 1 >= mem[_1346]:
                        revert with 0, 50
                    mem[_1346 + 64] = tokenAddress
                    mem[_1346 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1346 + 100] = arg3
                    mem[_1346 + 132] = arg4
                    mem[_1346 + 164] = 160
                    mem[_1346 + 260] = mem[_1346]
                    idx = 0
                    s = _1346 + 32
                    t = _1346 + 292
                    while idx < mem[_1346]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1346 + 196] = address(arg1)
                    mem[_1346 + 228] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1346 + (32 * mem[_1346]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1820 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1836 = mem[_1820]
                    require mem[_1820] <= test266151307()
                    require _1820 + mem[_1820] + 31 < _1820 + return_data.size
                    _1852 = mem[_1820 + mem[_1820]]
                    if mem[_1820 + mem[_1820]] > test266151307():
                        revert with 0, 65
                    if _1820 + ceil32(return_data.size) + ceil32(32 * mem[_1820 + mem[_1820]]) + 1 > test266151307() or ceil32(32 * mem[_1820 + mem[_1820]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1820 + ceil32(return_data.size) + ceil32(32 * mem[_1820 + mem[_1820]]) + 1
                    mem[_1820 + ceil32(return_data.size)] = _1852
                    require return_data.size >= _1836 + (32 * _1852) + 32
                    mem[_1820 + ceil32(return_data.size) + 32 len 32 * _1852] = mem[_1820 + _1836 + 32 len 32 * _1852]
                    if 0 >= _1852:
                        revert with 0, 50
                    _2156 = mem[_1820 + ceil32(return_data.size) + 32]
                    if mem[_1820 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1820 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2156 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2156 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2204 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2204] == bool(mem[_2204])
                    if arg4 < _2156:
                        revert with 0, 17
                    if arg4 - _2156 < _2156 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2156 - (_2156 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2156 - (_2156 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2268 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2268] == bool(mem[_2268])
                    emit 0xfedb587d: address(arg2), _2156, tokenAddress, arg3
                else:
                    _1343 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1343]:
                        revert with 0, 50
                    mem[_1343 + 64] = ext_call.return_data[12 len 20]
                    if 0 >= mem[_1343]:
                        revert with 0, 50
                    mem[_1343 + 32] = address(arg2)
                    if 2 >= mem[_1343]:
                        revert with 0, 50
                    mem[_1343 + 96] = tokenAddress
                    mem[_1343 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                    mem[_1343 + ceil32(return_data.size) + 132] = arg3
                    mem[_1343 + ceil32(return_data.size) + 164] = arg4
                    mem[_1343 + ceil32(return_data.size) + 196] = 160
                    mem[_1343 + ceil32(return_data.size) + 292] = mem[_1343]
                    idx = 0
                    s = _1343 + 32
                    t = _1343 + ceil32(return_data.size) + 324
                    while idx < mem[_1343]:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1343 + ceil32(return_data.size) + 228] = address(arg1)
                    mem[_1343 + ceil32(return_data.size) + 260] = arg5
                    require ext_code.size(stor101)
                    call stor101.mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len _1343 + ceil32(return_data.size) + (32 * mem[_1343]) + -mem[64] + 320]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1819 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1835 = mem[_1819]
                    require mem[_1819] <= test266151307()
                    require _1819 + mem[_1819] + 31 < _1819 + return_data.size
                    _1851 = mem[_1819 + mem[_1819]]
                    if mem[_1819 + mem[_1819]] > test266151307():
                        revert with 0, 65
                    if _1819 + ceil32(return_data.size) + ceil32(32 * mem[_1819 + mem[_1819]]) + 1 > test266151307() or ceil32(32 * mem[_1819 + mem[_1819]]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = _1819 + ceil32(return_data.size) + ceil32(32 * mem[_1819 + mem[_1819]]) + 1
                    mem[_1819 + ceil32(return_data.size)] = _1851
                    require return_data.size >= _1835 + (32 * _1851) + 32
                    mem[_1819 + ceil32(return_data.size) + 32 len 32 * _1851] = mem[_1819 + _1835 + 32 len 32 * _1851]
                    if 0 >= _1851:
                        revert with 0, 50
                    _2155 = mem[_1819 + ceil32(return_data.size) + 32]
                    if mem[_1819 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_1819 + ceil32(return_data.size) + 32]:
                        revert with 0, 17
                    mem[mem[64] + 4] = sub_11eb47dcAddress
                    mem[mem[64] + 36] = _2155 * sub_fd53fce0 / 100 * 10^6
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args sub_11eb47dcAddress, _2155 * sub_fd53fce0 / 100 * 10^6
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2203 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2203] == bool(mem[_2203])
                    if arg4 < _2155:
                        revert with 0, 17
                    if arg4 - _2155 < _2155 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    mem[mem[64] + 4] = address(arg1)
                    mem[mem[64] + 36] = arg4 - _2155 - (_2155 * sub_fd53fce0 / 100 * 10^6)
                    require ext_code.size(address(arg2))
                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg4 - _2155 - (_2155 * sub_fd53fce0 / 100 * 10^6)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2267 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2267] == bool(mem[_2267])
                    emit 0xfedb587d: address(arg2), _2155, tokenAddress, arg3
}

function sub_88e5249f(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if msg.sender == tokenAddress:
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(stor105)
        staticcall stor105.allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg3:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _944 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _952 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _944 + (32 * _952) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _952] = mem[(2 * ceil32(return_data.size)) + _944 + 224 len 32 * _952]
                if _952 < 1:
                    revert with 0, 17
                if _952 - 1 >= _952:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _952 - 1) + (4 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _952 - 1) + (4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _952 - 1) + (4 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _952 - 1) + (4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1808 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1808] == bool(mem[_1808])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1840 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1840] == mem[_1840 + 12 len 20]
                if address(arg2) == mem[_1840 + 12 len 20]:
                    _1862 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1862]:
                        revert with 0, 50
                    mem[_1862 + 32] = tokenAddress
                    if 1 >= mem[_1862]:
                        revert with 0, 50
                    mem[_1862 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1862 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1862 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1862 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1862 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1862 + ceil32(return_data.size) + 132] = arg4
                        mem[_1862 + ceil32(return_data.size) + 164] = 160
                        mem[_1862 + ceil32(return_data.size) + 260] = mem[_1862]
                        idx = 0
                        s = _1862 + 32
                        t = _1862 + ceil32(return_data.size) + 292
                        while idx < mem[_1862]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1862 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1862 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1862 + ceil32(return_data.size) + (32 * mem[_1862]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2589 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2621 = mem[_2589]
                        require mem[_2589] <= test266151307()
                        require _2589 + mem[_2589] + 31 < _2589 + return_data.size
                        _2653 = mem[_2589 + mem[_2589]]
                        if mem[_2589 + mem[_2589]] > test266151307():
                            revert with 0, 65
                        if _2589 + ceil32(return_data.size) + ceil32(32 * mem[_2589 + mem[_2589]]) + 1 > test266151307() or ceil32(32 * mem[_2589 + mem[_2589]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2589 + ceil32(return_data.size) + ceil32(32 * mem[_2589 + mem[_2589]]) + 1
                        mem[_2589 + ceil32(return_data.size)] = _2653
                        require return_data.size >= _2621 + (32 * _2653) + 32
                        mem[_2589 + ceil32(return_data.size) + 32 len 32 * _2653] = mem[_2589 + _2621 + 32 len 32 * _2653]
                        if _2653 < 1:
                            revert with 0, 17
                        if _2653 - 1 >= _2653:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2653 - 1) + _2589 + ceil32(return_data.size) + 32]
                    else:
                        mem[_1862 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1862 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1862 + ceil32(return_data.size) + 132] = arg4
                        mem[_1862 + ceil32(return_data.size) + 164] = 160
                        mem[_1862 + ceil32(return_data.size) + 260] = mem[_1862]
                        idx = 0
                        s = _1862 + 32
                        t = _1862 + ceil32(return_data.size) + 292
                        while idx < mem[_1862]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1862 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1862 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1862 + ceil32(return_data.size) + (32 * mem[_1862]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2590 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2622 = mem[_2590]
                        require mem[_2590] <= test266151307()
                        require _2590 + mem[_2590] + 31 < _2590 + return_data.size
                        _2654 = mem[_2590 + mem[_2590]]
                        if mem[_2590 + mem[_2590]] > test266151307():
                            revert with 0, 65
                        if _2590 + ceil32(return_data.size) + ceil32(32 * mem[_2590 + mem[_2590]]) + 1 > test266151307() or ceil32(32 * mem[_2590 + mem[_2590]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2590 + ceil32(return_data.size) + ceil32(32 * mem[_2590 + mem[_2590]]) + 1
                        mem[_2590 + ceil32(return_data.size)] = _2654
                        require return_data.size >= _2622 + (32 * _2654) + 32
                        mem[_2590 + ceil32(return_data.size) + 32 len 32 * _2654] = mem[_2590 + _2622 + 32 len 32 * _2654]
                        if _2654 < 1:
                            revert with 0, 17
                        if _2654 - 1 >= _2654:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2654 - 1) + _2590 + ceil32(return_data.size) + 32]
                else:
                    _1859 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1859]:
                        revert with 0, 50
                    mem[_1859 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1859]:
                        revert with 0, 50
                    mem[_1859 + 32] = tokenAddress
                    if 2 >= mem[_1859]:
                        revert with 0, 50
                    mem[_1859 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1859 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1859 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1859 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1859 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1859 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1859 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1859 + (2 * ceil32(return_data.size)) + 292] = mem[_1859]
                        idx = 0
                        s = _1859 + 32
                        t = _1859 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1859]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1859 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1859 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1859 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1859]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1859 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1859 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2619 = mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1859 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2651 = mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1859 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[_1859 + (4 * ceil32(return_data.size)) + 128] = mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2619 + (32 * _2651) + 32
                        mem[_1859 + (4 * ceil32(return_data.size)) + 160 len 32 * _2651] = mem[_1859 + (2 * ceil32(return_data.size)) + _2619 + 160 len 32 * _2651]
                        if _2651 < 1:
                            revert with 0, 17
                        if _2651 - 1 >= _2651:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2651 - 1) + _1859 + (4 * ceil32(return_data.size)) + 160]
                    else:
                        mem[_1859 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1859 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1859 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1859 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1859 + (2 * ceil32(return_data.size)) + 292] = mem[_1859]
                        idx = 0
                        s = _1859 + 32
                        t = _1859 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1859]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1859 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1859 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1859 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1859]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1859 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1859 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2620 = mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1859 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2652 = mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1859 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[_1859 + (4 * ceil32(return_data.size)) + 128] = mem[_1859 + (2 * ceil32(return_data.size)) + mem[_1859 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2620 + (32 * _2652) + 32
                        mem[_1859 + (4 * ceil32(return_data.size)) + 160 len 32 * _2652] = mem[_1859 + (2 * ceil32(return_data.size)) + _2620 + 160 len 32 * _2652]
                        if _2652 < 1:
                            revert with 0, 17
                        if _2652 - 1 >= _2652:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2652 - 1) + _1859 + (4 * ceil32(return_data.size)) + 160]
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _943 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _951 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _943 + (32 * _951) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _951] = mem[(4 * ceil32(return_data.size)) + _943 + 256 len 32 * _951]
                if _951 < 1:
                    revert with 0, 17
                if _951 - 1 >= _951:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _951 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _951 - 1) + (6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _951 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _951 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1807 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1807] == bool(mem[_1807])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1839 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1839] == mem[_1839 + 12 len 20]
                if address(arg2) == mem[_1839 + 12 len 20]:
                    _1858 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1858]:
                        revert with 0, 50
                    mem[_1858 + 32] = tokenAddress
                    if 1 >= mem[_1858]:
                        revert with 0, 50
                    mem[_1858 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1858 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1858 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1858 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1858 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1858 + ceil32(return_data.size) + 132] = arg4
                        mem[_1858 + ceil32(return_data.size) + 164] = 160
                        mem[_1858 + ceil32(return_data.size) + 260] = mem[_1858]
                        idx = 0
                        s = _1858 + 32
                        t = _1858 + ceil32(return_data.size) + 292
                        while idx < mem[_1858]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1858 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1858 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1858 + ceil32(return_data.size) + (32 * mem[_1858]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2585 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2617 = mem[_2585]
                        require mem[_2585] <= test266151307()
                        require _2585 + mem[_2585] + 31 < _2585 + return_data.size
                        _2649 = mem[_2585 + mem[_2585]]
                        if mem[_2585 + mem[_2585]] > test266151307():
                            revert with 0, 65
                        if _2585 + ceil32(return_data.size) + ceil32(32 * mem[_2585 + mem[_2585]]) + 1 > test266151307() or ceil32(32 * mem[_2585 + mem[_2585]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2585 + ceil32(return_data.size) + ceil32(32 * mem[_2585 + mem[_2585]]) + 1
                        mem[_2585 + ceil32(return_data.size)] = _2649
                        require return_data.size >= _2617 + (32 * _2649) + 32
                        mem[_2585 + ceil32(return_data.size) + 32 len 32 * _2649] = mem[_2585 + _2617 + 32 len 32 * _2649]
                        if _2649 < 1:
                            revert with 0, 17
                        if _2649 - 1 >= _2649:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2649 - 1) + _2585 + ceil32(return_data.size) + 32]
                    else:
                        mem[_1858 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1858 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1858 + ceil32(return_data.size) + 132] = arg4
                        mem[_1858 + ceil32(return_data.size) + 164] = 160
                        mem[_1858 + ceil32(return_data.size) + 260] = mem[_1858]
                        idx = 0
                        s = _1858 + 32
                        t = _1858 + ceil32(return_data.size) + 292
                        while idx < mem[_1858]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1858 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1858 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1858 + ceil32(return_data.size) + (32 * mem[_1858]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2586 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2618 = mem[_2586]
                        require mem[_2586] <= test266151307()
                        require _2586 + mem[_2586] + 31 < _2586 + return_data.size
                        _2650 = mem[_2586 + mem[_2586]]
                        if mem[_2586 + mem[_2586]] > test266151307():
                            revert with 0, 65
                        if _2586 + ceil32(return_data.size) + ceil32(32 * mem[_2586 + mem[_2586]]) + 1 > test266151307() or ceil32(32 * mem[_2586 + mem[_2586]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2586 + ceil32(return_data.size) + ceil32(32 * mem[_2586 + mem[_2586]]) + 1
                        mem[_2586 + ceil32(return_data.size)] = _2650
                        require return_data.size >= _2618 + (32 * _2650) + 32
                        mem[_2586 + ceil32(return_data.size) + 32 len 32 * _2650] = mem[_2586 + _2618 + 32 len 32 * _2650]
                        if _2650 < 1:
                            revert with 0, 17
                        if _2650 - 1 >= _2650:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2650 - 1) + _2586 + ceil32(return_data.size) + 32]
                else:
                    _1855 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1855]:
                        revert with 0, 50
                    mem[_1855 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1855]:
                        revert with 0, 50
                    mem[_1855 + 32] = tokenAddress
                    if 2 >= mem[_1855]:
                        revert with 0, 50
                    mem[_1855 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1855 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1855 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1855 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1855 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1855 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1855 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1855 + (2 * ceil32(return_data.size)) + 292] = mem[_1855]
                        idx = 0
                        s = _1855 + 32
                        t = _1855 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1855]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1855 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1855 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1855 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1855]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1855 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1855 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2615 = mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1855 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2647 = mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1855 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[_1855 + (4 * ceil32(return_data.size)) + 128] = mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2615 + (32 * _2647) + 32
                        mem[_1855 + (4 * ceil32(return_data.size)) + 160 len 32 * _2647] = mem[_1855 + (2 * ceil32(return_data.size)) + _2615 + 160 len 32 * _2647]
                        if _2647 < 1:
                            revert with 0, 17
                        if _2647 - 1 >= _2647:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2647 - 1) + _1855 + (4 * ceil32(return_data.size)) + 160]
                    else:
                        mem[_1855 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1855 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1855 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1855 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1855 + (2 * ceil32(return_data.size)) + 292] = mem[_1855]
                        idx = 0
                        s = _1855 + 32
                        t = _1855 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1855]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1855 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1855 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1855 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1855]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1855 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1855 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2616 = mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1855 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2648 = mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1855 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[_1855 + (4 * ceil32(return_data.size)) + 128] = mem[_1855 + (2 * ceil32(return_data.size)) + mem[_1855 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2616 + (32 * _2648) + 32
                        mem[_1855 + (4 * ceil32(return_data.size)) + 160 len 32 * _2648] = mem[_1855 + (2 * ceil32(return_data.size)) + _2616 + 160 len 32 * _2648]
                        if _2648 < 1:
                            revert with 0, 17
                        if _2648 - 1 >= _2648:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2648 - 1) + _1855 + (4 * ceil32(return_data.size)) + 160]
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg3
            require ext_code.size(stor105)
            call stor105.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg3
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _946 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _954 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _946 + (32 * _954) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _954] = mem[(4 * ceil32(return_data.size)) + _946 + 224 len 32 * _954]
                if _954 < 1:
                    revert with 0, 17
                if _954 - 1 >= _954:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _954 - 1) + (6 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _954 - 1) + (6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _954 - 1) + (6 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _954 - 1) + (6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1810 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1810] == bool(mem[_1810])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1842 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1842] == mem[_1842 + 12 len 20]
                if address(arg2) == mem[_1842 + 12 len 20]:
                    _1870 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1870]:
                        revert with 0, 50
                    mem[_1870 + 32] = tokenAddress
                    if 1 >= mem[_1870]:
                        revert with 0, 50
                    mem[_1870 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1870 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1870 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1870 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1870 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1870 + ceil32(return_data.size) + 132] = arg4
                        mem[_1870 + ceil32(return_data.size) + 164] = 160
                        mem[_1870 + ceil32(return_data.size) + 260] = mem[_1870]
                        idx = 0
                        s = _1870 + 32
                        t = _1870 + ceil32(return_data.size) + 292
                        while idx < mem[_1870]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1870 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1870 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1870 + ceil32(return_data.size) + (32 * mem[_1870]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2597 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2629 = mem[_2597]
                        require mem[_2597] <= test266151307()
                        require _2597 + mem[_2597] + 31 < _2597 + return_data.size
                        _2661 = mem[_2597 + mem[_2597]]
                        if mem[_2597 + mem[_2597]] > test266151307():
                            revert with 0, 65
                        if _2597 + ceil32(return_data.size) + ceil32(32 * mem[_2597 + mem[_2597]]) + 1 > test266151307() or ceil32(32 * mem[_2597 + mem[_2597]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2597 + ceil32(return_data.size) + ceil32(32 * mem[_2597 + mem[_2597]]) + 1
                        mem[_2597 + ceil32(return_data.size)] = _2661
                        require return_data.size >= _2629 + (32 * _2661) + 32
                        mem[_2597 + ceil32(return_data.size) + 32 len 32 * _2661] = mem[_2597 + _2629 + 32 len 32 * _2661]
                        if _2661 < 1:
                            revert with 0, 17
                        if _2661 - 1 >= _2661:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2661 - 1) + _2597 + ceil32(return_data.size) + 32]
                    else:
                        mem[_1870 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1870 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1870 + ceil32(return_data.size) + 132] = arg4
                        mem[_1870 + ceil32(return_data.size) + 164] = 160
                        mem[_1870 + ceil32(return_data.size) + 260] = mem[_1870]
                        idx = 0
                        s = _1870 + 32
                        t = _1870 + ceil32(return_data.size) + 292
                        while idx < mem[_1870]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1870 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1870 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1870 + ceil32(return_data.size) + (32 * mem[_1870]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2598 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2630 = mem[_2598]
                        require mem[_2598] <= test266151307()
                        require _2598 + mem[_2598] + 31 < _2598 + return_data.size
                        _2662 = mem[_2598 + mem[_2598]]
                        if mem[_2598 + mem[_2598]] > test266151307():
                            revert with 0, 65
                        if _2598 + ceil32(return_data.size) + ceil32(32 * mem[_2598 + mem[_2598]]) + 1 > test266151307() or ceil32(32 * mem[_2598 + mem[_2598]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2598 + ceil32(return_data.size) + ceil32(32 * mem[_2598 + mem[_2598]]) + 1
                        mem[_2598 + ceil32(return_data.size)] = _2662
                        require return_data.size >= _2630 + (32 * _2662) + 32
                        mem[_2598 + ceil32(return_data.size) + 32 len 32 * _2662] = mem[_2598 + _2630 + 32 len 32 * _2662]
                        if _2662 < 1:
                            revert with 0, 17
                        if _2662 - 1 >= _2662:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2662 - 1) + _2598 + ceil32(return_data.size) + 32]
                else:
                    _1867 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1867]:
                        revert with 0, 50
                    mem[_1867 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1867]:
                        revert with 0, 50
                    mem[_1867 + 32] = tokenAddress
                    if 2 >= mem[_1867]:
                        revert with 0, 50
                    mem[_1867 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1867 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1867 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1867 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1867 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1867 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1867 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1867 + (2 * ceil32(return_data.size)) + 292] = mem[_1867]
                        idx = 0
                        s = _1867 + 32
                        t = _1867 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1867]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1867 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1867 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1867 + (2 * ceil32(return_data.size)) + (32 * mem[_1867]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2595 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2627 = mem[_2595]
                        require mem[_2595] <= test266151307()
                        require _2595 + mem[_2595] + 31 < _2595 + return_data.size
                        _2659 = mem[_2595 + mem[_2595]]
                        if mem[_2595 + mem[_2595]] > test266151307():
                            revert with 0, 65
                        if _2595 + ceil32(return_data.size) + ceil32(32 * mem[_2595 + mem[_2595]]) + 1 > test266151307() or ceil32(32 * mem[_2595 + mem[_2595]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2595 + ceil32(return_data.size) + ceil32(32 * mem[_2595 + mem[_2595]]) + 1
                        mem[_2595 + ceil32(return_data.size)] = _2659
                        require return_data.size >= _2627 + (32 * _2659) + 32
                        mem[_2595 + ceil32(return_data.size) + 32 len 32 * _2659] = mem[_2595 + _2627 + 32 len 32 * _2659]
                        if _2659 < 1:
                            revert with 0, 17
                        if _2659 - 1 >= _2659:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2659 - 1) + _2595 + ceil32(return_data.size) + 32]
                    else:
                        mem[_1867 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1867 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1867 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1867 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1867 + (2 * ceil32(return_data.size)) + 292] = mem[_1867]
                        idx = 0
                        s = _1867 + 32
                        t = _1867 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1867]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1867 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1867 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1867 + (2 * ceil32(return_data.size)) + (32 * mem[_1867]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2596 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2628 = mem[_2596]
                        require mem[_2596] <= test266151307()
                        require _2596 + mem[_2596] + 31 < _2596 + return_data.size
                        _2660 = mem[_2596 + mem[_2596]]
                        if mem[_2596 + mem[_2596]] > test266151307():
                            revert with 0, 65
                        if _2596 + ceil32(return_data.size) + ceil32(32 * mem[_2596 + mem[_2596]]) + 1 > test266151307() or ceil32(32 * mem[_2596 + mem[_2596]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2596 + ceil32(return_data.size) + ceil32(32 * mem[_2596 + mem[_2596]]) + 1
                        mem[_2596 + ceil32(return_data.size)] = _2660
                        require return_data.size >= _2628 + (32 * _2660) + 32
                        mem[_2596 + ceil32(return_data.size) + 32 len 32 * _2660] = mem[_2596 + _2628 + 32 len 32 * _2660]
                        if _2660 < 1:
                            revert with 0, 17
                        if _2660 - 1 >= _2660:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2660 - 1) + _2596 + ceil32(return_data.size) + 32]
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(6 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _945 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _953 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _945 + (32 * _953) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _953] = mem[(6 * ceil32(return_data.size)) + _945 + 256 len 32 * _953]
                if _953 < 1:
                    revert with 0, 17
                if _953 - 1 >= _953:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _953 - 1) + (7 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _953 - 1) + (7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _953 - 1) + (7 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _953 - 1) + (7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1809 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1809] == bool(mem[_1809])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1841 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1841] == mem[_1841 + 12 len 20]
                if address(arg2) == mem[_1841 + 12 len 20]:
                    _1866 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1866]:
                        revert with 0, 50
                    mem[_1866 + 32] = tokenAddress
                    if 1 >= mem[_1866]:
                        revert with 0, 50
                    mem[_1866 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1866 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1866 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1866 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1866 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1866 + ceil32(return_data.size) + 132] = arg4
                        mem[_1866 + ceil32(return_data.size) + 164] = 160
                        mem[_1866 + ceil32(return_data.size) + 260] = mem[_1866]
                        idx = 0
                        s = _1866 + 32
                        t = _1866 + ceil32(return_data.size) + 292
                        while idx < mem[_1866]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1866 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1866 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1866 + ceil32(return_data.size) + 260 len (32 * mem[_1866]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1866 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1866 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2625 = mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1866 + ceil32(return_data.size) + return_data.size + 96
                        _2657 = mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1866 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1866 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                        mem[_1866 + (2 * ceil32(return_data.size)) + 96] = mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2625 + (32 * _2657) + 32
                        mem[_1866 + (2 * ceil32(return_data.size)) + 128 len 32 * _2657] = mem[_1866 + ceil32(return_data.size) + _2625 + 128 len 32 * _2657]
                        if _2657 < 1:
                            revert with 0, 17
                        if _2657 - 1 >= _2657:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2657 - 1) + _1866 + (2 * ceil32(return_data.size)) + 128]
                    else:
                        mem[_1866 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1866 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1866 + ceil32(return_data.size) + 132] = arg4
                        mem[_1866 + ceil32(return_data.size) + 164] = 160
                        mem[_1866 + ceil32(return_data.size) + 260] = mem[_1866]
                        idx = 0
                        s = _1866 + 32
                        t = _1866 + ceil32(return_data.size) + 292
                        while idx < mem[_1866]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1866 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1866 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1866 + ceil32(return_data.size) + 260 len (32 * mem[_1866]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1866 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1866 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2626 = mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1866 + ceil32(return_data.size) + return_data.size + 96
                        _2658 = mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1866 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1866 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                        mem[_1866 + (2 * ceil32(return_data.size)) + 96] = mem[_1866 + ceil32(return_data.size) + mem[_1866 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2626 + (32 * _2658) + 32
                        mem[_1866 + (2 * ceil32(return_data.size)) + 128 len 32 * _2658] = mem[_1866 + ceil32(return_data.size) + _2626 + 128 len 32 * _2658]
                        if _2658 < 1:
                            revert with 0, 17
                        if _2658 - 1 >= _2658:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2658 - 1) + _1866 + (2 * ceil32(return_data.size)) + 128]
                else:
                    _1863 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1863]:
                        revert with 0, 50
                    mem[_1863 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1863]:
                        revert with 0, 50
                    mem[_1863 + 32] = tokenAddress
                    if 2 >= mem[_1863]:
                        revert with 0, 50
                    mem[_1863 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1863 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1863 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1863 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1863 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1863 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1863 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1863 + (2 * ceil32(return_data.size)) + 292] = mem[_1863]
                        idx = 0
                        s = _1863 + 32
                        t = _1863 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1863]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1863 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1863 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1863 + (2 * ceil32(return_data.size)) + (32 * mem[_1863]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2591 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2623 = mem[_2591]
                        require mem[_2591] <= test266151307()
                        require _2591 + mem[_2591] + 31 < _2591 + return_data.size
                        _2655 = mem[_2591 + mem[_2591]]
                        if mem[_2591 + mem[_2591]] > test266151307():
                            revert with 0, 65
                        if _2591 + ceil32(return_data.size) + ceil32(32 * mem[_2591 + mem[_2591]]) + 1 > test266151307() or ceil32(32 * mem[_2591 + mem[_2591]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2591 + ceil32(return_data.size) + ceil32(32 * mem[_2591 + mem[_2591]]) + 1
                        mem[_2591 + ceil32(return_data.size)] = _2655
                        require return_data.size >= _2623 + (32 * _2655) + 32
                        mem[_2591 + ceil32(return_data.size) + 32 len 32 * _2655] = mem[_2591 + _2623 + 32 len 32 * _2655]
                        if _2655 < 1:
                            revert with 0, 17
                        if _2655 - 1 >= _2655:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2655 - 1) + _2591 + ceil32(return_data.size) + 32]
                    else:
                        mem[_1863 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1863 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1863 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1863 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1863 + (2 * ceil32(return_data.size)) + 292] = mem[_1863]
                        idx = 0
                        s = _1863 + 32
                        t = _1863 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1863]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1863 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1863 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1863 + (2 * ceil32(return_data.size)) + (32 * mem[_1863]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2592 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2624 = mem[_2592]
                        require mem[_2592] <= test266151307()
                        require _2592 + mem[_2592] + 31 < _2592 + return_data.size
                        _2656 = mem[_2592 + mem[_2592]]
                        if mem[_2592 + mem[_2592]] > test266151307():
                            revert with 0, 65
                        if _2592 + ceil32(return_data.size) + ceil32(32 * mem[_2592 + mem[_2592]]) + 1 > test266151307() or ceil32(32 * mem[_2592 + mem[_2592]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2592 + ceil32(return_data.size) + ceil32(32 * mem[_2592 + mem[_2592]]) + 1
                        mem[_2592 + ceil32(return_data.size)] = _2656
                        require return_data.size >= _2624 + (32 * _2656) + 32
                        mem[_2592 + ceil32(return_data.size) + 32 len 32 * _2656] = mem[_2592 + _2624 + 32 len 32 * _2656]
                        if _2656 < 1:
                            revert with 0, 17
                        if _2656 - 1 >= _2656:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2656 - 1) + _2592 + ceil32(return_data.size) + 32]
    else:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(stor105)
        staticcall stor105.allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg3:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _948 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _956 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _948 + (32 * _956) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _956] = mem[(2 * ceil32(return_data.size)) + _948 + 224 len 32 * _956]
                if _956 < 1:
                    revert with 0, 17
                if _956 - 1 >= _956:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _956 - 1) + (4 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _956 - 1) + (4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _956 - 1) + (4 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _956 - 1) + (4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1812 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1812] == bool(mem[_1812])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1844 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1844] == mem[_1844 + 12 len 20]
                if address(arg2) == mem[_1844 + 12 len 20]:
                    _1878 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1878]:
                        revert with 0, 50
                    mem[_1878 + 32] = tokenAddress
                    if 1 >= mem[_1878]:
                        revert with 0, 50
                    mem[_1878 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1878 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1878 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1878 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1878 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1878 + ceil32(return_data.size) + 132] = arg4
                        mem[_1878 + ceil32(return_data.size) + 164] = 160
                        mem[_1878 + ceil32(return_data.size) + 260] = mem[_1878]
                        idx = 0
                        s = _1878 + 32
                        t = _1878 + ceil32(return_data.size) + 292
                        while idx < mem[_1878]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1878 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1878 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1878 + ceil32(return_data.size) + 260 len (32 * mem[_1878]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1878 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1878 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2637 = mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1878 + ceil32(return_data.size) + return_data.size + 96
                        _2669 = mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1878 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[_1878 + (2 * ceil32(return_data.size)) + 96] = mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2637 + (32 * _2669) + 32
                        mem[_1878 + (2 * ceil32(return_data.size)) + 128 len 32 * _2669] = mem[_1878 + ceil32(return_data.size) + _2637 + 128 len 32 * _2669]
                        if _2669 < 1:
                            revert with 0, 17
                        if _2669 - 1 >= _2669:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2669 - 1) + _1878 + (2 * ceil32(return_data.size)) + 128]
                    else:
                        mem[_1878 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1878 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1878 + ceil32(return_data.size) + 132] = arg4
                        mem[_1878 + ceil32(return_data.size) + 164] = 160
                        mem[_1878 + ceil32(return_data.size) + 260] = mem[_1878]
                        idx = 0
                        s = _1878 + 32
                        t = _1878 + ceil32(return_data.size) + 292
                        while idx < mem[_1878]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1878 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1878 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1878 + ceil32(return_data.size) + 260 len (32 * mem[_1878]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1878 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1878 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2638 = mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1878 + ceil32(return_data.size) + return_data.size + 96
                        _2670 = mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1878 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[_1878 + (2 * ceil32(return_data.size)) + 96] = mem[_1878 + ceil32(return_data.size) + mem[_1878 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2638 + (32 * _2670) + 32
                        mem[_1878 + (2 * ceil32(return_data.size)) + 128 len 32 * _2670] = mem[_1878 + ceil32(return_data.size) + _2638 + 128 len 32 * _2670]
                        if _2670 < 1:
                            revert with 0, 17
                        if _2670 - 1 >= _2670:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2670 - 1) + _1878 + (2 * ceil32(return_data.size)) + 128]
                else:
                    _1875 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1875]:
                        revert with 0, 50
                    mem[_1875 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1875]:
                        revert with 0, 50
                    mem[_1875 + 32] = tokenAddress
                    if 2 >= mem[_1875]:
                        revert with 0, 50
                    mem[_1875 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1875 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1875 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1875 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1875 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1875 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1875 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1875 + (2 * ceil32(return_data.size)) + 292] = mem[_1875]
                        idx = 0
                        s = _1875 + 32
                        t = _1875 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1875]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1875 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1875 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1875 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1875]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1875 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1875 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2635 = mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1875 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2667 = mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1875 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1875 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1875 + (4 * ceil32(return_data.size)) + 128] = mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2635 + (32 * _2667) + 32
                        mem[_1875 + (4 * ceil32(return_data.size)) + 160 len 32 * _2667] = mem[_1875 + (2 * ceil32(return_data.size)) + _2635 + 160 len 32 * _2667]
                        if _2667 < 1:
                            revert with 0, 17
                        if _2667 - 1 >= _2667:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2667 - 1) + _1875 + (4 * ceil32(return_data.size)) + 160]
                    else:
                        mem[_1875 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1875 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1875 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1875 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1875 + (2 * ceil32(return_data.size)) + 292] = mem[_1875]
                        idx = 0
                        s = _1875 + 32
                        t = _1875 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1875]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1875 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1875 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1875 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1875]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1875 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1875 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2636 = mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1875 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2668 = mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1875 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1875 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1875 + (4 * ceil32(return_data.size)) + 128] = mem[_1875 + (2 * ceil32(return_data.size)) + mem[_1875 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2636 + (32 * _2668) + 32
                        mem[_1875 + (4 * ceil32(return_data.size)) + 160 len 32 * _2668] = mem[_1875 + (2 * ceil32(return_data.size)) + _2636 + 160 len 32 * _2668]
                        if _2668 < 1:
                            revert with 0, 17
                        if _2668 - 1 >= _2668:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2668 - 1) + _1875 + (4 * ceil32(return_data.size)) + 160]
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _947 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _955 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _947 + (32 * _955) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _955] = mem[(4 * ceil32(return_data.size)) + _947 + 256 len 32 * _955]
                if _955 < 1:
                    revert with 0, 17
                if _955 - 1 >= _955:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _955 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _955 - 1) + (6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _955 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _955 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1811 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1811] == bool(mem[_1811])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1843 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1843] == mem[_1843 + 12 len 20]
                if address(arg2) == mem[_1843 + 12 len 20]:
                    _1874 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1874]:
                        revert with 0, 50
                    mem[_1874 + 32] = tokenAddress
                    if 1 >= mem[_1874]:
                        revert with 0, 50
                    mem[_1874 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1874 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1874 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1874 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1874 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1874 + ceil32(return_data.size) + 132] = arg4
                        mem[_1874 + ceil32(return_data.size) + 164] = 160
                        mem[_1874 + ceil32(return_data.size) + 260] = mem[_1874]
                        idx = 0
                        s = _1874 + 32
                        t = _1874 + ceil32(return_data.size) + 292
                        while idx < mem[_1874]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1874 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1874 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1874 + ceil32(return_data.size) + 260 len (32 * mem[_1874]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1874 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1874 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2633 = mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1874 + ceil32(return_data.size) + return_data.size + 96
                        _2665 = mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1874 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1874 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                        mem[_1874 + (2 * ceil32(return_data.size)) + 96] = mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2633 + (32 * _2665) + 32
                        mem[_1874 + (2 * ceil32(return_data.size)) + 128 len 32 * _2665] = mem[_1874 + ceil32(return_data.size) + _2633 + 128 len 32 * _2665]
                        if _2665 < 1:
                            revert with 0, 17
                        if _2665 - 1 >= _2665:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2665 - 1) + _1874 + (2 * ceil32(return_data.size)) + 128]
                    else:
                        mem[_1874 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1874 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1874 + ceil32(return_data.size) + 132] = arg4
                        mem[_1874 + ceil32(return_data.size) + 164] = 160
                        mem[_1874 + ceil32(return_data.size) + 260] = mem[_1874]
                        idx = 0
                        s = _1874 + 32
                        t = _1874 + ceil32(return_data.size) + 292
                        while idx < mem[_1874]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1874 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1874 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1874 + ceil32(return_data.size) + 260 len (32 * mem[_1874]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1874 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1874 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2634 = mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1874 + ceil32(return_data.size) + return_data.size + 96
                        _2666 = mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1874 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1874 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                        mem[_1874 + (2 * ceil32(return_data.size)) + 96] = mem[_1874 + ceil32(return_data.size) + mem[_1874 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2634 + (32 * _2666) + 32
                        mem[_1874 + (2 * ceil32(return_data.size)) + 128 len 32 * _2666] = mem[_1874 + ceil32(return_data.size) + _2634 + 128 len 32 * _2666]
                        if _2666 < 1:
                            revert with 0, 17
                        if _2666 - 1 >= _2666:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2666 - 1) + _1874 + (2 * ceil32(return_data.size)) + 128]
                else:
                    _1871 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1871]:
                        revert with 0, 50
                    mem[_1871 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1871]:
                        revert with 0, 50
                    mem[_1871 + 32] = tokenAddress
                    if 2 >= mem[_1871]:
                        revert with 0, 50
                    mem[_1871 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1871 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1871 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1871 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1871 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1871 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1871 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1871 + (2 * ceil32(return_data.size)) + 292] = mem[_1871]
                        idx = 0
                        s = _1871 + 32
                        t = _1871 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1871]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1871 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1871 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1871 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1871]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1871 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1871 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2631 = mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1871 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2663 = mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1871 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1871 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1871 + (4 * ceil32(return_data.size)) + 128] = mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2631 + (32 * _2663) + 32
                        mem[_1871 + (4 * ceil32(return_data.size)) + 160 len 32 * _2663] = mem[_1871 + (2 * ceil32(return_data.size)) + _2631 + 160 len 32 * _2663]
                        if _2663 < 1:
                            revert with 0, 17
                        if _2663 - 1 >= _2663:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2663 - 1) + _1871 + (4 * ceil32(return_data.size)) + 160]
                    else:
                        mem[_1871 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1871 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1871 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1871 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1871 + (2 * ceil32(return_data.size)) + 292] = mem[_1871]
                        idx = 0
                        s = _1871 + 32
                        t = _1871 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1871]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1871 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1871 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1871 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1871]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1871 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1871 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2632 = mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1871 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2664 = mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1871 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1871 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1871 + (4 * ceil32(return_data.size)) + 128] = mem[_1871 + (2 * ceil32(return_data.size)) + mem[_1871 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2632 + (32 * _2664) + 32
                        mem[_1871 + (4 * ceil32(return_data.size)) + 160 len 32 * _2664] = mem[_1871 + (2 * ceil32(return_data.size)) + _2632 + 160 len 32 * _2664]
                        if _2664 < 1:
                            revert with 0, 17
                        if _2664 - 1 >= _2664:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2664 - 1) + _1871 + (4 * ceil32(return_data.size)) + 160]
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg3
            require ext_code.size(stor105)
            call stor105.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg3
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _950 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _958 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _950 + (32 * _958) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _958] = mem[(4 * ceil32(return_data.size)) + _950 + 224 len 32 * _958]
                if _958 < 1:
                    revert with 0, 17
                if _958 - 1 >= _958:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _958 - 1) + (6 * ceil32(return_data.size)) + 224] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _958 - 1) + (6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _958 - 1) + (6 * ceil32(return_data.size)) + 224]) - (sub_fd53fce0 * mem[(32 * _958 - 1) + (6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1814 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1814] == bool(mem[_1814])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1846 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1846] == mem[_1846 + 12 len 20]
                if address(arg2) == mem[_1846 + 12 len 20]:
                    _1886 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1886]:
                        revert with 0, 50
                    mem[_1886 + 32] = tokenAddress
                    if 1 >= mem[_1886]:
                        revert with 0, 50
                    mem[_1886 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1886 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1886 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1886 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1886 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1886 + ceil32(return_data.size) + 132] = arg4
                        mem[_1886 + ceil32(return_data.size) + 164] = 160
                        mem[_1886 + ceil32(return_data.size) + 260] = mem[_1886]
                        idx = 0
                        s = _1886 + 32
                        t = _1886 + ceil32(return_data.size) + 292
                        while idx < mem[_1886]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1886 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1886 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1886 + ceil32(return_data.size) + 260 len (32 * mem[_1886]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1886 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1886 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2645 = mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1886 + ceil32(return_data.size) + return_data.size + 96
                        _2677 = mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1886 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1886 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                        mem[_1886 + (2 * ceil32(return_data.size)) + 96] = mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2645 + (32 * _2677) + 32
                        mem[_1886 + (2 * ceil32(return_data.size)) + 128 len 32 * _2677] = mem[_1886 + ceil32(return_data.size) + _2645 + 128 len 32 * _2677]
                        if _2677 < 1:
                            revert with 0, 17
                        if _2677 - 1 >= _2677:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2677 - 1) + _1886 + (2 * ceil32(return_data.size)) + 128]
                    else:
                        mem[_1886 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1886 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1886 + ceil32(return_data.size) + 132] = arg4
                        mem[_1886 + ceil32(return_data.size) + 164] = 160
                        mem[_1886 + ceil32(return_data.size) + 260] = mem[_1886]
                        idx = 0
                        s = _1886 + 32
                        t = _1886 + ceil32(return_data.size) + 292
                        while idx < mem[_1886]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1886 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1886 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1886 + ceil32(return_data.size) + 260 len (32 * mem[_1886]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1886 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1886 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2646 = mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _1886 + ceil32(return_data.size) + return_data.size + 96
                        _2678 = mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        if mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _1886 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1886 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                        mem[_1886 + (2 * ceil32(return_data.size)) + 96] = mem[_1886 + ceil32(return_data.size) + mem[_1886 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                        require return_data.size >= _2646 + (32 * _2678) + 32
                        mem[_1886 + (2 * ceil32(return_data.size)) + 128 len 32 * _2678] = mem[_1886 + ceil32(return_data.size) + _2646 + 128 len 32 * _2678]
                        if _2678 < 1:
                            revert with 0, 17
                        if _2678 - 1 >= _2678:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2678 - 1) + _1886 + (2 * ceil32(return_data.size)) + 128]
                else:
                    _1883 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1883]:
                        revert with 0, 50
                    mem[_1883 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1883]:
                        revert with 0, 50
                    mem[_1883 + 32] = tokenAddress
                    if 2 >= mem[_1883]:
                        revert with 0, 50
                    mem[_1883 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1883 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1883 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1883 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1883 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1883 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1883 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1883 + (2 * ceil32(return_data.size)) + 292] = mem[_1883]
                        idx = 0
                        s = _1883 + 32
                        t = _1883 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1883]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1883 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1883 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1883 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1883]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1883 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1883 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2643 = mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1883 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2675 = mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1883 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1883 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1883 + (4 * ceil32(return_data.size)) + 128] = mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2643 + (32 * _2675) + 32
                        mem[_1883 + (4 * ceil32(return_data.size)) + 160 len 32 * _2675] = mem[_1883 + (2 * ceil32(return_data.size)) + _2643 + 160 len 32 * _2675]
                        if _2675 < 1:
                            revert with 0, 17
                        if _2675 - 1 >= _2675:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2675 - 1) + _1883 + (4 * ceil32(return_data.size)) + 160]
                    else:
                        mem[_1883 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1883 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1883 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1883 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1883 + (2 * ceil32(return_data.size)) + 292] = mem[_1883]
                        idx = 0
                        s = _1883 + 32
                        t = _1883 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1883]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1883 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1883 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1883 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1883]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1883 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1883 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2644 = mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1883 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2676 = mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1883 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1883 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1883 + (4 * ceil32(return_data.size)) + 128] = mem[_1883 + (2 * ceil32(return_data.size)) + mem[_1883 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2644 + (32 * _2676) + 32
                        mem[_1883 + (4 * ceil32(return_data.size)) + 160 len 32 * _2676] = mem[_1883 + (2 * ceil32(return_data.size)) + _2644 + 160 len 32 * _2676]
                        if _2676 < 1:
                            revert with 0, 17
                        if _2676 - 1 >= _2676:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2676 - 1) + _1883 + (4 * ceil32(return_data.size)) + 160]
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(6 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _949 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _957 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _949 + (32 * _957) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _957] = mem[(6 * ceil32(return_data.size)) + _949 + 256 len 32 * _957]
                if _957 < 1:
                    revert with 0, 17
                if _957 - 1 >= _957:
                    revert with 0, 50
                if 100 * 10^6 < sub_fd53fce0:
                    revert with 0, 17
                if mem[(32 * _957 - 1) + (7 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _957 - 1) + (7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(32 * _957 - 1) + (7 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _957 - 1) + (7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                if arg3 and sub_fd53fce0 > -1 / arg3:
                    revert with 0, 17
                mem[mem[64] + 4] = sub_11eb47dcAddress
                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                require ext_code.size(stor105)
                call stor105.transfer(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1813 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1813] == bool(mem[_1813])
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1845 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1845] == mem[_1845 + 12 len 20]
                if address(arg2) == mem[_1845 + 12 len 20]:
                    _1882 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_1882]:
                        revert with 0, 50
                    mem[_1882 + 32] = tokenAddress
                    if 1 >= mem[_1882]:
                        revert with 0, 50
                    mem[_1882 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1882 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1882 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1882 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1882 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1882 + ceil32(return_data.size) + 132] = arg4
                        mem[_1882 + ceil32(return_data.size) + 164] = 160
                        mem[_1882 + ceil32(return_data.size) + 260] = mem[_1882]
                        idx = 0
                        s = _1882 + 32
                        t = _1882 + ceil32(return_data.size) + 292
                        while idx < mem[_1882]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1882 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1882 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1882 + ceil32(return_data.size) + (32 * mem[_1882]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2609 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2641 = mem[_2609]
                        require mem[_2609] <= test266151307()
                        require _2609 + mem[_2609] + 31 < _2609 + return_data.size
                        _2673 = mem[_2609 + mem[_2609]]
                        if mem[_2609 + mem[_2609]] > test266151307():
                            revert with 0, 65
                        if _2609 + ceil32(return_data.size) + ceil32(32 * mem[_2609 + mem[_2609]]) + 1 > test266151307() or ceil32(32 * mem[_2609 + mem[_2609]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2609 + ceil32(return_data.size) + ceil32(32 * mem[_2609 + mem[_2609]]) + 1
                        mem[_2609 + ceil32(return_data.size)] = _2673
                        require return_data.size >= _2641 + (32 * _2673) + 32
                        mem[_2609 + ceil32(return_data.size) + 32 len 32 * _2673] = mem[_2609 + _2641 + 32 len 32 * _2673]
                        if _2673 < 1:
                            revert with 0, 17
                        if _2673 - 1 >= _2673:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2673 - 1) + _2609 + ceil32(return_data.size) + 32]
                    else:
                        mem[_1882 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1882 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1882 + ceil32(return_data.size) + 132] = arg4
                        mem[_1882 + ceil32(return_data.size) + 164] = 160
                        mem[_1882 + ceil32(return_data.size) + 260] = mem[_1882]
                        idx = 0
                        s = _1882 + 32
                        t = _1882 + ceil32(return_data.size) + 292
                        while idx < mem[_1882]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1882 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_1882 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1882 + ceil32(return_data.size) + (32 * mem[_1882]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2610 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2642 = mem[_2610]
                        require mem[_2610] <= test266151307()
                        require _2610 + mem[_2610] + 31 < _2610 + return_data.size
                        _2674 = mem[_2610 + mem[_2610]]
                        if mem[_2610 + mem[_2610]] > test266151307():
                            revert with 0, 65
                        if _2610 + ceil32(return_data.size) + ceil32(32 * mem[_2610 + mem[_2610]]) + 1 > test266151307() or ceil32(32 * mem[_2610 + mem[_2610]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2610 + ceil32(return_data.size) + ceil32(32 * mem[_2610 + mem[_2610]]) + 1
                        mem[_2610 + ceil32(return_data.size)] = _2674
                        require return_data.size >= _2642 + (32 * _2674) + 32
                        mem[_2610 + ceil32(return_data.size) + 32 len 32 * _2674] = mem[_2610 + _2642 + 32 len 32 * _2674]
                        if _2674 < 1:
                            revert with 0, 17
                        if _2674 - 1 >= _2674:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2674 - 1) + _2610 + ceil32(return_data.size) + 32]
                else:
                    _1879 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_1879]:
                        revert with 0, 50
                    mem[_1879 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_1879]:
                        revert with 0, 50
                    mem[_1879 + 32] = tokenAddress
                    if 2 >= mem[_1879]:
                        revert with 0, 50
                    mem[_1879 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_1879 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1879 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                        revert with 0, 17
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_1879 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1879 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1879 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1879 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1879 + (2 * ceil32(return_data.size)) + 292] = mem[_1879]
                        idx = 0
                        s = _1879 + 32
                        t = _1879 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1879]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1879 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1879 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1879 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1879]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1879 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1879 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2639 = mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1879 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2671 = mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1879 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1879 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1879 + (4 * ceil32(return_data.size)) + 128] = mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2639 + (32 * _2671) + 32
                        mem[_1879 + (4 * ceil32(return_data.size)) + 160 len 32 * _2671] = mem[_1879 + (2 * ceil32(return_data.size)) + _2639 + 160 len 32 * _2671]
                        if _2671 < 1:
                            revert with 0, 17
                        if _2671 - 1 >= _2671:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2671 - 1) + _1879 + (4 * ceil32(return_data.size)) + 160]
                    else:
                        mem[_1879 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                        mem[_1879 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                        mem[_1879 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_1879 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_1879 + (2 * ceil32(return_data.size)) + 292] = mem[_1879]
                        idx = 0
                        s = _1879 + 32
                        t = _1879 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_1879]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_1879 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_1879 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_1879 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_1879]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1879 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1879 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _2640 = mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                        require mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                        require _1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _1879 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _2672 = mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        if mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _1879 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _1879 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                        mem[_1879 + (4 * ceil32(return_data.size)) + 128] = mem[_1879 + (2 * ceil32(return_data.size)) + mem[_1879 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                        require return_data.size >= _2640 + (32 * _2672) + 32
                        mem[_1879 + (4 * ceil32(return_data.size)) + 160 len 32 * _2672] = mem[_1879 + (2 * ceil32(return_data.size)) + _2640 + 160 len 32 * _2672]
                        if _2672 < 1:
                            revert with 0, 17
                        if _2672 - 1 >= _2672:
                            revert with 0, 50
                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _2672 - 1) + _1879 + (4 * ceil32(return_data.size)) + 160]
}

function sub_80be66cf(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if msg.sender == tokenAddress:
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(stor105)
        staticcall stor105.allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg4:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1128 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1136 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _1128 + (32 * _1136) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _1136] = mem[(2 * ceil32(return_data.size)) + _1128 + 224 len 32 * _1136]
                if 0 >= _1136:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(4 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2168 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2168] == mem[_2168 + 12 len 20]
                if address(arg2) == mem[_2168 + 12 len 20]:
                    _2190 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2190]:
                        revert with 0, 50
                    mem[_2190 + 32] = tokenAddress
                    if 1 >= mem[_2190]:
                        revert with 0, 50
                    mem[_2190 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2190 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2190 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2190 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2190 + ceil32(return_data.size) + 100] = arg3
                        mem[_2190 + ceil32(return_data.size) + 132] = arg4
                        mem[_2190 + ceil32(return_data.size) + 164] = 160
                        mem[_2190 + ceil32(return_data.size) + 260] = mem[_2190]
                        idx = 0
                        s = _2190 + 32
                        t = _2190 + ceil32(return_data.size) + 292
                        while idx < mem[_2190]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2190 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2190 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2190 + ceil32(return_data.size) + 260 len (32 * mem[_2190]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2190 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2190 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3173 = mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2190 + ceil32(return_data.size) + return_data.size + 96
                        _3205 = mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2190 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2190 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2190 + (2 * ceil32(return_data.size)) + 96] = mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3173 + (32 * _3205) + 32
                        mem[_2190 + (2 * ceil32(return_data.size)) + 128 len 32 * _3205] = mem[_2190 + ceil32(return_data.size) + _3173 + 128 len 32 * _3205]
                        if 0 >= _3205:
                            revert with 0, 50
                        _3813 = mem[_2190 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2190 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2190 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3813 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3813 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3909 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3909] == bool(mem[_3909])
                        if arg4 < _3813:
                            revert with 0, 17
                        if arg4 - _3813 < _3813 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3813 - (_3813 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3813 - (_3813 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4037 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4037] == bool(mem[_4037])
                        emit 0xfedb587d: tokenAddress, _3813, address(arg2), arg3
                    else:
                        mem[_2190 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2190 + ceil32(return_data.size) + 100] = arg3
                        mem[_2190 + ceil32(return_data.size) + 132] = arg4
                        mem[_2190 + ceil32(return_data.size) + 164] = 160
                        mem[_2190 + ceil32(return_data.size) + 260] = mem[_2190]
                        idx = 0
                        s = _2190 + 32
                        t = _2190 + ceil32(return_data.size) + 292
                        while idx < mem[_2190]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2190 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2190 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2190 + ceil32(return_data.size) + 260 len (32 * mem[_2190]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2190 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2190 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3174 = mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2190 + ceil32(return_data.size) + return_data.size + 96
                        _3206 = mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2190 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2190 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2190 + (2 * ceil32(return_data.size)) + 96] = mem[_2190 + ceil32(return_data.size) + mem[_2190 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3174 + (32 * _3206) + 32
                        mem[_2190 + (2 * ceil32(return_data.size)) + 128 len 32 * _3206] = mem[_2190 + ceil32(return_data.size) + _3174 + 128 len 32 * _3206]
                        if 0 >= _3206:
                            revert with 0, 50
                        _3814 = mem[_2190 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2190 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2190 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3814 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3814 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3910 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3910] == bool(mem[_3910])
                        if arg4 < _3814:
                            revert with 0, 17
                        if arg4 - _3814 < _3814 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3814 - (_3814 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3814 - (_3814 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4038 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4038] == bool(mem[_4038])
                        emit 0xfedb587d: tokenAddress, _3814, address(arg2), arg3
                else:
                    _2187 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2187]:
                        revert with 0, 50
                    mem[_2187 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2187]:
                        revert with 0, 50
                    mem[_2187 + 32] = tokenAddress
                    if 2 >= mem[_2187]:
                        revert with 0, 50
                    mem[_2187 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2187 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2187 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2187 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2187 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2187 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2187 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2187 + (2 * ceil32(return_data.size)) + 292] = mem[_2187]
                        idx = 0
                        s = _2187 + 32
                        t = _2187 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2187]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2187 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2187 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2187 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2187]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2187 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2187 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3171 = mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2187 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3203 = mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2187 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2187 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2187 + (4 * ceil32(return_data.size)) + 128] = mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3171 + (32 * _3203) + 32
                        mem[_2187 + (4 * ceil32(return_data.size)) + 160 len 32 * _3203] = mem[_2187 + (2 * ceil32(return_data.size)) + _3171 + 160 len 32 * _3203]
                        if 0 >= _3203:
                            revert with 0, 50
                        _3811 = mem[_2187 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2187 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2187 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3811 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3811 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3907 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3907] == bool(mem[_3907])
                        if arg4 < _3811:
                            revert with 0, 17
                        if arg4 - _3811 < _3811 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3811 - (_3811 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3811 - (_3811 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4035 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4035] == bool(mem[_4035])
                        emit 0xfedb587d: tokenAddress, _3811, address(arg2), arg3
                    else:
                        mem[_2187 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2187 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2187 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2187 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2187 + (2 * ceil32(return_data.size)) + 292] = mem[_2187]
                        idx = 0
                        s = _2187 + 32
                        t = _2187 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2187]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2187 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2187 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2187 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2187]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2187 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2187 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3172 = mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2187 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3204 = mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2187 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2187 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2187 + (4 * ceil32(return_data.size)) + 128] = mem[_2187 + (2 * ceil32(return_data.size)) + mem[_2187 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3172 + (32 * _3204) + 32
                        mem[_2187 + (4 * ceil32(return_data.size)) + 160 len 32 * _3204] = mem[_2187 + (2 * ceil32(return_data.size)) + _3172 + 160 len 32 * _3204]
                        if 0 >= _3204:
                            revert with 0, 50
                        _3812 = mem[_2187 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2187 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2187 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3812 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3812 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3908 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3908] == bool(mem[_3908])
                        if arg4 < _3812:
                            revert with 0, 17
                        if arg4 - _3812 < _3812 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3812 - (_3812 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3812 - (_3812 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4036 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4036] == bool(mem[_4036])
                        emit 0xfedb587d: tokenAddress, _3812, address(arg2), arg3
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _1127 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _1135 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _1127 + (32 * _1135) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1135] = mem[(4 * ceil32(return_data.size)) + _1127 + 256 len 32 * _1135]
                if 0 >= _1135:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2167 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2167] == mem[_2167 + 12 len 20]
                if address(arg2) == mem[_2167 + 12 len 20]:
                    _2186 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2186]:
                        revert with 0, 50
                    mem[_2186 + 32] = tokenAddress
                    if 1 >= mem[_2186]:
                        revert with 0, 50
                    mem[_2186 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2186 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2186 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2186 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2186 + ceil32(return_data.size) + 100] = arg3
                        mem[_2186 + ceil32(return_data.size) + 132] = arg4
                        mem[_2186 + ceil32(return_data.size) + 164] = 160
                        mem[_2186 + ceil32(return_data.size) + 260] = mem[_2186]
                        idx = 0
                        s = _2186 + 32
                        t = _2186 + ceil32(return_data.size) + 292
                        while idx < mem[_2186]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2186 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2186 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2186 + ceil32(return_data.size) + 260 len (32 * mem[_2186]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2186 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2186 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3169 = mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2186 + ceil32(return_data.size) + return_data.size + 96
                        _3201 = mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2186 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2186 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2186 + (2 * ceil32(return_data.size)) + 96] = _3201
                        require return_data.size >= _3169 + (32 * _3201) + 32
                        mem[_2186 + (2 * ceil32(return_data.size)) + 128 len 32 * _3201] = mem[_2186 + ceil32(return_data.size) + _3169 + 128 len 32 * _3201]
                        if 0 >= _3201:
                            revert with 0, 50
                        _3809 = mem[_2186 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2186 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2186 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3809 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3809 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3905 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3905] == bool(mem[_3905])
                        if arg4 < _3809:
                            revert with 0, 17
                        if arg4 - _3809 < _3809 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3809 - (_3809 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3809 - (_3809 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4033 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4033] == bool(mem[_4033])
                        emit 0xfedb587d: tokenAddress, _3809, address(arg2), arg3
                    else:
                        mem[_2186 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2186 + ceil32(return_data.size) + 100] = arg3
                        mem[_2186 + ceil32(return_data.size) + 132] = arg4
                        mem[_2186 + ceil32(return_data.size) + 164] = 160
                        mem[_2186 + ceil32(return_data.size) + 260] = mem[_2186]
                        idx = 0
                        s = _2186 + 32
                        t = _2186 + ceil32(return_data.size) + 292
                        while idx < mem[_2186]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2186 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2186 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2186 + ceil32(return_data.size) + 260 len (32 * mem[_2186]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2186 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2186 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3170 = mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2186 + ceil32(return_data.size) + return_data.size + 96
                        _3202 = mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2186 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2186 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2186 + ceil32(return_data.size) + mem[_2186 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2186 + (2 * ceil32(return_data.size)) + 96] = _3202
                        require return_data.size >= _3170 + (32 * _3202) + 32
                        mem[_2186 + (2 * ceil32(return_data.size)) + 128 len 32 * _3202] = mem[_2186 + ceil32(return_data.size) + _3170 + 128 len 32 * _3202]
                        if 0 >= _3202:
                            revert with 0, 50
                        _3810 = mem[_2186 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2186 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2186 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3810 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3810 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3906 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3906] == bool(mem[_3906])
                        if arg4 < _3810:
                            revert with 0, 17
                        if arg4 - _3810 < _3810 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3810 - (_3810 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3810 - (_3810 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4034 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4034] == bool(mem[_4034])
                        emit 0xfedb587d: tokenAddress, _3810, address(arg2), arg3
                else:
                    _2183 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2183]:
                        revert with 0, 50
                    mem[_2183 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2183]:
                        revert with 0, 50
                    mem[_2183 + 32] = tokenAddress
                    if 2 >= mem[_2183]:
                        revert with 0, 50
                    mem[_2183 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2183 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2183 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2183 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2183 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2183 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2183 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2183 + (2 * ceil32(return_data.size)) + 292] = mem[_2183]
                        idx = 0
                        s = _2183 + 32
                        t = _2183 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2183]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2183 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2183 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2183 + (2 * ceil32(return_data.size)) + (32 * mem[_2183]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3135 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3167 = mem[_3135]
                        require mem[_3135] <= test266151307()
                        require _3135 + mem[_3135] + 31 < _3135 + return_data.size
                        _3199 = mem[_3135 + mem[_3135]]
                        if mem[_3135 + mem[_3135]] > test266151307():
                            revert with 0, 65
                        if _3135 + ceil32(return_data.size) + ceil32(32 * mem[_3135 + mem[_3135]]) + 1 > test266151307() or ceil32(32 * mem[_3135 + mem[_3135]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3135 + ceil32(return_data.size) + ceil32(32 * mem[_3135 + mem[_3135]]) + 1
                        mem[_3135 + ceil32(return_data.size)] = _3199
                        require return_data.size >= _3167 + (32 * _3199) + 32
                        mem[_3135 + ceil32(return_data.size) + 32 len 32 * _3199] = mem[_3135 + _3167 + 32 len 32 * _3199]
                        if 0 >= _3199:
                            revert with 0, 50
                        _3807 = mem[_3135 + ceil32(return_data.size) + 32]
                        if mem[_3135 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3135 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3807 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3807 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3903 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3903] == bool(mem[_3903])
                        if arg4 < _3807:
                            revert with 0, 17
                        if arg4 - _3807 < _3807 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3807 - (_3807 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3807 - (_3807 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4031 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4031] == bool(mem[_4031])
                        emit 0xfedb587d: tokenAddress, _3807, address(arg2), arg3
                    else:
                        mem[_2183 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2183 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2183 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2183 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2183 + (2 * ceil32(return_data.size)) + 292] = mem[_2183]
                        idx = 0
                        s = _2183 + 32
                        t = _2183 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2183]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2183 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2183 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2183 + (2 * ceil32(return_data.size)) + (32 * mem[_2183]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3136 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3168 = mem[_3136]
                        require mem[_3136] <= test266151307()
                        require _3136 + mem[_3136] + 31 < _3136 + return_data.size
                        _3200 = mem[_3136 + mem[_3136]]
                        if mem[_3136 + mem[_3136]] > test266151307():
                            revert with 0, 65
                        if _3136 + ceil32(return_data.size) + ceil32(32 * mem[_3136 + mem[_3136]]) + 1 > test266151307() or ceil32(32 * mem[_3136 + mem[_3136]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3136 + ceil32(return_data.size) + ceil32(32 * mem[_3136 + mem[_3136]]) + 1
                        mem[_3136 + ceil32(return_data.size)] = _3200
                        require return_data.size >= _3168 + (32 * _3200) + 32
                        mem[_3136 + ceil32(return_data.size) + 32 len 32 * _3200] = mem[_3136 + _3168 + 32 len 32 * _3200]
                        if 0 >= _3200:
                            revert with 0, 50
                        _3808 = mem[_3136 + ceil32(return_data.size) + 32]
                        if mem[_3136 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3136 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3808 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3808 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3904 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3904] == bool(mem[_3904])
                        if arg4 < _3808:
                            revert with 0, 17
                        if arg4 - _3808 < _3808 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3808 - (_3808 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3808 - (_3808 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4032 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4032] == bool(mem[_4032])
                        emit 0xfedb587d: tokenAddress, _3808, address(arg2), arg3
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg4
            require ext_code.size(stor105)
            call stor105.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg4
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1130 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1138 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _1130 + (32 * _1138) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1138] = mem[(4 * ceil32(return_data.size)) + _1130 + 224 len 32 * _1138]
                if 0 >= _1138:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2170 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2170] == mem[_2170 + 12 len 20]
                if address(arg2) == mem[_2170 + 12 len 20]:
                    _2198 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2198]:
                        revert with 0, 50
                    mem[_2198 + 32] = tokenAddress
                    if 1 >= mem[_2198]:
                        revert with 0, 50
                    mem[_2198 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2198 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2198 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2198 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2198 + ceil32(return_data.size) + 100] = arg3
                        mem[_2198 + ceil32(return_data.size) + 132] = arg4
                        mem[_2198 + ceil32(return_data.size) + 164] = 160
                        mem[_2198 + ceil32(return_data.size) + 260] = mem[_2198]
                        idx = 0
                        s = _2198 + 32
                        t = _2198 + ceil32(return_data.size) + 292
                        while idx < mem[_2198]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2198 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2198 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2198 + ceil32(return_data.size) + 260 len (32 * mem[_2198]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2198 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2198 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3181 = mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2198 + ceil32(return_data.size) + return_data.size + 96
                        _3213 = mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2198 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2198 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2198 + (2 * ceil32(return_data.size)) + 96] = mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3181 + (32 * _3213) + 32
                        mem[_2198 + (2 * ceil32(return_data.size)) + 128 len 32 * _3213] = mem[_2198 + ceil32(return_data.size) + _3181 + 128 len 32 * _3213]
                        if 0 >= _3213:
                            revert with 0, 50
                        _3821 = mem[_2198 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2198 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2198 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3821 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3821 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3917 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3917] == bool(mem[_3917])
                        if arg4 < _3821:
                            revert with 0, 17
                        if arg4 - _3821 < _3821 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3821 - (_3821 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3821 - (_3821 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4045 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4045] == bool(mem[_4045])
                        emit 0xfedb587d: tokenAddress, _3821, address(arg2), arg3
                    else:
                        mem[_2198 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2198 + ceil32(return_data.size) + 100] = arg3
                        mem[_2198 + ceil32(return_data.size) + 132] = arg4
                        mem[_2198 + ceil32(return_data.size) + 164] = 160
                        mem[_2198 + ceil32(return_data.size) + 260] = mem[_2198]
                        idx = 0
                        s = _2198 + 32
                        t = _2198 + ceil32(return_data.size) + 292
                        while idx < mem[_2198]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2198 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2198 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2198 + ceil32(return_data.size) + 260 len (32 * mem[_2198]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2198 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2198 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3182 = mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2198 + ceil32(return_data.size) + return_data.size + 96
                        _3214 = mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2198 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2198 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2198 + (2 * ceil32(return_data.size)) + 96] = mem[_2198 + ceil32(return_data.size) + mem[_2198 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3182 + (32 * _3214) + 32
                        mem[_2198 + (2 * ceil32(return_data.size)) + 128 len 32 * _3214] = mem[_2198 + ceil32(return_data.size) + _3182 + 128 len 32 * _3214]
                        if 0 >= _3214:
                            revert with 0, 50
                        _3822 = mem[_2198 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2198 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2198 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3822 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3822 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3918 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3918] == bool(mem[_3918])
                        if arg4 < _3822:
                            revert with 0, 17
                        if arg4 - _3822 < _3822 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3822 - (_3822 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3822 - (_3822 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4046 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4046] == bool(mem[_4046])
                        emit 0xfedb587d: tokenAddress, _3822, address(arg2), arg3
                else:
                    _2195 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2195]:
                        revert with 0, 50
                    mem[_2195 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2195]:
                        revert with 0, 50
                    mem[_2195 + 32] = tokenAddress
                    if 2 >= mem[_2195]:
                        revert with 0, 50
                    mem[_2195 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2195 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2195 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2195 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2195 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2195 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2195 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2195 + (2 * ceil32(return_data.size)) + 292] = mem[_2195]
                        idx = 0
                        s = _2195 + 32
                        t = _2195 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2195]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2195 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2195 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2195 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2195]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2195 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2195 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3179 = mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2195 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3211 = mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2195 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2195 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2195 + (4 * ceil32(return_data.size)) + 128] = mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3179 + (32 * _3211) + 32
                        mem[_2195 + (4 * ceil32(return_data.size)) + 160 len 32 * _3211] = mem[_2195 + (2 * ceil32(return_data.size)) + _3179 + 160 len 32 * _3211]
                        if 0 >= _3211:
                            revert with 0, 50
                        _3819 = mem[_2195 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2195 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2195 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3819 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3819 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3915 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3915] == bool(mem[_3915])
                        if arg4 < _3819:
                            revert with 0, 17
                        if arg4 - _3819 < _3819 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3819 - (_3819 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3819 - (_3819 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4043 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4043] == bool(mem[_4043])
                        emit 0xfedb587d: tokenAddress, _3819, address(arg2), arg3
                    else:
                        mem[_2195 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2195 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2195 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2195 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2195 + (2 * ceil32(return_data.size)) + 292] = mem[_2195]
                        idx = 0
                        s = _2195 + 32
                        t = _2195 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2195]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2195 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2195 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2195 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2195]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2195 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2195 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3180 = mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2195 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3212 = mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2195 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2195 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2195 + (4 * ceil32(return_data.size)) + 128] = mem[_2195 + (2 * ceil32(return_data.size)) + mem[_2195 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3180 + (32 * _3212) + 32
                        mem[_2195 + (4 * ceil32(return_data.size)) + 160 len 32 * _3212] = mem[_2195 + (2 * ceil32(return_data.size)) + _3180 + 160 len 32 * _3212]
                        if 0 >= _3212:
                            revert with 0, 50
                        _3820 = mem[_2195 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2195 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2195 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3820 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3820 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3916 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3916] == bool(mem[_3916])
                        if arg4 < _3820:
                            revert with 0, 17
                        if arg4 - _3820 < _3820 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3820 - (_3820 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3820 - (_3820 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4044 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4044] == bool(mem[_4044])
                        emit 0xfedb587d: tokenAddress, _3820, address(arg2), arg3
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(6 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _1129 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _1137 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _1129 + (32 * _1137) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _1137] = mem[(6 * ceil32(return_data.size)) + _1129 + 256 len 32 * _1137]
                if 0 >= _1137:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(7 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(7 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2169 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2169] == mem[_2169 + 12 len 20]
                if address(arg2) == mem[_2169 + 12 len 20]:
                    _2194 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2194]:
                        revert with 0, 50
                    mem[_2194 + 32] = tokenAddress
                    if 1 >= mem[_2194]:
                        revert with 0, 50
                    mem[_2194 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2194 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2194 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2194 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2194 + ceil32(return_data.size) + 100] = arg3
                        mem[_2194 + ceil32(return_data.size) + 132] = arg4
                        mem[_2194 + ceil32(return_data.size) + 164] = 160
                        mem[_2194 + ceil32(return_data.size) + 260] = mem[_2194]
                        idx = 0
                        s = _2194 + 32
                        t = _2194 + ceil32(return_data.size) + 292
                        while idx < mem[_2194]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2194 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2194 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2194 + ceil32(return_data.size) + 260 len (32 * mem[_2194]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2194 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2194 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3177 = mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2194 + ceil32(return_data.size) + return_data.size + 96
                        _3209 = mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2194 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2194 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2194 + (2 * ceil32(return_data.size)) + 96] = mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3177 + (32 * _3209) + 32
                        mem[_2194 + (2 * ceil32(return_data.size)) + 128 len 32 * _3209] = mem[_2194 + ceil32(return_data.size) + _3177 + 128 len 32 * _3209]
                        if 0 >= _3209:
                            revert with 0, 50
                        _3817 = mem[_2194 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2194 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2194 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3817 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3817 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3913 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3913] == bool(mem[_3913])
                        if arg4 < _3817:
                            revert with 0, 17
                        if arg4 - _3817 < _3817 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3817 - (_3817 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3817 - (_3817 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4041 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4041] == bool(mem[_4041])
                        emit 0xfedb587d: tokenAddress, _3817, address(arg2), arg3
                    else:
                        mem[_2194 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2194 + ceil32(return_data.size) + 100] = arg3
                        mem[_2194 + ceil32(return_data.size) + 132] = arg4
                        mem[_2194 + ceil32(return_data.size) + 164] = 160
                        mem[_2194 + ceil32(return_data.size) + 260] = mem[_2194]
                        idx = 0
                        s = _2194 + 32
                        t = _2194 + ceil32(return_data.size) + 292
                        while idx < mem[_2194]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2194 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2194 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2194 + ceil32(return_data.size) + 260 len (32 * mem[_2194]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2194 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2194 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3178 = mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2194 + ceil32(return_data.size) + return_data.size + 96
                        _3210 = mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2194 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2194 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2194 + (2 * ceil32(return_data.size)) + 96] = mem[_2194 + ceil32(return_data.size) + mem[_2194 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3178 + (32 * _3210) + 32
                        mem[_2194 + (2 * ceil32(return_data.size)) + 128 len 32 * _3210] = mem[_2194 + ceil32(return_data.size) + _3178 + 128 len 32 * _3210]
                        if 0 >= _3210:
                            revert with 0, 50
                        _3818 = mem[_2194 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2194 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2194 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3818 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3818 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3914 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3914] == bool(mem[_3914])
                        if arg4 < _3818:
                            revert with 0, 17
                        if arg4 - _3818 < _3818 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3818 - (_3818 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3818 - (_3818 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4042 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4042] == bool(mem[_4042])
                        emit 0xfedb587d: tokenAddress, _3818, address(arg2), arg3
                else:
                    _2191 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2191]:
                        revert with 0, 50
                    mem[_2191 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2191]:
                        revert with 0, 50
                    mem[_2191 + 32] = tokenAddress
                    if 2 >= mem[_2191]:
                        revert with 0, 50
                    mem[_2191 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2191 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2191 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2191 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2191 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2191 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2191 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2191 + (2 * ceil32(return_data.size)) + 292] = mem[_2191]
                        idx = 0
                        s = _2191 + 32
                        t = _2191 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2191]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2191 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2191 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2191 + (2 * ceil32(return_data.size)) + (32 * mem[_2191]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3143 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3175 = mem[_3143]
                        require mem[_3143] <= test266151307()
                        require _3143 + mem[_3143] + 31 < _3143 + return_data.size
                        _3207 = mem[_3143 + mem[_3143]]
                        if mem[_3143 + mem[_3143]] > test266151307():
                            revert with 0, 65
                        if _3143 + ceil32(return_data.size) + ceil32(32 * mem[_3143 + mem[_3143]]) + 1 > test266151307() or ceil32(32 * mem[_3143 + mem[_3143]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3143 + ceil32(return_data.size) + ceil32(32 * mem[_3143 + mem[_3143]]) + 1
                        mem[_3143 + ceil32(return_data.size)] = _3207
                        require return_data.size >= _3175 + (32 * _3207) + 32
                        mem[_3143 + ceil32(return_data.size) + 32 len 32 * _3207] = mem[_3143 + _3175 + 32 len 32 * _3207]
                        if 0 >= _3207:
                            revert with 0, 50
                        _3815 = mem[_3143 + ceil32(return_data.size) + 32]
                        if mem[_3143 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3143 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3815 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3815 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3911 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3911] == bool(mem[_3911])
                        if arg4 < _3815:
                            revert with 0, 17
                        if arg4 - _3815 < _3815 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3815 - (_3815 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3815 - (_3815 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4039 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4039] == bool(mem[_4039])
                        emit 0xfedb587d: tokenAddress, _3815, address(arg2), arg3
                    else:
                        mem[_2191 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2191 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2191 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2191 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2191 + (2 * ceil32(return_data.size)) + 292] = mem[_2191]
                        idx = 0
                        s = _2191 + 32
                        t = _2191 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2191]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2191 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2191 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2191 + (2 * ceil32(return_data.size)) + (32 * mem[_2191]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3144 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3176 = mem[_3144]
                        require mem[_3144] <= test266151307()
                        require _3144 + mem[_3144] + 31 < _3144 + return_data.size
                        _3208 = mem[_3144 + mem[_3144]]
                        if mem[_3144 + mem[_3144]] > test266151307():
                            revert with 0, 65
                        if _3144 + ceil32(return_data.size) + ceil32(32 * mem[_3144 + mem[_3144]]) + 1 > test266151307() or ceil32(32 * mem[_3144 + mem[_3144]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3144 + ceil32(return_data.size) + ceil32(32 * mem[_3144 + mem[_3144]]) + 1
                        mem[_3144 + ceil32(return_data.size)] = _3208
                        require return_data.size >= _3176 + (32 * _3208) + 32
                        mem[_3144 + ceil32(return_data.size) + 32 len 32 * _3208] = mem[_3144 + _3176 + 32 len 32 * _3208]
                        if 0 >= _3208:
                            revert with 0, 50
                        _3816 = mem[_3144 + ceil32(return_data.size) + 32]
                        if mem[_3144 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3144 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3816 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3816 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3912 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3912] == bool(mem[_3912])
                        if arg4 < _3816:
                            revert with 0, 17
                        if arg4 - _3816 < _3816 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3816 - (_3816 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3816 - (_3816 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4040 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4040] == bool(mem[_4040])
                        emit 0xfedb587d: tokenAddress, _3816, address(arg2), arg3
    else:
        if address(sub_0584aecfAddress) != msg.sender:
            revert with 0, 'Access Denied!'
        mem[100] = this.address
        mem[132] = routerAddress
        require ext_code.size(stor105)
        staticcall stor105.allowance(address arg1, address arg2) with:
                gas gas_remaining wei
               args address(this.address), routerAddress
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] >= arg4:
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(2 * ceil32(return_data.size)) + 96] = 2
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(2 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(2 * ceil32(return_data.size)) + 196] = arg3
                mem[(2 * ceil32(return_data.size)) + 228] = 64
                mem[(2 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (2 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1132 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
                _1140 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(4 * ceil32(return_data.size)) + 192] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _1132 + (32 * _1140) + 32
                mem[(4 * ceil32(return_data.size)) + 224 len 32 * _1140] = mem[(2 * ceil32(return_data.size)) + _1132 + 224 len 32 * _1140]
                if 0 >= _1140:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(4 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2172 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2172] == mem[_2172 + 12 len 20]
                if address(arg2) == mem[_2172 + 12 len 20]:
                    _2206 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2206]:
                        revert with 0, 50
                    mem[_2206 + 32] = tokenAddress
                    if 1 >= mem[_2206]:
                        revert with 0, 50
                    mem[_2206 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2206 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2206 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2206 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2206 + ceil32(return_data.size) + 100] = arg3
                        mem[_2206 + ceil32(return_data.size) + 132] = arg4
                        mem[_2206 + ceil32(return_data.size) + 164] = 160
                        mem[_2206 + ceil32(return_data.size) + 260] = mem[_2206]
                        idx = 0
                        s = _2206 + 32
                        t = _2206 + ceil32(return_data.size) + 292
                        while idx < mem[_2206]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2206 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2206 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2206 + ceil32(return_data.size) + 260 len (32 * mem[_2206]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2206 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2206 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3189 = mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2206 + ceil32(return_data.size) + return_data.size + 96
                        _3221 = mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2206 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2206 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2206 + (2 * ceil32(return_data.size)) + 96] = _3221
                        require return_data.size >= _3189 + (32 * _3221) + 32
                        mem[_2206 + (2 * ceil32(return_data.size)) + 128 len 32 * _3221] = mem[_2206 + ceil32(return_data.size) + _3189 + 128 len 32 * _3221]
                        if 0 >= _3221:
                            revert with 0, 50
                        _3829 = mem[_2206 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2206 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2206 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3829 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3829 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3925 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3925] == bool(mem[_3925])
                        if arg4 < _3829:
                            revert with 0, 17
                        if arg4 - _3829 < _3829 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3829 - (_3829 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3829 - (_3829 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4053 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4053] == bool(mem[_4053])
                        emit 0xfedb587d: tokenAddress, _3829, address(arg2), arg3
                    else:
                        mem[_2206 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2206 + ceil32(return_data.size) + 100] = arg3
                        mem[_2206 + ceil32(return_data.size) + 132] = arg4
                        mem[_2206 + ceil32(return_data.size) + 164] = 160
                        mem[_2206 + ceil32(return_data.size) + 260] = mem[_2206]
                        idx = 0
                        s = _2206 + 32
                        t = _2206 + ceil32(return_data.size) + 292
                        while idx < mem[_2206]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2206 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2206 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2206 + ceil32(return_data.size) + 260 len (32 * mem[_2206]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2206 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2206 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3190 = mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2206 + ceil32(return_data.size) + return_data.size + 96
                        _3222 = mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2206 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2206 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2206 + ceil32(return_data.size) + mem[_2206 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2206 + (2 * ceil32(return_data.size)) + 96] = _3222
                        require return_data.size >= _3190 + (32 * _3222) + 32
                        mem[_2206 + (2 * ceil32(return_data.size)) + 128 len 32 * _3222] = mem[_2206 + ceil32(return_data.size) + _3190 + 128 len 32 * _3222]
                        if 0 >= _3222:
                            revert with 0, 50
                        _3830 = mem[_2206 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2206 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2206 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3830 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3830 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3926 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3926] == bool(mem[_3926])
                        if arg4 < _3830:
                            revert with 0, 17
                        if arg4 - _3830 < _3830 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3830 - (_3830 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3830 - (_3830 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4054 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4054] == bool(mem[_4054])
                        emit 0xfedb587d: tokenAddress, _3830, address(arg2), arg3
                else:
                    _2203 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2203]:
                        revert with 0, 50
                    mem[_2203 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2203]:
                        revert with 0, 50
                    mem[_2203 + 32] = tokenAddress
                    if 2 >= mem[_2203]:
                        revert with 0, 50
                    mem[_2203 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2203 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2203 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2203 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2203 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2203 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2203 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2203 + (2 * ceil32(return_data.size)) + 292] = mem[_2203]
                        idx = 0
                        s = _2203 + 32
                        t = _2203 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2203]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2203 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2203 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2203 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2203]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2203 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2203 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3187 = mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2203 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3219 = mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2203 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2203 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2203 + (4 * ceil32(return_data.size)) + 128] = mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3187 + (32 * _3219) + 32
                        mem[_2203 + (4 * ceil32(return_data.size)) + 160 len 32 * _3219] = mem[_2203 + (2 * ceil32(return_data.size)) + _3187 + 160 len 32 * _3219]
                        if 0 >= _3219:
                            revert with 0, 50
                        _3827 = mem[_2203 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2203 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2203 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3827 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3827 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3923] == bool(mem[_3923])
                        if arg4 < _3827:
                            revert with 0, 17
                        if arg4 - _3827 < _3827 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3827 - (_3827 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3827 - (_3827 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4051 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4051] == bool(mem[_4051])
                        emit 0xfedb587d: tokenAddress, _3827, address(arg2), arg3
                    else:
                        mem[_2203 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2203 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2203 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2203 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2203 + (2 * ceil32(return_data.size)) + 292] = mem[_2203]
                        idx = 0
                        s = _2203 + 32
                        t = _2203 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2203]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2203 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2203 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2203 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2203]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2203 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2203 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3188 = mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2203 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3220 = mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2203 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2203 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2203 + (4 * ceil32(return_data.size)) + 128] = mem[_2203 + (2 * ceil32(return_data.size)) + mem[_2203 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3188 + (32 * _3220) + 32
                        mem[_2203 + (4 * ceil32(return_data.size)) + 160 len 32 * _3220] = mem[_2203 + (2 * ceil32(return_data.size)) + _3188 + 160 len 32 * _3220]
                        if 0 >= _3220:
                            revert with 0, 50
                        _3828 = mem[_2203 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2203 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2203 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3828 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3828 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3924 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3924] == bool(mem[_3924])
                        if arg4 < _3828:
                            revert with 0, 17
                        if arg4 - _3828 < _3828 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3828 - (_3828 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3828 - (_3828 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4052 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4052] == bool(mem[_4052])
                        emit 0xfedb587d: tokenAddress, _3828, address(arg2), arg3
            else:
                mem[(2 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(2 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                mem[(4 * ceil32(return_data.size)) + 260] = 64
                mem[(4 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (2 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _1131 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                _1139 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _1131 + (32 * _1139) + 32
                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1139] = mem[(4 * ceil32(return_data.size)) + _1131 + 256 len 32 * _1139]
                if 0 >= _1139:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2171 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2171] == mem[_2171 + 12 len 20]
                if address(arg2) == mem[_2171 + 12 len 20]:
                    _2202 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2202]:
                        revert with 0, 50
                    mem[_2202 + 32] = tokenAddress
                    if 1 >= mem[_2202]:
                        revert with 0, 50
                    mem[_2202 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2202 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2202 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2202 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2202 + ceil32(return_data.size) + 100] = arg3
                        mem[_2202 + ceil32(return_data.size) + 132] = arg4
                        mem[_2202 + ceil32(return_data.size) + 164] = 160
                        mem[_2202 + ceil32(return_data.size) + 260] = mem[_2202]
                        idx = 0
                        s = _2202 + 32
                        t = _2202 + ceil32(return_data.size) + 292
                        while idx < mem[_2202]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2202 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2202 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2202 + ceil32(return_data.size) + 260 len (32 * mem[_2202]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2202 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2202 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3185 = mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2202 + ceil32(return_data.size) + return_data.size + 96
                        _3217 = mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2202 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2202 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2202 + (2 * ceil32(return_data.size)) + 96] = mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3185 + (32 * _3217) + 32
                        mem[_2202 + (2 * ceil32(return_data.size)) + 128 len 32 * _3217] = mem[_2202 + ceil32(return_data.size) + _3185 + 128 len 32 * _3217]
                        if 0 >= _3217:
                            revert with 0, 50
                        _3825 = mem[_2202 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2202 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2202 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3825 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3825 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3921 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3921] == bool(mem[_3921])
                        if arg4 < _3825:
                            revert with 0, 17
                        if arg4 - _3825 < _3825 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3825 - (_3825 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3825 - (_3825 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4049 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4049] == bool(mem[_4049])
                        emit 0xfedb587d: tokenAddress, _3825, address(arg2), arg3
                    else:
                        mem[_2202 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2202 + ceil32(return_data.size) + 100] = arg3
                        mem[_2202 + ceil32(return_data.size) + 132] = arg4
                        mem[_2202 + ceil32(return_data.size) + 164] = 160
                        mem[_2202 + ceil32(return_data.size) + 260] = mem[_2202]
                        idx = 0
                        s = _2202 + 32
                        t = _2202 + ceil32(return_data.size) + 292
                        while idx < mem[_2202]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2202 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2202 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2202 + ceil32(return_data.size) + 260 len (32 * mem[_2202]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2202 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2202 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3186 = mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2202 + ceil32(return_data.size) + return_data.size + 96
                        _3218 = mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2202 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2202 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2202 + (2 * ceil32(return_data.size)) + 96] = mem[_2202 + ceil32(return_data.size) + mem[_2202 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        require return_data.size >= _3186 + (32 * _3218) + 32
                        mem[_2202 + (2 * ceil32(return_data.size)) + 128 len 32 * _3218] = mem[_2202 + ceil32(return_data.size) + _3186 + 128 len 32 * _3218]
                        if 0 >= _3218:
                            revert with 0, 50
                        _3826 = mem[_2202 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2202 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2202 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3826 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3826 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3922 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3922] == bool(mem[_3922])
                        if arg4 < _3826:
                            revert with 0, 17
                        if arg4 - _3826 < _3826 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3826 - (_3826 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3826 - (_3826 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4050 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4050] == bool(mem[_4050])
                        emit 0xfedb587d: tokenAddress, _3826, address(arg2), arg3
                else:
                    _2199 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2199]:
                        revert with 0, 50
                    mem[_2199 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2199]:
                        revert with 0, 50
                    mem[_2199 + 32] = tokenAddress
                    if 2 >= mem[_2199]:
                        revert with 0, 50
                    mem[_2199 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2199 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2199 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2199 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2199 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2199 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2199 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2199 + (2 * ceil32(return_data.size)) + 292] = mem[_2199]
                        idx = 0
                        s = _2199 + 32
                        t = _2199 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2199]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2199 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2199 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2199 + (2 * ceil32(return_data.size)) + (32 * mem[_2199]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3151 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3183 = mem[_3151]
                        require mem[_3151] <= test266151307()
                        require _3151 + mem[_3151] + 31 < _3151 + return_data.size
                        _3215 = mem[_3151 + mem[_3151]]
                        if mem[_3151 + mem[_3151]] > test266151307():
                            revert with 0, 65
                        if _3151 + ceil32(return_data.size) + ceil32(32 * mem[_3151 + mem[_3151]]) + 1 > test266151307() or ceil32(32 * mem[_3151 + mem[_3151]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3151 + ceil32(return_data.size) + ceil32(32 * mem[_3151 + mem[_3151]]) + 1
                        mem[_3151 + ceil32(return_data.size)] = _3215
                        require return_data.size >= _3183 + (32 * _3215) + 32
                        mem[_3151 + ceil32(return_data.size) + 32 len 32 * _3215] = mem[_3151 + _3183 + 32 len 32 * _3215]
                        if 0 >= _3215:
                            revert with 0, 50
                        _3823 = mem[_3151 + ceil32(return_data.size) + 32]
                        if mem[_3151 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3151 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3823 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3823 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3919 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3919] == bool(mem[_3919])
                        if arg4 < _3823:
                            revert with 0, 17
                        if arg4 - _3823 < _3823 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3823 - (_3823 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3823 - (_3823 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4047 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4047] == bool(mem[_4047])
                        emit 0xfedb587d: tokenAddress, _3823, address(arg2), arg3
                    else:
                        mem[_2199 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2199 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2199 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2199 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2199 + (2 * ceil32(return_data.size)) + 292] = mem[_2199]
                        idx = 0
                        s = _2199 + 32
                        t = _2199 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2199]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2199 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2199 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2199 + (2 * ceil32(return_data.size)) + (32 * mem[_2199]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3152 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3184 = mem[_3152]
                        require mem[_3152] <= test266151307()
                        require _3152 + mem[_3152] + 31 < _3152 + return_data.size
                        _3216 = mem[_3152 + mem[_3152]]
                        if mem[_3152 + mem[_3152]] > test266151307():
                            revert with 0, 65
                        if _3152 + ceil32(return_data.size) + ceil32(32 * mem[_3152 + mem[_3152]]) + 1 > test266151307() or ceil32(32 * mem[_3152 + mem[_3152]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3152 + ceil32(return_data.size) + ceil32(32 * mem[_3152 + mem[_3152]]) + 1
                        mem[_3152 + ceil32(return_data.size)] = _3216
                        require return_data.size >= _3184 + (32 * _3216) + 32
                        mem[_3152 + ceil32(return_data.size) + 32 len 32 * _3216] = mem[_3152 + _3184 + 32 len 32 * _3216]
                        if 0 >= _3216:
                            revert with 0, 50
                        _3824 = mem[_3152 + ceil32(return_data.size) + 32]
                        if mem[_3152 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3152 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3824 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3824 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3920 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3920] == bool(mem[_3920])
                        if arg4 < _3824:
                            revert with 0, 17
                        if arg4 - _3824 < _3824 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3824 - (_3824 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3824 - (_3824 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4048 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4048] == bool(mem[_4048])
                        emit 0xfedb587d: tokenAddress, _3824, address(arg2), arg3
        else:
            mem[ceil32(return_data.size) + 100] = routerAddress
            mem[ceil32(return_data.size) + 132] = arg4
            require ext_code.size(stor105)
            call stor105.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args routerAddress, arg4
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(stor101)
            staticcall stor101.WAVAX() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(arg2) == ext_call.return_data[12 len 20]:
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg3
                mem[(4 * ceil32(return_data.size)) + 228] = 64
                mem[(4 * ceil32(return_data.size)) + 260] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 292
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 292 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1134 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _1142 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg3) >> 32 + 192]
                require return_data.size >= _1134 + (32 * _1142) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1142] = mem[(4 * ceil32(return_data.size)) + _1134 + 224 len 32 * _1142]
                if 0 >= _1142:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(6 * ceil32(return_data.size)) + 224] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 224]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 224]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 224]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2174 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2174] == mem[_2174 + 12 len 20]
                if address(arg2) == mem[_2174 + 12 len 20]:
                    _2214 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2214]:
                        revert with 0, 50
                    mem[_2214 + 32] = tokenAddress
                    if 1 >= mem[_2214]:
                        revert with 0, 50
                    mem[_2214 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2214 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2214 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2214 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2214 + ceil32(return_data.size) + 100] = arg3
                        mem[_2214 + ceil32(return_data.size) + 132] = arg4
                        mem[_2214 + ceil32(return_data.size) + 164] = 160
                        mem[_2214 + ceil32(return_data.size) + 260] = mem[_2214]
                        idx = 0
                        s = _2214 + 32
                        t = _2214 + ceil32(return_data.size) + 292
                        while idx < mem[_2214]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2214 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2214 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2214 + ceil32(return_data.size) + (32 * mem[_2214]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3165 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3197 = mem[_3165]
                        require mem[_3165] <= test266151307()
                        require _3165 + mem[_3165] + 31 < _3165 + return_data.size
                        _3229 = mem[_3165 + mem[_3165]]
                        if mem[_3165 + mem[_3165]] > test266151307():
                            revert with 0, 65
                        if _3165 + ceil32(return_data.size) + ceil32(32 * mem[_3165 + mem[_3165]]) + 1 > test266151307() or ceil32(32 * mem[_3165 + mem[_3165]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3165 + ceil32(return_data.size) + ceil32(32 * mem[_3165 + mem[_3165]]) + 1
                        mem[_3165 + ceil32(return_data.size)] = _3229
                        require return_data.size >= _3197 + (32 * _3229) + 32
                        mem[_3165 + ceil32(return_data.size) + 32 len 32 * _3229] = mem[_3165 + _3197 + 32 len 32 * _3229]
                        if 0 >= _3229:
                            revert with 0, 50
                        _3837 = mem[_3165 + ceil32(return_data.size) + 32]
                        if mem[_3165 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3165 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3837 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3837 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3933 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3933] == bool(mem[_3933])
                        if arg4 < _3837:
                            revert with 0, 17
                        if arg4 - _3837 < _3837 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3837 - (_3837 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3837 - (_3837 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4061 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4061] == bool(mem[_4061])
                        emit 0xfedb587d: tokenAddress, _3837, address(arg2), arg3
                    else:
                        mem[_2214 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2214 + ceil32(return_data.size) + 100] = arg3
                        mem[_2214 + ceil32(return_data.size) + 132] = arg4
                        mem[_2214 + ceil32(return_data.size) + 164] = 160
                        mem[_2214 + ceil32(return_data.size) + 260] = mem[_2214]
                        idx = 0
                        s = _2214 + 32
                        t = _2214 + ceil32(return_data.size) + 292
                        while idx < mem[_2214]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2214 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2214 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2214 + ceil32(return_data.size) + (32 * mem[_2214]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3166 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3198 = mem[_3166]
                        require mem[_3166] <= test266151307()
                        require _3166 + mem[_3166] + 31 < _3166 + return_data.size
                        _3230 = mem[_3166 + mem[_3166]]
                        if mem[_3166 + mem[_3166]] > test266151307():
                            revert with 0, 65
                        if _3166 + ceil32(return_data.size) + ceil32(32 * mem[_3166 + mem[_3166]]) + 1 > test266151307() or ceil32(32 * mem[_3166 + mem[_3166]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3166 + ceil32(return_data.size) + ceil32(32 * mem[_3166 + mem[_3166]]) + 1
                        mem[_3166 + ceil32(return_data.size)] = _3230
                        require return_data.size >= _3198 + (32 * _3230) + 32
                        mem[_3166 + ceil32(return_data.size) + 32 len 32 * _3230] = mem[_3166 + _3198 + 32 len 32 * _3230]
                        if 0 >= _3230:
                            revert with 0, 50
                        _3838 = mem[_3166 + ceil32(return_data.size) + 32]
                        if mem[_3166 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3166 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3838 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3838 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3934 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3934] == bool(mem[_3934])
                        if arg4 < _3838:
                            revert with 0, 17
                        if arg4 - _3838 < _3838 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3838 - (_3838 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3838 - (_3838 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4062 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4062] == bool(mem[_4062])
                        emit 0xfedb587d: tokenAddress, _3838, address(arg2), arg3
                else:
                    _2211 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2211]:
                        revert with 0, 50
                    mem[_2211 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2211]:
                        revert with 0, 50
                    mem[_2211 + 32] = tokenAddress
                    if 2 >= mem[_2211]:
                        revert with 0, 50
                    mem[_2211 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2211 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2211 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2211 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2211 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2211 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2211 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2211 + (2 * ceil32(return_data.size)) + 292] = mem[_2211]
                        idx = 0
                        s = _2211 + 32
                        t = _2211 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2211]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2211 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2211 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2211 + (2 * ceil32(return_data.size)) + (32 * mem[_2211]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3163 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3195 = mem[_3163]
                        require mem[_3163] <= test266151307()
                        require _3163 + mem[_3163] + 31 < _3163 + return_data.size
                        _3227 = mem[_3163 + mem[_3163]]
                        if mem[_3163 + mem[_3163]] > test266151307():
                            revert with 0, 65
                        if _3163 + ceil32(return_data.size) + ceil32(32 * mem[_3163 + mem[_3163]]) + 1 > test266151307() or ceil32(32 * mem[_3163 + mem[_3163]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3163 + ceil32(return_data.size) + ceil32(32 * mem[_3163 + mem[_3163]]) + 1
                        mem[_3163 + ceil32(return_data.size)] = _3227
                        require return_data.size >= _3195 + (32 * _3227) + 32
                        mem[_3163 + ceil32(return_data.size) + 32 len 32 * _3227] = mem[_3163 + _3195 + 32 len 32 * _3227]
                        if 0 >= _3227:
                            revert with 0, 50
                        _3835 = mem[_3163 + ceil32(return_data.size) + 32]
                        if mem[_3163 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3163 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3835 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3835 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3931 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3931] == bool(mem[_3931])
                        if arg4 < _3835:
                            revert with 0, 17
                        if arg4 - _3835 < _3835 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3835 - (_3835 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3835 - (_3835 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4059 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4059] == bool(mem[_4059])
                        emit 0xfedb587d: tokenAddress, _3835, address(arg2), arg3
                    else:
                        mem[_2211 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2211 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2211 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2211 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2211 + (2 * ceil32(return_data.size)) + 292] = mem[_2211]
                        idx = 0
                        s = _2211 + 32
                        t = _2211 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2211]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2211 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2211 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _2211 + (2 * ceil32(return_data.size)) + (32 * mem[_2211]) + -mem[64] + 320]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3164 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3196 = mem[_3164]
                        require mem[_3164] <= test266151307()
                        require _3164 + mem[_3164] + 31 < _3164 + return_data.size
                        _3228 = mem[_3164 + mem[_3164]]
                        if mem[_3164 + mem[_3164]] > test266151307():
                            revert with 0, 65
                        if _3164 + ceil32(return_data.size) + ceil32(32 * mem[_3164 + mem[_3164]]) + 1 > test266151307() or ceil32(32 * mem[_3164 + mem[_3164]]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _3164 + ceil32(return_data.size) + ceil32(32 * mem[_3164 + mem[_3164]]) + 1
                        mem[_3164 + ceil32(return_data.size)] = _3228
                        require return_data.size >= _3196 + (32 * _3228) + 32
                        mem[_3164 + ceil32(return_data.size) + 32 len 32 * _3228] = mem[_3164 + _3196 + 32 len 32 * _3228]
                        if 0 >= _3228:
                            revert with 0, 50
                        _3836 = mem[_3164 + ceil32(return_data.size) + 32]
                        if mem[_3164 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_3164 + ceil32(return_data.size) + 32]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3836 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3836 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3932 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3932] == bool(mem[_3932])
                        if arg4 < _3836:
                            revert with 0, 17
                        if arg4 - _3836 < _3836 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3836 - (_3836 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3836 - (_3836 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4060 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4060] == bool(mem[_4060])
                        emit 0xfedb587d: tokenAddress, _3836, address(arg2), arg3
            else:
                mem[(4 * ceil32(return_data.size)) + 96] = 3
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[(4 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 160] = ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 128] = tokenAddress
                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                mem[(6 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                mem[(6 * ceil32(return_data.size)) + 228] = arg3
                mem[(6 * ceil32(return_data.size)) + 260] = 64
                mem[(6 * ceil32(return_data.size)) + 292] = 3
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (6 * ceil32(return_data.size)) + 324
                while idx < 3:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                require ext_code.size(stor101)
                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                        gas gas_remaining wei
                       args arg3, Array(len=3, data=mem[(6 * ceil32(return_data.size)) + 324 len 96])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(6 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (7 * ceil32(return_data.size)) + 224
                require return_data.size >= 32
                _1133 = mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                require mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                require (6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (6 * ceil32(return_data.size)) + return_data.size + 224
                _1141 = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                if mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                    revert with 0, 65
                if (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (7 * ceil32(return_data.size)) + ceil32(32 * mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                mem[(7 * ceil32(return_data.size)) + 224] = mem[(6 * ceil32(return_data.size)) + mem[(6 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                require return_data.size >= _1133 + (32 * _1141) + 32
                mem[(7 * ceil32(return_data.size)) + 256 len 32 * _1141] = mem[(6 * ceil32(return_data.size)) + _1133 + 256 len 32 * _1141]
                if 0 >= _1141:
                    revert with 0, 50
                if 100 * 10^6 > !sub_fd53fce0:
                    revert with 0, 17
                if mem[(7 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(7 * ceil32(return_data.size)) + 256]:
                    revert with 0, 17
                if (100 * 10^6 * mem[(7 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(7 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                require ext_code.size(stor101)
                staticcall stor101.WAVAX() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2173 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2173] == mem[_2173 + 12 len 20]
                if address(arg2) == mem[_2173 + 12 len 20]:
                    _2210 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if not mem[_2210]:
                        revert with 0, 50
                    mem[_2210 + 32] = tokenAddress
                    if 1 >= mem[_2210]:
                        revert with 0, 50
                    mem[_2210 + 64] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2210 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2210 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2210 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2210 + ceil32(return_data.size) + 100] = arg3
                        mem[_2210 + ceil32(return_data.size) + 132] = arg4
                        mem[_2210 + ceil32(return_data.size) + 164] = 160
                        mem[_2210 + ceil32(return_data.size) + 260] = mem[_2210]
                        idx = 0
                        s = _2210 + 32
                        t = _2210 + ceil32(return_data.size) + 292
                        while idx < mem[_2210]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2210 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2210 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2210 + ceil32(return_data.size) + 260 len (32 * mem[_2210]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2210 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2210 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3193 = mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2210 + ceil32(return_data.size) + return_data.size + 96
                        _3225 = mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2210 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2210 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2210 + (2 * ceil32(return_data.size)) + 96] = _3225
                        require return_data.size >= _3193 + (32 * _3225) + 32
                        mem[_2210 + (2 * ceil32(return_data.size)) + 128 len 32 * _3225] = mem[_2210 + ceil32(return_data.size) + _3193 + 128 len 32 * _3225]
                        if 0 >= _3225:
                            revert with 0, 50
                        _3833 = mem[_2210 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2210 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2210 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3833 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3833 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3929] == bool(mem[_3929])
                        if arg4 < _3833:
                            revert with 0, 17
                        if arg4 - _3833 < _3833 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3833 - (_3833 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3833 - (_3833 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4057 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4057] == bool(mem[_4057])
                        emit 0xfedb587d: tokenAddress, _3833, address(arg2), arg3
                    else:
                        mem[_2210 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2210 + ceil32(return_data.size) + 100] = arg3
                        mem[_2210 + ceil32(return_data.size) + 132] = arg4
                        mem[_2210 + ceil32(return_data.size) + 164] = 160
                        mem[_2210 + ceil32(return_data.size) + 260] = mem[_2210]
                        idx = 0
                        s = _2210 + 32
                        t = _2210 + ceil32(return_data.size) + 292
                        while idx < mem[_2210]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2210 + ceil32(return_data.size) + 196] = address(arg1)
                        mem[_2210 + ceil32(return_data.size) + 228] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2210 + ceil32(return_data.size) + 260 len (32 * mem[_2210]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2210 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2210 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _3194 = mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _2210 + ceil32(return_data.size) + return_data.size + 96
                        _3226 = mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                        if mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if _2210 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2210 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_2210 + ceil32(return_data.size) + mem[_2210 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                        mem[_2210 + (2 * ceil32(return_data.size)) + 96] = _3226
                        require return_data.size >= _3194 + (32 * _3226) + 32
                        mem[_2210 + (2 * ceil32(return_data.size)) + 128 len 32 * _3226] = mem[_2210 + ceil32(return_data.size) + _3194 + 128 len 32 * _3226]
                        if 0 >= _3226:
                            revert with 0, 50
                        _3834 = mem[_2210 + (2 * ceil32(return_data.size)) + 128]
                        if mem[_2210 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_2210 + (2 * ceil32(return_data.size)) + 128]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3834 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3834 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3930 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3930] == bool(mem[_3930])
                        if arg4 < _3834:
                            revert with 0, 17
                        if arg4 - _3834 < _3834 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3834 - (_3834 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3834 - (_3834 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4058 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4058] == bool(mem[_4058])
                        emit 0xfedb587d: tokenAddress, _3834, address(arg2), arg3
                else:
                    _2207 = mem[64]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[mem[64] + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if 1 >= mem[_2207]:
                        revert with 0, 50
                    mem[_2207 + 64] = ext_call.return_data[12 len 20]
                    if not mem[_2207]:
                        revert with 0, 50
                    mem[_2207 + 32] = tokenAddress
                    if 2 >= mem[_2207]:
                        revert with 0, 50
                    mem[_2207 + 96] = address(arg2)
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    mem[_2207 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2207 + (2 * ceil32(return_data.size)) + 128
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if address(arg2) != ext_call.return_data[12 len 20]:
                        mem[_2207 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                        mem[_2207 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2207 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2207 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2207 + (2 * ceil32(return_data.size)) + 292] = mem[_2207]
                        idx = 0
                        s = _2207 + 32
                        t = _2207 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2207]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2207 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2207 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2207 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2207]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2207 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2207 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3191 = mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2207 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3223 = mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2207 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2207 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2207 + (4 * ceil32(return_data.size)) + 128] = mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3191 + (32 * _3223) + 32
                        mem[_2207 + (4 * ceil32(return_data.size)) + 160 len 32 * _3223] = mem[_2207 + (2 * ceil32(return_data.size)) + _3191 + 160 len 32 * _3223]
                        if 0 >= _3223:
                            revert with 0, 50
                        _3831 = mem[_2207 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2207 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2207 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3831 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3831 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3927 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3927] == bool(mem[_3927])
                        if arg4 < _3831:
                            revert with 0, 17
                        if arg4 - _3831 < _3831 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3831 - (_3831 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3831 - (_3831 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4055 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4055] == bool(mem[_4055])
                        emit 0xfedb587d: tokenAddress, _3831, address(arg2), arg3
                    else:
                        mem[_2207 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                        mem[_2207 + (2 * ceil32(return_data.size)) + 132] = arg3
                        mem[_2207 + (2 * ceil32(return_data.size)) + 164] = arg4
                        mem[_2207 + (2 * ceil32(return_data.size)) + 196] = 160
                        mem[_2207 + (2 * ceil32(return_data.size)) + 292] = mem[_2207]
                        idx = 0
                        s = _2207 + 32
                        t = _2207 + (2 * ceil32(return_data.size)) + 324
                        while idx < mem[_2207]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_2207 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                        mem[_2207 + (2 * ceil32(return_data.size)) + 260] = arg5
                        require ext_code.size(stor101)
                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg3, arg4, 160, address(arg1), arg5, mem[_2207 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_2207]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2207 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _2207 + (4 * ceil32(return_data.size)) + 128
                        require return_data.size >= 32
                        _3192 = mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                        require mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                        require _2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _2207 + (2 * ceil32(return_data.size)) + return_data.size + 128
                        _3224 = mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        if mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                            revert with 0, 65
                        if _2207 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = _2207 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                        mem[_2207 + (4 * ceil32(return_data.size)) + 128] = mem[_2207 + (2 * ceil32(return_data.size)) + mem[_2207 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                        require return_data.size >= _3192 + (32 * _3224) + 32
                        mem[_2207 + (4 * ceil32(return_data.size)) + 160 len 32 * _3224] = mem[_2207 + (2 * ceil32(return_data.size)) + _3192 + 160 len 32 * _3224]
                        if 0 >= _3224:
                            revert with 0, 50
                        _3832 = mem[_2207 + (4 * ceil32(return_data.size)) + 160]
                        if mem[_2207 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_2207 + (4 * ceil32(return_data.size)) + 160]:
                            revert with 0, 17
                        mem[mem[64] + 4] = sub_11eb47dcAddress
                        mem[mem[64] + 36] = _3832 * sub_fd53fce0 / 100 * 10^6
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args sub_11eb47dcAddress, _3832 * sub_fd53fce0 / 100 * 10^6
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3928] == bool(mem[_3928])
                        if arg4 < _3832:
                            revert with 0, 17
                        if arg4 - _3832 < _3832 * sub_fd53fce0 / 100 * 10^6:
                            revert with 0, 17
                        mem[mem[64] + 4] = address(arg1)
                        mem[mem[64] + 36] = arg4 - _3832 - (_3832 * sub_fd53fce0 / 100 * 10^6)
                        require ext_code.size(stor105)
                        call stor105.transfer(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), arg4 - _3832 - (_3832 * sub_fd53fce0 / 100 * 10^6)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4056 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_4056] == bool(mem[_4056])
                        emit 0xfedb587d: tokenAddress, _3832, address(arg2), arg3
}

function _fallback() payable {
    if calldata.size < 4:
        require not calldata.size
        emit PaymentReceived(msg.sender, msg.value);
    else:
        if unknown_0x88e5249f(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xc350a1b5(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0xeb6d3a11(?????) > uint32(call.func_hash) >> 224:
                    if uint32(call.func_hash) >> 224 != unknown_0xc350a1b5(?????):
                        if unknown_0xce7c2ac2(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            return shares[address(arg1)]
                        if uint32(call.func_hash) >> 224 != unknown_0xd79779b2(?????):
                            require unknown_0xe33b7de3(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            return totalReleased
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require arg1 == address(arg1)
                        return totalReleased[address(arg1)]
                    require not msg.value
                    require calldata.size - 4 >= 96
                    require arg1 == address(arg1)
                    require arg3 == address(arg3)
                    if uint8(stor0.field_8):
                        if ext_code.size(this.address):
                            revert with 0, 'Initializable: contract is already initialized'
                        if uint8(stor0.field_8):
                            if not address(arg1):
                                revert with 0, 'ROUTER ZERO'
                            mem[160] = msg.sender
                            mem[192] = 1
                            mem[224] = 1
                            if not uint8(stor0.field_8):
                                revert with 0, 'Initializable: contract is not initializing'
                            idx = 0
                            while idx < 1:
                                if idx >= 1:
                                    revert with 0, 50
                                if idx >= 1:
                                    revert with 0, 50
                                _4376 = mem[(32 * idx) + 224]
                                if not mem[(32 * idx) + 172 len 20]:
                                    revert with 0, 'PaymentSplitter: account is the zero address'
                                if mem[(32 * idx) + 224] <= 0:
                                    revert with 0, 'PaymentSplitter: shares are 0'
                                if shares[mem[(32 * idx) + 172 len 20]]:
                                    revert with 0, 'PaymentSplitter: account already has shares'
                                payee.length++
                                stor42A7[stor55.length] = mem[(32 * idx) + 172 len 20]
                                mem[0] = mem[(32 * idx) + 172 len 20]
                                mem[32] = 53
                                shares[address(mem[(32 * idx) + 160])] = mem[(32 * idx) + 224]
                                if totalShares > !mem[(32 * idx) + 224]:
                                    revert with 0, 17
                                totalShares += mem[(32 * idx) + 224]
                                mem[256] = mem[(32 * idx) + 172 len 20]
                                mem[288] = _4376
                                emit PayeeAdded(mem[256], _4376);
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            uint16(stor0.field_0) = 257
                            if not address(arg1):
                                revert with 0, 'ROUTER ZERO'
                            mem[160] = msg.sender
                            mem[192] = 1
                            mem[224] = 1
                            if not uint8(stor0.field_8):
                                revert with 0, 'Initializable: contract is not initializing'
                            idx = 0
                            while idx < 1:
                                if idx >= 1:
                                    revert with 0, 50
                                if idx >= 1:
                                    revert with 0, 50
                                _4377 = mem[(32 * idx) + 224]
                                if not mem[(32 * idx) + 172 len 20]:
                                    revert with 0, 'PaymentSplitter: account is the zero address'
                                if mem[(32 * idx) + 224] <= 0:
                                    revert with 0, 'PaymentSplitter: shares are 0'
                                if shares[mem[(32 * idx) + 172 len 20]]:
                                    revert with 0, 'PaymentSplitter: account already has shares'
                                payee.length++
                                stor42A7[stor55.length] = mem[(32 * idx) + 172 len 20]
                                mem[0] = mem[(32 * idx) + 172 len 20]
                                mem[32] = 53
                                shares[address(mem[(32 * idx) + 160])] = mem[(32 * idx) + 224]
                                if totalShares > !mem[(32 * idx) + 224]:
                                    revert with 0, 17
                                totalShares += mem[(32 * idx) + 224]
                                mem[256] = mem[(32 * idx) + 172 len 20]
                                mem[288] = _4377
                                emit PayeeAdded(mem[256], _4377);
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    else:
                        if uint8(stor0.field_0):
                            revert with 0, 'Initializable: contract is already initialized'
                        if uint8(stor0.field_8):
                            if not address(arg1):
                                revert with 0, 'ROUTER ZERO'
                            mem[160] = msg.sender
                            mem[192] = 1
                            mem[224] = 1
                            if not uint8(stor0.field_8):
                                revert with 0, 'Initializable: contract is not initializing'
                            idx = 0
                            while idx < 1:
                                if idx >= 1:
                                    revert with 0, 50
                                if idx >= 1:
                                    revert with 0, 50
                                _4378 = mem[(32 * idx) + 224]
                                if not mem[(32 * idx) + 172 len 20]:
                                    revert with 0, 'PaymentSplitter: account is the zero address'
                                if mem[(32 * idx) + 224] <= 0:
                                    revert with 0, 'PaymentSplitter: shares are 0'
                                if shares[mem[(32 * idx) + 172 len 20]]:
                                    revert with 0, 'PaymentSplitter: account already has shares'
                                payee.length++
                                stor42A7[stor55.length] = mem[(32 * idx) + 172 len 20]
                                mem[0] = mem[(32 * idx) + 172 len 20]
                                mem[32] = 53
                                shares[address(mem[(32 * idx) + 160])] = mem[(32 * idx) + 224]
                                if totalShares > !mem[(32 * idx) + 224]:
                                    revert with 0, 17
                                totalShares += mem[(32 * idx) + 224]
                                mem[256] = mem[(32 * idx) + 172 len 20]
                                mem[288] = _4378
                                emit PayeeAdded(mem[256], _4378);
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            uint16(stor0.field_0) = 257
                            if not address(arg1):
                                revert with 0, 'ROUTER ZERO'
                            mem[160] = msg.sender
                            mem[192] = 1
                            mem[224] = 1
                            if not uint8(stor0.field_8):
                                revert with 0, 'Initializable: contract is not initializing'
                            idx = 0
                            while idx < 1:
                                if idx >= 1:
                                    revert with 0, 50
                                if idx >= 1:
                                    revert with 0, 50
                                _4379 = mem[(32 * idx) + 224]
                                if not mem[(32 * idx) + 172 len 20]:
                                    revert with 0, 'PaymentSplitter: account is the zero address'
                                if mem[(32 * idx) + 224] <= 0:
                                    revert with 0, 'PaymentSplitter: shares are 0'
                                if shares[mem[(32 * idx) + 172 len 20]]:
                                    revert with 0, 'PaymentSplitter: account already has shares'
                                payee.length++
                                stor42A7[stor55.length] = mem[(32 * idx) + 172 len 20]
                                mem[0] = mem[(32 * idx) + 172 len 20]
                                mem[32] = 53
                                shares[address(mem[(32 * idx) + 160])] = mem[(32 * idx) + 224]
                                if totalShares > !mem[(32 * idx) + 224]:
                                    revert with 0, 17
                                totalShares += mem[(32 * idx) + 224]
                                mem[256] = mem[(32 * idx) + 172 len 20]
                                mem[288] = _4379
                                emit PayeeAdded(mem[256], _4379);
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                    routerAddress = address(arg1)
                    stor101 = address(arg1)
                    uint256(stor104) = msg.sender or Mask(96, 160, uint256(stor104))
                    sub_fd53fce0 = arg2
                    sub_11eb47dcAddress = address(arg3)
                    if not uint8(stor0.field_8):
                        uint8(stor0.field_8) = 0
                else:
                    if unknown_0xeb6d3a11(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        return ext_call.return_data[12 len 20]
                    if uint32(call.func_hash) >> 224 != unknown_0xed9705da(?????):
                        if uint32(call.func_hash) >> 224 != unknown_0xf5c13653(?????):
                            require unknown_0xfd53fce0(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            return sub_fd53fce0
                        require not msg.value
                        require calldata.size - 4 >= 96
                        require arg1 == bool(arg1)
                        require arg2 == address(arg2)
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if address(arg2) == ext_call.return_data[12 len 20]:
                            mem[ceil32(return_data.size) + 128] = 2
                            if not arg1:
                                mem[ceil32(return_data.size) + 160] = tokenAddress
                                mem[ceil32(return_data.size) + 192] = address(arg2)
                                mem[ceil32(return_data.size) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + 228] = arg3
                                mem[ceil32(return_data.size) + 260] = 64
                                mem[ceil32(return_data.size) + 292] = 2
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = ceil32(return_data.size) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4514 = mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < ceil32(return_data.size) + return_data.size + 224
                                _4578 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(2 * ceil32(return_data.size)) + 224] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4514 + (32 * _4578) + 32
                                mem[(2 * ceil32(return_data.size)) + 256 len 32 * _4578] = mem[ceil32(return_data.size) + _4514 + 256 len 32 * _4578]
                                if _4578 < 1:
                                    revert with 0, 17
                                if _4578 - 1 >= _4578:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4578 - 1) + (2 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4578 - 1) + (2 * ceil32(return_data.size)) + 256]:
                                    revert with 0, 17
                                mem[mem[64]] = (100 * 10^6 * mem[(32 * _4578 - 1) + (2 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4578 - 1) + (2 * ceil32(return_data.size)) + 256]) / 100 * 10^6
                            else:
                                mem[ceil32(return_data.size) + 160] = address(arg2)
                                mem[ceil32(return_data.size) + 192] = tokenAddress
                                mem[ceil32(return_data.size) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + 228] = arg3
                                mem[ceil32(return_data.size) + 260] = 64
                                mem[ceil32(return_data.size) + 292] = 2
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = ceil32(return_data.size) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4515 = mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < ceil32(return_data.size) + return_data.size + 224
                                _4579 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(2 * ceil32(return_data.size)) + 224] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4515 + (32 * _4579) + 32
                                mem[(2 * ceil32(return_data.size)) + 256 len 32 * _4579] = mem[ceil32(return_data.size) + _4515 + 256 len 32 * _4579]
                                if _4579 < 1:
                                    revert with 0, 17
                                if _4579 - 1 >= _4579:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4579 - 1) + (2 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4579 - 1) + (2 * ceil32(return_data.size)) + 256]:
                                    revert with 0, 17
                                mem[mem[64]] = (100 * 10^6 * mem[(32 * _4579 - 1) + (2 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4579 - 1) + (2 * ceil32(return_data.size)) + 256]) / 100 * 10^6
                        else:
                            mem[ceil32(return_data.size) + 128] = 3
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[ceil32(return_data.size) + 192] = ext_call.return_data[12 len 20]
                            if not arg1:
                                mem[ceil32(return_data.size) + 160] = tokenAddress
                                mem[ceil32(return_data.size) + 224] = address(arg2)
                                mem[(2 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 260] = arg3
                                mem[(2 * ceil32(return_data.size)) + 292] = 64
                                mem[(2 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = (2 * ceil32(return_data.size)) + 356
                                while idx < mem[ceil32(return_data.size) + 128]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, 64, mem[(2 * ceil32(return_data.size)) + 324 len (32 * mem[ceil32(return_data.size) + 128]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(2 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (4 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                _4512 = mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (2 * ceil32(return_data.size)) + return_data.size + 256
                                _4576 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                    revert with 0, 65
                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                mem[(4 * ceil32(return_data.size)) + 256] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                require return_data.size >= _4512 + (32 * _4576) + 32
                                mem[(4 * ceil32(return_data.size)) + 288 len 32 * _4576] = mem[(2 * ceil32(return_data.size)) + _4512 + 288 len 32 * _4576]
                                if _4576 < 1:
                                    revert with 0, 17
                                if _4576 - 1 >= _4576:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4576 - 1) + (4 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4576 - 1) + (4 * ceil32(return_data.size)) + 288]:
                                    revert with 0, 17
                                mem[mem[64]] = (100 * 10^6 * mem[(32 * _4576 - 1) + (4 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4576 - 1) + (4 * ceil32(return_data.size)) + 288]) / 100 * 10^6
                            else:
                                mem[ceil32(return_data.size) + 160] = address(arg2)
                                mem[ceil32(return_data.size) + 224] = tokenAddress
                                mem[(2 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 260] = arg3
                                mem[(2 * ceil32(return_data.size)) + 292] = 64
                                mem[(2 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = (2 * ceil32(return_data.size)) + 356
                                while idx < mem[ceil32(return_data.size) + 128]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, 64, mem[(2 * ceil32(return_data.size)) + 324 len (32 * mem[ceil32(return_data.size) + 128]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(2 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (4 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                _4513 = mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (2 * ceil32(return_data.size)) + return_data.size + 256
                                _4577 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                    revert with 0, 65
                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                mem[(4 * ceil32(return_data.size)) + 256] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                require return_data.size >= _4513 + (32 * _4577) + 32
                                mem[(4 * ceil32(return_data.size)) + 288 len 32 * _4577] = mem[(2 * ceil32(return_data.size)) + _4513 + 288 len 32 * _4577]
                                if _4577 < 1:
                                    revert with 0, 17
                                if _4577 - 1 >= _4577:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4577 - 1) + (4 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4577 - 1) + (4 * ceil32(return_data.size)) + 288]:
                                    revert with 0, 17
                                mem[mem[64]] = (100 * 10^6 * mem[(32 * _4577 - 1) + (4 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4577 - 1) + (4 * ceil32(return_data.size)) + 288]) / 100 * 10^6
                        return memory
                          from mem[64]
                           len 32
                    require calldata.size - 4 >= 96
                    require arg1 == address(arg1)
                    if msg.sender == tokenAddress:
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
                            mem[(2 * ceil32(return_data.size)) + 128] = 2
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                            mem[(2 * ceil32(return_data.size)) + 224] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
                            mem[(2 * ceil32(return_data.size)) + 228] = arg2
                            mem[(2 * ceil32(return_data.size)) + 260] = 128
                            mem[(2 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (2 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(2 * ceil32(return_data.size)) + 292] = address(arg1)
                            mem[(2 * ceil32(return_data.size)) + 324] = arg3
                            require ext_code.size(stor101)
                            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                               value msg.value wei
                                 gas gas_remaining wei
                                args arg2, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 388 len 64]), address(arg1), arg3
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _4509 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32
                            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                            _4573 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
                            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225
                            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
                            require return_data.size >= _4509 + (32 * _4573) + 32
                            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4573] = mem[(2 * ceil32(return_data.size)) + _4509 + 256 len 32 * _4573]
                            if 0 >= _4573:
                                revert with 0, 50
                            if mem[(4 * ceil32(return_data.size)) + 256] and sub_fd53fce0 > -1 / mem[(4 * ceil32(return_data.size)) + 256]:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value mem[(4 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.value < mem[(4 * ceil32(return_data.size)) + 256]:
                                revert with 0, 17
                            if msg.value - mem[(4 * ceil32(return_data.size)) + 256] < mem[(4 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6:
                                revert with 0, 17
                            call address(arg1) with:
                               value msg.value - mem[(4 * ceil32(return_data.size)) + 256] - (mem[(4 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6) wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = mem[(4 * ceil32(return_data.size)) + 256]
                        else:
                            mem[(2 * ceil32(return_data.size)) + 128] = 3
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                            mem[(4 * ceil32(return_data.size)) + 256] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 260] = arg2
                            mem[(4 * ceil32(return_data.size)) + 292] = 128
                            mem[(4 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (4 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 324] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 356] = arg3
                            require ext_code.size(stor101)
                            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                               value msg.value wei
                                 gas gas_remaining wei
                                args arg2, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg1), arg3
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 256
                            require return_data.size >= 32
                            _4508 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                            _4572 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 257
                            mem[(6 * ceil32(return_data.size)) + 256] = _4572
                            require return_data.size >= _4508 + (32 * _4572) + 32
                            mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4572] = mem[(4 * ceil32(return_data.size)) + _4508 + 288 len 32 * _4572]
                            if 0 >= _4572:
                                revert with 0, 50
                            if mem[(6 * ceil32(return_data.size)) + 288] and sub_fd53fce0 > -1 / mem[(6 * ceil32(return_data.size)) + 288]:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value mem[(6 * ceil32(return_data.size)) + 288] * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.value < mem[(6 * ceil32(return_data.size)) + 288]:
                                revert with 0, 17
                            if msg.value - mem[(6 * ceil32(return_data.size)) + 288] < mem[(6 * ceil32(return_data.size)) + 288] * sub_fd53fce0 / 100 * 10^6:
                                revert with 0, 17
                            call address(arg1) with:
                               value msg.value - mem[(6 * ceil32(return_data.size)) + 288] - (mem[(6 * ceil32(return_data.size)) + 288] * sub_fd53fce0 / 100 * 10^6) wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = mem[(6 * ceil32(return_data.size)) + 288]
                    else:
                        if address(sub_0584aecfAddress) != msg.sender:
                            revert with 0, 'Access Denied!'
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
                            mem[(2 * ceil32(return_data.size)) + 128] = 2
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                            mem[(2 * ceil32(return_data.size)) + 224] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
                            mem[(2 * ceil32(return_data.size)) + 228] = arg2
                            mem[(2 * ceil32(return_data.size)) + 260] = 128
                            mem[(2 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (2 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(2 * ceil32(return_data.size)) + 292] = address(arg1)
                            mem[(2 * ceil32(return_data.size)) + 324] = arg3
                            require ext_code.size(stor101)
                            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                               value msg.value wei
                                 gas gas_remaining wei
                                args arg2, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 388 len 64]), address(arg1), arg3
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _4511 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32
                            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                            _4575 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
                            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225
                            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
                            require return_data.size >= _4511 + (32 * _4575) + 32
                            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4575] = mem[(2 * ceil32(return_data.size)) + _4511 + 256 len 32 * _4575]
                            if 0 >= _4575:
                                revert with 0, 50
                            if mem[(4 * ceil32(return_data.size)) + 256] and sub_fd53fce0 > -1 / mem[(4 * ceil32(return_data.size)) + 256]:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value mem[(4 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.value < mem[(4 * ceil32(return_data.size)) + 256]:
                                revert with 0, 17
                            if msg.value - mem[(4 * ceil32(return_data.size)) + 256] < mem[(4 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6:
                                revert with 0, 17
                            call address(arg1) with:
                               value msg.value - mem[(4 * ceil32(return_data.size)) + 256] - (mem[(4 * ceil32(return_data.size)) + 256] * sub_fd53fce0 / 100 * 10^6) wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = mem[(4 * ceil32(return_data.size)) + 256]
                        else:
                            mem[(2 * ceil32(return_data.size)) + 128] = 3
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                            mem[(4 * ceil32(return_data.size)) + 256] = 0x8a657e6700000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 260] = arg2
                            mem[(4 * ceil32(return_data.size)) + 292] = 128
                            mem[(4 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (4 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 324] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 356] = arg3
                            require ext_code.size(stor101)
                            call stor101.swapAVAXForExactTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                               value msg.value wei
                                 gas gas_remaining wei
                                args arg2, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg1), arg3
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 256
                            require return_data.size >= 32
                            _4510 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                            _4574 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 257
                            mem[(6 * ceil32(return_data.size)) + 256] = _4574
                            require return_data.size >= _4510 + (32 * _4574) + 32
                            mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4574] = mem[(4 * ceil32(return_data.size)) + _4510 + 288 len 32 * _4574]
                            if 0 >= _4574:
                                revert with 0, 50
                            if mem[(6 * ceil32(return_data.size)) + 288] and sub_fd53fce0 > -1 / mem[(6 * ceil32(return_data.size)) + 288]:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value mem[(6 * ceil32(return_data.size)) + 288] * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.value < mem[(6 * ceil32(return_data.size)) + 288]:
                                revert with 0, 17
                            if msg.value - mem[(6 * ceil32(return_data.size)) + 288] < mem[(6 * ceil32(return_data.size)) + 288] * sub_fd53fce0 / 100 * 10^6:
                                revert with 0, 17
                            call address(arg1) with:
                               value msg.value - mem[(6 * ceil32(return_data.size)) + 288] - (mem[(6 * ceil32(return_data.size)) + 288] * sub_fd53fce0 / 100 * 10^6) wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = mem[(6 * ceil32(return_data.size)) + 288]
                    mem[mem[64] + 64] = arg2
                    emit 0xa979c0b1: mem[mem[64]], tokenAddress, arg2
            else:
                if uint32(call.func_hash) >> 224 != unknown_0x88e5249f(?????):
                    if unknown_0x8b83209b(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        if arg1 >= payee.length:
                            revert with 0, 50
                        return payee[arg1]
                    if uint32(call.func_hash) >> 224 != unknown_0x8f6e53b7(?????):
                        if unknown_0x9852595c(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            return released[address(arg1)]
                        if unknown_0x9d76ea58(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return tokenAddress
                        if uint32(call.func_hash) >> 224 != unknown_0xbd747678(?????):
                            require unknown_0xbf16f65a(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            if tokenAddress != msg.sender:
                                if address(sub_0584aecfAddress) != msg.sender:
                                    revert with 0, 'Access Denied!'
                            if arg1 > 100 * 10^6:
                                revert with 0, 'FEES: swap exceeding 100%'
                            sub_fd53fce0 = arg1
                        require not msg.value
                        require calldata.size - 4 >= 96
                        require arg1 == bool(arg1)
                        require arg2 == address(arg2)
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if address(arg2) == ext_call.return_data[12 len 20]:
                            mem[ceil32(return_data.size) + 128] = 2
                            if not arg1:
                                mem[ceil32(return_data.size) + 160] = tokenAddress
                                mem[ceil32(return_data.size) + 192] = address(arg2)
                                mem[ceil32(return_data.size) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + 228] = arg3
                                mem[ceil32(return_data.size) + 260] = 64
                                mem[ceil32(return_data.size) + 292] = 2
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = ceil32(return_data.size) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4494 = mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < ceil32(return_data.size) + return_data.size + 224
                                _4570 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(2 * ceil32(return_data.size)) + 224] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4494 + (32 * _4570) + 32
                                mem[(2 * ceil32(return_data.size)) + 256 len 32 * _4570] = mem[ceil32(return_data.size) + _4494 + 256 len 32 * _4570]
                                if 0 >= _4570:
                                    revert with 0, 50
                            else:
                                mem[ceil32(return_data.size) + 160] = address(arg2)
                                mem[ceil32(return_data.size) + 192] = tokenAddress
                                mem[ceil32(return_data.size) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + 228] = arg3
                                mem[ceil32(return_data.size) + 260] = 64
                                mem[ceil32(return_data.size) + 292] = 2
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = ceil32(return_data.size) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[ceil32(return_data.size) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4495 = mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < ceil32(return_data.size) + return_data.size + 224
                                _4571 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(2 * ceil32(return_data.size)) + 224] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4495 + (32 * _4571) + 32
                                mem[(2 * ceil32(return_data.size)) + 256 len 32 * _4571] = mem[ceil32(return_data.size) + _4495 + 256 len 32 * _4571]
                                if 0 >= _4571:
                                    revert with 0, 50
                            if 100 * 10^6 > !sub_fd53fce0:
                                revert with 0, 17
                            if mem[(2 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(2 * ceil32(return_data.size)) + 256]:
                                revert with 0, 17
                            mem[mem[64]] = (100 * 10^6 * mem[(2 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(2 * ceil32(return_data.size)) + 256]) / 100 * 10^6
                        else:
                            mem[ceil32(return_data.size) + 128] = 3
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[ceil32(return_data.size) + 256] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[ceil32(return_data.size) + 192] = ext_call.return_data[12 len 20]
                            if not arg1:
                                mem[ceil32(return_data.size) + 160] = tokenAddress
                                mem[ceil32(return_data.size) + 224] = address(arg2)
                                mem[(2 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 260] = arg3
                                mem[(2 * ceil32(return_data.size)) + 292] = 64
                                mem[(2 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = (2 * ceil32(return_data.size)) + 356
                                while idx < mem[ceil32(return_data.size) + 128]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, 64, mem[(2 * ceil32(return_data.size)) + 324 len (32 * mem[ceil32(return_data.size) + 128]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(2 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (4 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                _4492 = mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (2 * ceil32(return_data.size)) + return_data.size + 256
                                _4568 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                    revert with 0, 65
                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                mem[(4 * ceil32(return_data.size)) + 256] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                require return_data.size >= _4492 + (32 * _4568) + 32
                                mem[(4 * ceil32(return_data.size)) + 288 len 32 * _4568] = mem[(2 * ceil32(return_data.size)) + _4492 + 288 len 32 * _4568]
                                if 0 >= _4568:
                                    revert with 0, 50
                            else:
                                mem[ceil32(return_data.size) + 160] = address(arg2)
                                mem[ceil32(return_data.size) + 224] = tokenAddress
                                mem[(2 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 260] = arg3
                                mem[(2 * ceil32(return_data.size)) + 292] = 64
                                mem[(2 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = ceil32(return_data.size) + 160
                                t = (2 * ceil32(return_data.size)) + 356
                                while idx < mem[ceil32(return_data.size) + 128]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, 64, mem[(2 * ceil32(return_data.size)) + 324 len (32 * mem[ceil32(return_data.size) + 128]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(2 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (4 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                _4493 = mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (2 * ceil32(return_data.size)) + return_data.size + 256
                                _4569 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                    revert with 0, 65
                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                mem[(4 * ceil32(return_data.size)) + 256] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                require return_data.size >= _4493 + (32 * _4569) + 32
                                mem[(4 * ceil32(return_data.size)) + 288 len 32 * _4569] = mem[(2 * ceil32(return_data.size)) + _4493 + 288 len 32 * _4569]
                                if 0 >= _4569:
                                    revert with 0, 50
                            if 100 * 10^6 > !sub_fd53fce0:
                                revert with 0, 17
                            if mem[(4 * ceil32(return_data.size)) + 288] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 288]:
                                revert with 0, 17
                            mem[mem[64]] = (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 288]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 288]) / 100 * 10^6
                        return memory
                          from mem[64]
                           len 32
                    require calldata.size - 4 >= 96
                    require arg1 == address(arg1)
                    if msg.sender == tokenAddress:
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
                            mem[(2 * ceil32(return_data.size)) + 128] = 2
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                            mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(2 * ceil32(return_data.size)) + 228] = msg.value
                            mem[(2 * ceil32(return_data.size)) + 260] = 64
                            mem[(2 * ceil32(return_data.size)) + 292] = 2
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (2 * ceil32(return_data.size)) + 324
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(stor101)
                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args msg.value, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _4489 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32
                            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
                            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                            _4565 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
                            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225
                            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
                            require return_data.size >= _4489 + (32 * _4565) + 32
                            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4565] = mem[(2 * ceil32(return_data.size)) + _4489 + 256 len 32 * _4565]
                            if _4565 < 1:
                                revert with 0, 17
                            if _4565 - 1 >= _4565:
                                revert with 0, 50
                            if 100 * 10^6 < sub_fd53fce0:
                                revert with 0, 17
                            if mem[(32 * _4565 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4565 - 1) + (4 * ceil32(return_data.size)) + 256]:
                                revert with 0, 17
                            if (100 * 10^6 * mem[(32 * _4565 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4565 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg2:
                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                            if msg.value and sub_fd53fce0 > -1 / msg.value:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8217 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8253 = mem[_8217]
                            require mem[_8217] == mem[_8217 + 12 len 20]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8441 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8441] == mem[_8441 + 12 len 20]
                            if address(_8253) == mem[_8441 + 12 len 20]:
                                _8679 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_8679]:
                                    revert with 0, 50
                                mem[_8679 + 32] = address(_8253)
                                if 1 >= mem[_8679]:
                                    revert with 0, 50
                                mem[_8679 + 64] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8679 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8679 + 100] = arg2
                                mem[_8679 + 132] = 128
                                mem[_8679 + 228] = mem[_8679]
                                idx = 0
                                s = _8679 + 32
                                t = _8679 + 260
                                while idx < mem[_8679]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8679 + 164] = address(arg1)
                                mem[_8679 + 196] = arg3
                                require ext_code.size(stor101)
                                call stor101.mem[mem[64] len 4] with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _8679 + (32 * mem[_8679]) + -mem[64] + 256]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11023 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11127 = mem[_11023]
                                require mem[_11023] <= test266151307()
                                require _11023 + mem[_11023] + 31 < _11023 + return_data.size
                                _11231 = mem[_11023 + mem[_11023]]
                                if mem[_11023 + mem[_11023]] > test266151307():
                                    revert with 0, 65
                                if _11023 + ceil32(return_data.size) + ceil32(32 * mem[_11023 + mem[_11023]]) + 1 > test266151307() or ceil32(32 * mem[_11023 + mem[_11023]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _11023 + ceil32(return_data.size) + ceil32(32 * mem[_11023 + mem[_11023]]) + 1
                                mem[_11023 + ceil32(return_data.size)] = _11231
                                require return_data.size >= _11127 + (32 * _11231) + 32
                                mem[_11023 + ceil32(return_data.size) + 32 len 32 * _11231] = mem[_11023 + _11127 + 32 len 32 * _11231]
                                if _11231 < 1:
                                    revert with 0, 17
                                if _11231 - 1 >= _11231:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11231 - 1) + _11023 + ceil32(return_data.size) + 32]
                            else:
                                _8676 = mem[64]
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64] + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_8676]:
                                    revert with 0, 50
                                mem[_8676 + 64] = ext_call.return_data[12 len 20]
                                if 0 >= mem[_8676]:
                                    revert with 0, 50
                                mem[_8676 + 32] = address(_8253)
                                if 2 >= mem[_8676]:
                                    revert with 0, 50
                                mem[_8676 + 96] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8676 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8676 + ceil32(return_data.size) + 132] = arg2
                                mem[_8676 + ceil32(return_data.size) + 164] = 128
                                mem[_8676 + ceil32(return_data.size) + 260] = mem[_8676]
                                idx = 0
                                s = _8676 + 32
                                t = _8676 + ceil32(return_data.size) + 292
                                while idx < mem[_8676]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8676 + ceil32(return_data.size) + 196] = address(arg1)
                                mem[_8676 + ceil32(return_data.size) + 228] = arg3
                                require ext_code.size(stor101)
                                call stor101.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args arg2, 128, address(arg1), arg3, mem[_8676 + ceil32(return_data.size) + 260 len (32 * mem[_8676]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_8676 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = _8676 + (2 * ceil32(return_data.size)) + 128
                                require return_data.size >= 32
                                _11126 = mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32
                                require mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                                require _8676 + ceil32(return_data.size) + mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 159 < _8676 + ceil32(return_data.size) + return_data.size + 128
                                _11230 = mem[_8676 + ceil32(return_data.size) + mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                                if mem[_8676 + ceil32(return_data.size) + mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128] > test266151307():
                                    revert with 0, 65
                                if _8676 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8676 + ceil32(return_data.size) + mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8676 + ceil32(return_data.size) + mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _8676 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8676 + ceil32(return_data.size) + mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129
                                mem[_8676 + (2 * ceil32(return_data.size)) + 128] = mem[_8676 + ceil32(return_data.size) + mem[_8676 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                                require return_data.size >= _11126 + (32 * _11230) + 32
                                mem[_8676 + (2 * ceil32(return_data.size)) + 160 len 32 * _11230] = mem[_8676 + ceil32(return_data.size) + _11126 + 160 len 32 * _11230]
                                if _11230 < 1:
                                    revert with 0, 17
                                if _11230 - 1 >= _11230:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11230 - 1) + _8676 + (2 * ceil32(return_data.size)) + 160]
                        else:
                            mem[(2 * ceil32(return_data.size)) + 128] = 3
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                            mem[(4 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 260] = msg.value
                            mem[(4 * ceil32(return_data.size)) + 292] = 64
                            mem[(4 * ceil32(return_data.size)) + 324] = 3
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (4 * ceil32(return_data.size)) + 356
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(stor101)
                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args msg.value, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 256
                            require return_data.size >= 32
                            _4488 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                            _4564 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]) + 257
                            mem[(6 * ceil32(return_data.size)) + 256] = _4564
                            require return_data.size >= _4488 + (32 * _4564) + 32
                            mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4564] = mem[(4 * ceil32(return_data.size)) + _4488 + 288 len 32 * _4564]
                            if _4564 < 1:
                                revert with 0, 17
                            if _4564 - 1 >= _4564:
                                revert with 0, 50
                            if 100 * 10^6 < sub_fd53fce0:
                                revert with 0, 17
                            if mem[(32 * _4564 - 1) + (6 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4564 - 1) + (6 * ceil32(return_data.size)) + 288]:
                                revert with 0, 17
                            if (100 * 10^6 * mem[(32 * _4564 - 1) + (6 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4564 - 1) + (6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 < arg2:
                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                            if msg.value and sub_fd53fce0 > -1 / msg.value:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8216 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8252 = mem[_8216]
                            require mem[_8216] == mem[_8216 + 12 len 20]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8440 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8440] == mem[_8440 + 12 len 20]
                            if address(_8252) == mem[_8440 + 12 len 20]:
                                _8675 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_8675]:
                                    revert with 0, 50
                                mem[_8675 + 32] = address(_8252)
                                if 1 >= mem[_8675]:
                                    revert with 0, 50
                                mem[_8675 + 64] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8675 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8675 + 100] = arg2
                                mem[_8675 + 132] = 128
                                mem[_8675 + 228] = mem[_8675]
                                idx = 0
                                s = _8675 + 32
                                t = _8675 + 260
                                while idx < mem[_8675]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8675 + 164] = address(arg1)
                                mem[_8675 + 196] = arg3
                                require ext_code.size(stor101)
                                call stor101.mem[mem[64] len 4] with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _8675 + (32 * mem[_8675]) + -mem[64] + 256]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11021 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11125 = mem[_11021]
                                require mem[_11021] <= test266151307()
                                require _11021 + mem[_11021] + 31 < _11021 + return_data.size
                                _11229 = mem[_11021 + mem[_11021]]
                                if mem[_11021 + mem[_11021]] > test266151307():
                                    revert with 0, 65
                                if _11021 + ceil32(return_data.size) + ceil32(32 * mem[_11021 + mem[_11021]]) + 1 > test266151307() or ceil32(32 * mem[_11021 + mem[_11021]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _11021 + ceil32(return_data.size) + ceil32(32 * mem[_11021 + mem[_11021]]) + 1
                                mem[_11021 + ceil32(return_data.size)] = _11229
                                require return_data.size >= _11125 + (32 * _11229) + 32
                                mem[_11021 + ceil32(return_data.size) + 32 len 32 * _11229] = mem[_11021 + _11125 + 32 len 32 * _11229]
                                if _11229 < 1:
                                    revert with 0, 17
                                if _11229 - 1 >= _11229:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11229 - 1) + _11021 + ceil32(return_data.size) + 32]
                            else:
                                _8672 = mem[64]
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64] + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_8672]:
                                    revert with 0, 50
                                mem[_8672 + 64] = ext_call.return_data[12 len 20]
                                if 0 >= mem[_8672]:
                                    revert with 0, 50
                                mem[_8672 + 32] = address(_8252)
                                if 2 >= mem[_8672]:
                                    revert with 0, 50
                                mem[_8672 + 96] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8672 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8672 + ceil32(return_data.size) + 132] = arg2
                                mem[_8672 + ceil32(return_data.size) + 164] = 128
                                mem[_8672 + ceil32(return_data.size) + 260] = mem[_8672]
                                idx = 0
                                s = _8672 + 32
                                t = _8672 + ceil32(return_data.size) + 292
                                while idx < mem[_8672]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8672 + ceil32(return_data.size) + 196] = address(arg1)
                                mem[_8672 + ceil32(return_data.size) + 228] = arg3
                                require ext_code.size(stor101)
                                call stor101.swapExactAVAXForTokens(uint256 arg1, address[] arg2, address arg3, uint256 arg4) with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args arg2, 128, address(arg1), arg3, mem[_8672 + ceil32(return_data.size) + 260 len (32 * mem[_8672]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_8672 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = _8672 + (2 * ceil32(return_data.size)) + 128
                                require return_data.size >= 32
                                _11124 = mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32
                                require mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
                                require _8672 + ceil32(return_data.size) + mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 159 < _8672 + ceil32(return_data.size) + return_data.size + 128
                                _11228 = mem[_8672 + ceil32(return_data.size) + mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                                if mem[_8672 + ceil32(return_data.size) + mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128] > test266151307():
                                    revert with 0, 65
                                if _8672 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8672 + ceil32(return_data.size) + mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8672 + ceil32(return_data.size) + mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _8672 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8672 + ceil32(return_data.size) + mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]) + 129
                                mem[_8672 + (2 * ceil32(return_data.size)) + 128] = mem[_8672 + ceil32(return_data.size) + mem[_8672 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg2) >> 32 + 128]
                                require return_data.size >= _11124 + (32 * _11228) + 32
                                mem[_8672 + (2 * ceil32(return_data.size)) + 160 len 32 * _11228] = mem[_8672 + ceil32(return_data.size) + _11124 + 160 len 32 * _11228]
                                if _11228 < 1:
                                    revert with 0, 17
                                if _11228 - 1 >= _11228:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11228 - 1) + _8672 + (2 * ceil32(return_data.size)) + 160]
                    else:
                        if address(sub_0584aecfAddress) != msg.sender:
                            revert with 0, 'Access Denied!'
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        if address(ext_call.return_data[0]) == ext_call.return_data[12 len 20]:
                            mem[(2 * ceil32(return_data.size)) + 128] = 2
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                            mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(2 * ceil32(return_data.size)) + 228] = msg.value
                            mem[(2 * ceil32(return_data.size)) + 260] = 64
                            mem[(2 * ceil32(return_data.size)) + 292] = 2
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (2 * ceil32(return_data.size)) + 324
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(stor101)
                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args msg.value, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _4491 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32
                            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
                            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                            _4567 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
                            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]) + 225
                            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, msg.value) >> 32 + 224]
                            require return_data.size >= _4491 + (32 * _4567) + 32
                            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4567] = mem[(2 * ceil32(return_data.size)) + _4491 + 256 len 32 * _4567]
                            if _4567 < 1:
                                revert with 0, 17
                            if _4567 - 1 >= _4567:
                                revert with 0, 50
                            if 100 * 10^6 < sub_fd53fce0:
                                revert with 0, 17
                            if mem[(32 * _4567 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4567 - 1) + (4 * ceil32(return_data.size)) + 256]:
                                revert with 0, 17
                            if (100 * 10^6 * mem[(32 * _4567 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4567 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg2:
                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                            if msg.value and sub_fd53fce0 > -1 / msg.value:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8219 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8255 = mem[_8219]
                            require mem[_8219] == mem[_8219 + 12 len 20]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8443 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8443] == mem[_8443 + 12 len 20]
                            if address(_8255) == mem[_8443 + 12 len 20]:
                                _8687 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_8687]:
                                    revert with 0, 50
                                mem[_8687 + 32] = address(_8255)
                                if 1 >= mem[_8687]:
                                    revert with 0, 50
                                mem[_8687 + 64] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8687 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8687 + 100] = arg2
                                mem[_8687 + 132] = 128
                                mem[_8687 + 228] = mem[_8687]
                                idx = 0
                                s = _8687 + 32
                                t = _8687 + 260
                                while idx < mem[_8687]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8687 + 164] = address(arg1)
                                mem[_8687 + 196] = arg3
                                require ext_code.size(stor101)
                                call stor101.mem[mem[64] len 4] with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _8687 + (32 * mem[_8687]) + -mem[64] + 256]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11027 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11131 = mem[_11027]
                                require mem[_11027] <= test266151307()
                                require _11027 + mem[_11027] + 31 < _11027 + return_data.size
                                _11235 = mem[_11027 + mem[_11027]]
                                if mem[_11027 + mem[_11027]] > test266151307():
                                    revert with 0, 65
                                if _11027 + ceil32(return_data.size) + ceil32(32 * mem[_11027 + mem[_11027]]) + 1 > test266151307() or ceil32(32 * mem[_11027 + mem[_11027]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _11027 + ceil32(return_data.size) + ceil32(32 * mem[_11027 + mem[_11027]]) + 1
                                mem[_11027 + ceil32(return_data.size)] = _11235
                                require return_data.size >= _11131 + (32 * _11235) + 32
                                mem[_11027 + ceil32(return_data.size) + 32 len 32 * _11235] = mem[_11027 + _11131 + 32 len 32 * _11235]
                                if _11235 < 1:
                                    revert with 0, 17
                                if _11235 - 1 >= _11235:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11235 - 1) + _11027 + ceil32(return_data.size) + 32]
                            else:
                                _8684 = mem[64]
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64] + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_8684]:
                                    revert with 0, 50
                                mem[_8684 + 64] = ext_call.return_data[12 len 20]
                                if 0 >= mem[_8684]:
                                    revert with 0, 50
                                mem[_8684 + 32] = address(_8255)
                                if 2 >= mem[_8684]:
                                    revert with 0, 50
                                mem[_8684 + 96] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8684 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8684 + ceil32(return_data.size) + 132] = arg2
                                mem[_8684 + ceil32(return_data.size) + 164] = 128
                                mem[_8684 + ceil32(return_data.size) + 260] = mem[_8684]
                                idx = 0
                                s = _8684 + 32
                                t = _8684 + ceil32(return_data.size) + 292
                                while idx < mem[_8684]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8684 + ceil32(return_data.size) + 196] = address(arg1)
                                mem[_8684 + ceil32(return_data.size) + 228] = arg3
                                require ext_code.size(stor101)
                                call stor101.mem[mem[64] len 4] with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _8684 + ceil32(return_data.size) + (32 * mem[_8684]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11026 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11130 = mem[_11026]
                                require mem[_11026] <= test266151307()
                                require _11026 + mem[_11026] + 31 < _11026 + return_data.size
                                _11234 = mem[_11026 + mem[_11026]]
                                if mem[_11026 + mem[_11026]] > test266151307():
                                    revert with 0, 65
                                if _11026 + ceil32(return_data.size) + ceil32(32 * mem[_11026 + mem[_11026]]) + 1 > test266151307() or ceil32(32 * mem[_11026 + mem[_11026]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _11026 + ceil32(return_data.size) + ceil32(32 * mem[_11026 + mem[_11026]]) + 1
                                mem[_11026 + ceil32(return_data.size)] = _11234
                                require return_data.size >= _11130 + (32 * _11234) + 32
                                mem[_11026 + ceil32(return_data.size) + 32 len 32 * _11234] = mem[_11026 + _11130 + 32 len 32 * _11234]
                                if _11234 < 1:
                                    revert with 0, 17
                                if _11234 - 1 >= _11234:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11234 - 1) + _11026 + ceil32(return_data.size) + 32]
                        else:
                            mem[(2 * ceil32(return_data.size)) + 128] = 3
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                            mem[(2 * ceil32(return_data.size)) + 160] = address(ext_call.return_data[0])
                            mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                            mem[(4 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 260] = msg.value
                            mem[(4 * ceil32(return_data.size)) + 292] = 64
                            mem[(4 * ceil32(return_data.size)) + 324] = 3
                            idx = 0
                            s = (2 * ceil32(return_data.size)) + 160
                            t = (4 * ceil32(return_data.size)) + 356
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(stor101)
                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args msg.value, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 256
                            require return_data.size >= 32
                            _4490 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                            _4566 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, msg.value) >> 32 + 256]) + 257
                            mem[(6 * ceil32(return_data.size)) + 256] = _4566
                            require return_data.size >= _4490 + (32 * _4566) + 32
                            mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4566] = mem[(4 * ceil32(return_data.size)) + _4490 + 288 len 32 * _4566]
                            if _4566 < 1:
                                revert with 0, 17
                            if _4566 - 1 >= _4566:
                                revert with 0, 50
                            if 100 * 10^6 < sub_fd53fce0:
                                revert with 0, 17
                            if mem[(32 * _4566 - 1) + (6 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4566 - 1) + (6 * ceil32(return_data.size)) + 288]:
                                revert with 0, 17
                            if (100 * 10^6 * mem[(32 * _4566 - 1) + (6 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4566 - 1) + (6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 < arg2:
                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                            if msg.value and sub_fd53fce0 > -1 / msg.value:
                                revert with 0, 17
                            call sub_11eb47dcAddress with:
                               value msg.value * sub_fd53fce0 / 100 * 10^6 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8218 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _8254 = mem[_8218]
                            require mem[_8218] == mem[_8218 + 12 len 20]
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8442 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8442] == mem[_8442 + 12 len 20]
                            if address(_8254) == mem[_8442 + 12 len 20]:
                                _8683 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_8683]:
                                    revert with 0, 50
                                mem[_8683 + 32] = address(_8254)
                                if 1 >= mem[_8683]:
                                    revert with 0, 50
                                mem[_8683 + 64] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8683 + 96] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8683 + 100] = arg2
                                mem[_8683 + 132] = 128
                                mem[_8683 + 228] = mem[_8683]
                                idx = 0
                                s = _8683 + 32
                                t = _8683 + 260
                                while idx < mem[_8683]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8683 + 164] = address(arg1)
                                mem[_8683 + 196] = arg3
                                require ext_code.size(stor101)
                                call stor101.mem[mem[64] len 4] with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _8683 + (32 * mem[_8683]) + -mem[64] + 256]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11025 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11129 = mem[_11025]
                                require mem[_11025] <= test266151307()
                                require _11025 + mem[_11025] + 31 < _11025 + return_data.size
                                _11233 = mem[_11025 + mem[_11025]]
                                if mem[_11025 + mem[_11025]] > test266151307():
                                    revert with 0, 65
                                if _11025 + ceil32(return_data.size) + ceil32(32 * mem[_11025 + mem[_11025]]) + 1 > test266151307() or ceil32(32 * mem[_11025 + mem[_11025]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _11025 + ceil32(return_data.size) + ceil32(32 * mem[_11025 + mem[_11025]]) + 1
                                mem[_11025 + ceil32(return_data.size)] = _11233
                                require return_data.size >= _11129 + (32 * _11233) + 32
                                mem[_11025 + ceil32(return_data.size) + 32 len 32 * _11233] = mem[_11025 + _11129 + 32 len 32 * _11233]
                                if _11233 < 1:
                                    revert with 0, 17
                                if _11233 - 1 >= _11233:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11233 - 1) + _11025 + ceil32(return_data.size) + 32]
                            else:
                                _8680 = mem[64]
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64] + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                if 1 >= mem[_8680]:
                                    revert with 0, 50
                                mem[_8680 + 64] = ext_call.return_data[12 len 20]
                                if 0 >= mem[_8680]:
                                    revert with 0, 50
                                mem[_8680 + 32] = address(_8254)
                                if 2 >= mem[_8680]:
                                    revert with 0, 50
                                mem[_8680 + 96] = tokenAddress
                                if msg.value < msg.value * sub_fd53fce0 / 100 * 10^6:
                                    revert with 0, 17
                                mem[_8680 + ceil32(return_data.size) + 128] = 0xa2a1623d00000000000000000000000000000000000000000000000000000000
                                mem[_8680 + ceil32(return_data.size) + 132] = arg2
                                mem[_8680 + ceil32(return_data.size) + 164] = 128
                                mem[_8680 + ceil32(return_data.size) + 260] = mem[_8680]
                                idx = 0
                                s = _8680 + 32
                                t = _8680 + ceil32(return_data.size) + 292
                                while idx < mem[_8680]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[_8680 + ceil32(return_data.size) + 196] = address(arg1)
                                mem[_8680 + ceil32(return_data.size) + 228] = arg3
                                require ext_code.size(stor101)
                                call stor101.mem[mem[64] len 4] with:
                                   value msg.value - (msg.value * sub_fd53fce0 / 100 * 10^6) wei
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _8680 + ceil32(return_data.size) + (32 * mem[_8680]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _11024 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _11128 = mem[_11024]
                                require mem[_11024] <= test266151307()
                                require _11024 + mem[_11024] + 31 < _11024 + return_data.size
                                _11232 = mem[_11024 + mem[_11024]]
                                if mem[_11024 + mem[_11024]] > test266151307():
                                    revert with 0, 65
                                if _11024 + ceil32(return_data.size) + ceil32(32 * mem[_11024 + mem[_11024]]) + 1 > test266151307() or ceil32(32 * mem[_11024 + mem[_11024]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _11024 + ceil32(return_data.size) + ceil32(32 * mem[_11024 + mem[_11024]]) + 1
                                mem[_11024 + ceil32(return_data.size)] = _11232
                                require return_data.size >= _11128 + (32 * _11232) + 32
                                mem[_11024 + ceil32(return_data.size) + 32 len 32 * _11232] = mem[_11024 + _11128 + 32 len 32 * _11232]
                                if _11232 < 1:
                                    revert with 0, 17
                                if _11232 - 1 >= _11232:
                                    revert with 0, 50
                                emit 0xa979c0b1: msg.value, tokenAddress, mem[(32 * _11232 - 1) + _11024 + ceil32(return_data.size) + 32]
                else:
                    require not msg.value
                    require calldata.size - 4 >= 160
                    require arg1 == address(arg1)
                    require arg2 == address(arg2)
                    if msg.sender == tokenAddress:
                        mem[132] = this.address
                        mem[164] = routerAddress
                        require ext_code.size(stor105)
                        staticcall stor105.allowance(address arg1, address arg2) with:
                                gas gas_remaining wei
                               args address(this.address), routerAddress
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] >= arg3:
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if address(arg2) == ext_call.return_data[12 len 20]:
                                mem[(2 * ceil32(return_data.size)) + 128] = 2
                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                mem[(2 * ceil32(return_data.size)) + 260] = 64
                                mem[(2 * ceil32(return_data.size)) + 292] = 2
                                idx = 0
                                s = (2 * ceil32(return_data.size)) + 160
                                t = (2 * ceil32(return_data.size)) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (4 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4481 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                _4557 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4481 + (32 * _4557) + 32
                                mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4557] = mem[(2 * ceil32(return_data.size)) + _4481 + 256 len 32 * _4557]
                                if _4557 < 1:
                                    revert with 0, 17
                                if _4557 - 1 >= _4557:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4557 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4557 - 1) + (4 * ceil32(return_data.size)) + 256]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4557 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4557 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8209 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8209] == bool(mem[_8209])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8417 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8417] == mem[_8417 + 12 len 20]
                                if address(arg2) == mem[_8417 + 12 len 20]:
                                    _8623 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8623]:
                                        revert with 0, 50
                                    mem[_8623 + 32] = tokenAddress
                                    if 1 >= mem[_8623]:
                                        revert with 0, 50
                                    mem[_8623 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8623 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8623 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8623 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8623 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8623 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8623 + ceil32(return_data.size) + 164] = 160
                                        mem[_8623 + ceil32(return_data.size) + 260] = mem[_8623]
                                        idx = 0
                                        s = _8623 + 32
                                        t = _8623 + ceil32(return_data.size) + 292
                                        while idx < mem[_8623]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8623 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8623 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8623 + ceil32(return_data.size) + 260 len (32 * mem[_8623]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8623 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8623 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11098 = mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8623 + ceil32(return_data.size) + return_data.size + 96
                                        _11202 = mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8623 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8623 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8623 + (2 * ceil32(return_data.size)) + 96] = mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11098 + (32 * _11202) + 32
                                        mem[_8623 + (2 * ceil32(return_data.size)) + 128 len 32 * _11202] = mem[_8623 + ceil32(return_data.size) + _11098 + 128 len 32 * _11202]
                                        if _11202 < 1:
                                            revert with 0, 17
                                        if _11202 - 1 >= _11202:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11202 - 1) + _8623 + (2 * ceil32(return_data.size)) + 128]
                                    else:
                                        mem[_8623 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8623 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8623 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8623 + ceil32(return_data.size) + 164] = 160
                                        mem[_8623 + ceil32(return_data.size) + 260] = mem[_8623]
                                        idx = 0
                                        s = _8623 + 32
                                        t = _8623 + ceil32(return_data.size) + 292
                                        while idx < mem[_8623]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8623 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8623 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8623 + ceil32(return_data.size) + 260 len (32 * mem[_8623]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8623 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8623 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11099 = mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8623 + ceil32(return_data.size) + return_data.size + 96
                                        _11203 = mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8623 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8623 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8623 + (2 * ceil32(return_data.size)) + 96] = mem[_8623 + ceil32(return_data.size) + mem[_8623 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11099 + (32 * _11203) + 32
                                        mem[_8623 + (2 * ceil32(return_data.size)) + 128 len 32 * _11203] = mem[_8623 + ceil32(return_data.size) + _11099 + 128 len 32 * _11203]
                                        if _11203 < 1:
                                            revert with 0, 17
                                        if _11203 - 1 >= _11203:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11203 - 1) + _8623 + (2 * ceil32(return_data.size)) + 128]
                                else:
                                    _8620 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8620]:
                                        revert with 0, 50
                                    mem[_8620 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8620]:
                                        revert with 0, 50
                                    mem[_8620 + 32] = tokenAddress
                                    if 2 >= mem[_8620]:
                                        revert with 0, 50
                                    mem[_8620 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8620 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8620 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 292] = mem[_8620]
                                        idx = 0
                                        s = _8620 + 32
                                        t = _8620 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8620]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8620 + (2 * ceil32(return_data.size)) + (32 * mem[_8620]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10992 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11096 = mem[_10992]
                                        require mem[_10992] <= test266151307()
                                        require _10992 + mem[_10992] + 31 < _10992 + return_data.size
                                        _11200 = mem[_10992 + mem[_10992]]
                                        if mem[_10992 + mem[_10992]] > test266151307():
                                            revert with 0, 65
                                        if _10992 + ceil32(return_data.size) + ceil32(32 * mem[_10992 + mem[_10992]]) + 1 > test266151307() or ceil32(32 * mem[_10992 + mem[_10992]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _10992 + ceil32(return_data.size) + ceil32(32 * mem[_10992 + mem[_10992]]) + 1
                                        mem[_10992 + ceil32(return_data.size)] = _11200
                                        require return_data.size >= _11096 + (32 * _11200) + 32
                                        mem[_10992 + ceil32(return_data.size) + 32 len 32 * _11200] = mem[_10992 + _11096 + 32 len 32 * _11200]
                                        if _11200 < 1:
                                            revert with 0, 17
                                        if _11200 - 1 >= _11200:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11200 - 1) + _10992 + ceil32(return_data.size) + 32]
                                    else:
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 292] = mem[_8620]
                                        idx = 0
                                        s = _8620 + 32
                                        t = _8620 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8620]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8620 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8620 + (2 * ceil32(return_data.size)) + (32 * mem[_8620]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10993 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11097 = mem[_10993]
                                        require mem[_10993] <= test266151307()
                                        require _10993 + mem[_10993] + 31 < _10993 + return_data.size
                                        _11201 = mem[_10993 + mem[_10993]]
                                        if mem[_10993 + mem[_10993]] > test266151307():
                                            revert with 0, 65
                                        if _10993 + ceil32(return_data.size) + ceil32(32 * mem[_10993 + mem[_10993]]) + 1 > test266151307() or ceil32(32 * mem[_10993 + mem[_10993]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _10993 + ceil32(return_data.size) + ceil32(32 * mem[_10993 + mem[_10993]]) + 1
                                        mem[_10993 + ceil32(return_data.size)] = _11201
                                        require return_data.size >= _11097 + (32 * _11201) + 32
                                        mem[_10993 + ceil32(return_data.size) + 32 len 32 * _11201] = mem[_10993 + _11097 + 32 len 32 * _11201]
                                        if _11201 < 1:
                                            revert with 0, 17
                                        if _11201 - 1 >= _11201:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11201 - 1) + _10993 + ceil32(return_data.size) + 32]
                            else:
                                mem[(2 * ceil32(return_data.size)) + 128] = 3
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(2 * ceil32(return_data.size)) + 224] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                mem[(4 * ceil32(return_data.size)) + 292] = 64
                                mem[(4 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = (2 * ceil32(return_data.size)) + 160
                                t = (4 * ceil32(return_data.size)) + 356
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                _4480 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                _4556 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                mem[(6 * ceil32(return_data.size)) + 256] = _4556
                                require return_data.size >= _4480 + (32 * _4556) + 32
                                mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4556] = mem[(4 * ceil32(return_data.size)) + _4480 + 288 len 32 * _4556]
                                if _4556 < 1:
                                    revert with 0, 17
                                if _4556 - 1 >= _4556:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4556 - 1) + (6 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4556 - 1) + (6 * ceil32(return_data.size)) + 288]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4556 - 1) + (6 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4556 - 1) + (6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8208 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8208] == bool(mem[_8208])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8416 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8416] == mem[_8416 + 12 len 20]
                                if address(arg2) == mem[_8416 + 12 len 20]:
                                    _8619 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8619]:
                                        revert with 0, 50
                                    mem[_8619 + 32] = tokenAddress
                                    if 1 >= mem[_8619]:
                                        revert with 0, 50
                                    mem[_8619 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8619 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8619 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8619 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8619 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8619 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8619 + ceil32(return_data.size) + 164] = 160
                                        mem[_8619 + ceil32(return_data.size) + 260] = mem[_8619]
                                        idx = 0
                                        s = _8619 + 32
                                        t = _8619 + ceil32(return_data.size) + 292
                                        while idx < mem[_8619]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8619 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8619 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8619 + ceil32(return_data.size) + 260 len (32 * mem[_8619]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8619 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8619 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11094 = mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8619 + ceil32(return_data.size) + return_data.size + 96
                                        _11198 = mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8619 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8619 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8619 + (2 * ceil32(return_data.size)) + 96] = mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11094 + (32 * _11198) + 32
                                        mem[_8619 + (2 * ceil32(return_data.size)) + 128 len 32 * _11198] = mem[_8619 + ceil32(return_data.size) + _11094 + 128 len 32 * _11198]
                                        if _11198 < 1:
                                            revert with 0, 17
                                        if _11198 - 1 >= _11198:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11198 - 1) + _8619 + (2 * ceil32(return_data.size)) + 128]
                                    else:
                                        mem[_8619 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8619 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8619 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8619 + ceil32(return_data.size) + 164] = 160
                                        mem[_8619 + ceil32(return_data.size) + 260] = mem[_8619]
                                        idx = 0
                                        s = _8619 + 32
                                        t = _8619 + ceil32(return_data.size) + 292
                                        while idx < mem[_8619]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8619 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8619 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8619 + ceil32(return_data.size) + 260 len (32 * mem[_8619]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8619 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8619 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11095 = mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8619 + ceil32(return_data.size) + return_data.size + 96
                                        _11199 = mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8619 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8619 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8619 + (2 * ceil32(return_data.size)) + 96] = mem[_8619 + ceil32(return_data.size) + mem[_8619 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11095 + (32 * _11199) + 32
                                        mem[_8619 + (2 * ceil32(return_data.size)) + 128 len 32 * _11199] = mem[_8619 + ceil32(return_data.size) + _11095 + 128 len 32 * _11199]
                                        if _11199 < 1:
                                            revert with 0, 17
                                        if _11199 - 1 >= _11199:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11199 - 1) + _8619 + (2 * ceil32(return_data.size)) + 128]
                                else:
                                    _8616 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8616]:
                                        revert with 0, 50
                                    mem[_8616 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8616]:
                                        revert with 0, 50
                                    mem[_8616 + 32] = tokenAddress
                                    if 2 >= mem[_8616]:
                                        revert with 0, 50
                                    mem[_8616 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8616 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8616 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 292] = mem[_8616]
                                        idx = 0
                                        s = _8616 + 32
                                        t = _8616 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8616]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8616 + (2 * ceil32(return_data.size)) + (32 * mem[_8616]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10988 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11092 = mem[_10988]
                                        require mem[_10988] <= test266151307()
                                        require _10988 + mem[_10988] + 31 < _10988 + return_data.size
                                        _11196 = mem[_10988 + mem[_10988]]
                                        if mem[_10988 + mem[_10988]] > test266151307():
                                            revert with 0, 65
                                        if _10988 + ceil32(return_data.size) + ceil32(32 * mem[_10988 + mem[_10988]]) + 1 > test266151307() or ceil32(32 * mem[_10988 + mem[_10988]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _10988 + ceil32(return_data.size) + ceil32(32 * mem[_10988 + mem[_10988]]) + 1
                                        mem[_10988 + ceil32(return_data.size)] = _11196
                                        require return_data.size >= _11092 + (32 * _11196) + 32
                                        mem[_10988 + ceil32(return_data.size) + 32 len 32 * _11196] = mem[_10988 + _11092 + 32 len 32 * _11196]
                                        if _11196 < 1:
                                            revert with 0, 17
                                        if _11196 - 1 >= _11196:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11196 - 1) + _10988 + ceil32(return_data.size) + 32]
                                    else:
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 292] = mem[_8616]
                                        idx = 0
                                        s = _8616 + 32
                                        t = _8616 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8616]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8616 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8616 + (2 * ceil32(return_data.size)) + (32 * mem[_8616]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _10989 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11093 = mem[_10989]
                                        require mem[_10989] <= test266151307()
                                        require _10989 + mem[_10989] + 31 < _10989 + return_data.size
                                        _11197 = mem[_10989 + mem[_10989]]
                                        if mem[_10989 + mem[_10989]] > test266151307():
                                            revert with 0, 65
                                        if _10989 + ceil32(return_data.size) + ceil32(32 * mem[_10989 + mem[_10989]]) + 1 > test266151307() or ceil32(32 * mem[_10989 + mem[_10989]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _10989 + ceil32(return_data.size) + ceil32(32 * mem[_10989 + mem[_10989]]) + 1
                                        mem[_10989 + ceil32(return_data.size)] = _11197
                                        require return_data.size >= _11093 + (32 * _11197) + 32
                                        mem[_10989 + ceil32(return_data.size) + 32 len 32 * _11197] = mem[_10989 + _11093 + 32 len 32 * _11197]
                                        if _11197 < 1:
                                            revert with 0, 17
                                        if _11197 - 1 >= _11197:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11197 - 1) + _10989 + ceil32(return_data.size) + 32]
                        else:
                            mem[ceil32(return_data.size) + 132] = routerAddress
                            mem[ceil32(return_data.size) + 164] = arg3
                            require ext_code.size(stor105)
                            call stor105.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, arg3
                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if address(arg2) == ext_call.return_data[12 len 20]:
                                mem[(4 * ceil32(return_data.size)) + 128] = 2
                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                mem[(4 * ceil32(return_data.size)) + 260] = 64
                                mem[(4 * ceil32(return_data.size)) + 292] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 160
                                t = (4 * ceil32(return_data.size)) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4483 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                _4559 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4483 + (32 * _4559) + 32
                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4559] = mem[(4 * ceil32(return_data.size)) + _4483 + 256 len 32 * _4559]
                                if _4559 < 1:
                                    revert with 0, 17
                                if _4559 - 1 >= _4559:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4559 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4559 - 1) + (6 * ceil32(return_data.size)) + 256]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4559 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4559 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8211 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8211] == bool(mem[_8211])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8419 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8419] == mem[_8419 + 12 len 20]
                                if address(arg2) == mem[_8419 + 12 len 20]:
                                    _8631 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8631]:
                                        revert with 0, 50
                                    mem[_8631 + 32] = tokenAddress
                                    if 1 >= mem[_8631]:
                                        revert with 0, 50
                                    mem[_8631 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8631 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8631 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8631 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8631 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8631 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8631 + ceil32(return_data.size) + 164] = 160
                                        mem[_8631 + ceil32(return_data.size) + 260] = mem[_8631]
                                        idx = 0
                                        s = _8631 + 32
                                        t = _8631 + ceil32(return_data.size) + 292
                                        while idx < mem[_8631]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8631 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8631 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8631 + ceil32(return_data.size) + (32 * mem[_8631]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11002 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11106 = mem[_11002]
                                        require mem[_11002] <= test266151307()
                                        require _11002 + mem[_11002] + 31 < _11002 + return_data.size
                                        _11210 = mem[_11002 + mem[_11002]]
                                        if mem[_11002 + mem[_11002]] > test266151307():
                                            revert with 0, 65
                                        if _11002 + ceil32(return_data.size) + ceil32(32 * mem[_11002 + mem[_11002]]) + 1 > test266151307() or ceil32(32 * mem[_11002 + mem[_11002]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _11002 + ceil32(return_data.size) + ceil32(32 * mem[_11002 + mem[_11002]]) + 1
                                        mem[_11002 + ceil32(return_data.size)] = _11210
                                        require return_data.size >= _11106 + (32 * _11210) + 32
                                        mem[_11002 + ceil32(return_data.size) + 32 len 32 * _11210] = mem[_11002 + _11106 + 32 len 32 * _11210]
                                        if _11210 < 1:
                                            revert with 0, 17
                                        if _11210 - 1 >= _11210:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11210 - 1) + _11002 + ceil32(return_data.size) + 32]
                                    else:
                                        mem[_8631 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8631 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8631 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8631 + ceil32(return_data.size) + 164] = 160
                                        mem[_8631 + ceil32(return_data.size) + 260] = mem[_8631]
                                        idx = 0
                                        s = _8631 + 32
                                        t = _8631 + ceil32(return_data.size) + 292
                                        while idx < mem[_8631]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8631 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8631 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8631 + ceil32(return_data.size) + (32 * mem[_8631]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11003 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11107 = mem[_11003]
                                        require mem[_11003] <= test266151307()
                                        require _11003 + mem[_11003] + 31 < _11003 + return_data.size
                                        _11211 = mem[_11003 + mem[_11003]]
                                        if mem[_11003 + mem[_11003]] > test266151307():
                                            revert with 0, 65
                                        if _11003 + ceil32(return_data.size) + ceil32(32 * mem[_11003 + mem[_11003]]) + 1 > test266151307() or ceil32(32 * mem[_11003 + mem[_11003]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _11003 + ceil32(return_data.size) + ceil32(32 * mem[_11003 + mem[_11003]]) + 1
                                        mem[_11003 + ceil32(return_data.size)] = _11211
                                        require return_data.size >= _11107 + (32 * _11211) + 32
                                        mem[_11003 + ceil32(return_data.size) + 32 len 32 * _11211] = mem[_11003 + _11107 + 32 len 32 * _11211]
                                        if _11211 < 1:
                                            revert with 0, 17
                                        if _11211 - 1 >= _11211:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11211 - 1) + _11003 + ceil32(return_data.size) + 32]
                                else:
                                    _8628 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8628]:
                                        revert with 0, 50
                                    mem[_8628 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8628]:
                                        revert with 0, 50
                                    mem[_8628 + 32] = tokenAddress
                                    if 2 >= mem[_8628]:
                                        revert with 0, 50
                                    mem[_8628 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8628 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8628 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 292] = mem[_8628]
                                        idx = 0
                                        s = _8628 + 32
                                        t = _8628 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8628]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8628 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8628]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8628 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11104 = mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8628 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11208 = mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8628 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8628 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                                        mem[_8628 + (4 * ceil32(return_data.size)) + 128] = mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11104 + (32 * _11208) + 32
                                        mem[_8628 + (4 * ceil32(return_data.size)) + 160 len 32 * _11208] = mem[_8628 + (2 * ceil32(return_data.size)) + _11104 + 160 len 32 * _11208]
                                        if _11208 < 1:
                                            revert with 0, 17
                                        if _11208 - 1 >= _11208:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11208 - 1) + _8628 + (4 * ceil32(return_data.size)) + 160]
                                    else:
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 292] = mem[_8628]
                                        idx = 0
                                        s = _8628 + 32
                                        t = _8628 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8628]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8628 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8628]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8628 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8628 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11105 = mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8628 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11209 = mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8628 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8628 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                                        mem[_8628 + (4 * ceil32(return_data.size)) + 128] = mem[_8628 + (2 * ceil32(return_data.size)) + mem[_8628 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11105 + (32 * _11209) + 32
                                        mem[_8628 + (4 * ceil32(return_data.size)) + 160 len 32 * _11209] = mem[_8628 + (2 * ceil32(return_data.size)) + _11105 + 160 len 32 * _11209]
                                        if _11209 < 1:
                                            revert with 0, 17
                                        if _11209 - 1 >= _11209:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11209 - 1) + _8628 + (4 * ceil32(return_data.size)) + 160]
                            else:
                                mem[(4 * ceil32(return_data.size)) + 128] = 3
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(4 * ceil32(return_data.size)) + 224] = address(arg2)
                                mem[(6 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                mem[(6 * ceil32(return_data.size)) + 292] = 64
                                mem[(6 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 160
                                t = (6 * ceil32(return_data.size)) + 356
                                while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4418 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4482 = mem[_4418]
                                require mem[_4418] <= test266151307()
                                require _4418 + mem[_4418] + 31 < _4418 + return_data.size
                                _4558 = mem[_4418 + mem[_4418]]
                                if mem[_4418 + mem[_4418]] > test266151307():
                                    revert with 0, 65
                                if _4418 + ceil32(return_data.size) + ceil32(32 * mem[_4418 + mem[_4418]]) + 1 > test266151307() or ceil32(32 * mem[_4418 + mem[_4418]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _4418 + ceil32(return_data.size) + ceil32(32 * mem[_4418 + mem[_4418]]) + 1
                                mem[_4418 + ceil32(return_data.size)] = _4558
                                require return_data.size >= _4482 + (32 * _4558) + 32
                                mem[_4418 + ceil32(return_data.size) + 32 len 32 * _4558] = mem[_4418 + _4482 + 32 len 32 * _4558]
                                if _4558 < 1:
                                    revert with 0, 17
                                if _4558 - 1 >= _4558:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4558 - 1) + _4418 + ceil32(return_data.size) + 32] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4558 - 1) + _4418 + ceil32(return_data.size) + 32]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4558 - 1) + _4418 + ceil32(return_data.size) + 32]) - (sub_fd53fce0 * mem[(32 * _4558 - 1) + _4418 + ceil32(return_data.size) + 32]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8210 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8210] == bool(mem[_8210])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8418 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8418] == mem[_8418 + 12 len 20]
                                if address(arg2) == mem[_8418 + 12 len 20]:
                                    _8627 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8627]:
                                        revert with 0, 50
                                    mem[_8627 + 32] = tokenAddress
                                    if 1 >= mem[_8627]:
                                        revert with 0, 50
                                    mem[_8627 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8627 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8627 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8627 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8627 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8627 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8627 + ceil32(return_data.size) + 164] = 160
                                        mem[_8627 + ceil32(return_data.size) + 260] = mem[_8627]
                                        idx = 0
                                        s = _8627 + 32
                                        t = _8627 + ceil32(return_data.size) + 292
                                        while idx < mem[_8627]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8627 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8627 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8627 + ceil32(return_data.size) + 260 len (32 * mem[_8627]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8627 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8627 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11102 = mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8627 + ceil32(return_data.size) + return_data.size + 96
                                        _11206 = mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8627 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8627 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8627 + (2 * ceil32(return_data.size)) + 96] = mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11102 + (32 * _11206) + 32
                                        mem[_8627 + (2 * ceil32(return_data.size)) + 128 len 32 * _11206] = mem[_8627 + ceil32(return_data.size) + _11102 + 128 len 32 * _11206]
                                        if _11206 < 1:
                                            revert with 0, 17
                                        if _11206 - 1 >= _11206:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11206 - 1) + _8627 + (2 * ceil32(return_data.size)) + 128]
                                    else:
                                        mem[_8627 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8627 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8627 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8627 + ceil32(return_data.size) + 164] = 160
                                        mem[_8627 + ceil32(return_data.size) + 260] = mem[_8627]
                                        idx = 0
                                        s = _8627 + 32
                                        t = _8627 + ceil32(return_data.size) + 292
                                        while idx < mem[_8627]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8627 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8627 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8627 + ceil32(return_data.size) + 260 len (32 * mem[_8627]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8627 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8627 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11103 = mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8627 + ceil32(return_data.size) + return_data.size + 96
                                        _11207 = mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8627 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8627 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8627 + (2 * ceil32(return_data.size)) + 96] = mem[_8627 + ceil32(return_data.size) + mem[_8627 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11103 + (32 * _11207) + 32
                                        mem[_8627 + (2 * ceil32(return_data.size)) + 128 len 32 * _11207] = mem[_8627 + ceil32(return_data.size) + _11103 + 128 len 32 * _11207]
                                        if _11207 < 1:
                                            revert with 0, 17
                                        if _11207 - 1 >= _11207:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11207 - 1) + _8627 + (2 * ceil32(return_data.size)) + 128]
                                else:
                                    _8624 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8624]:
                                        revert with 0, 50
                                    mem[_8624 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8624]:
                                        revert with 0, 50
                                    mem[_8624 + 32] = tokenAddress
                                    if 2 >= mem[_8624]:
                                        revert with 0, 50
                                    mem[_8624 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8624 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8624 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 292] = mem[_8624]
                                        idx = 0
                                        s = _8624 + 32
                                        t = _8624 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8624]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8624 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8624]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8624 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11100 = mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8624 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11204 = mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8624 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8624 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                                        mem[_8624 + (4 * ceil32(return_data.size)) + 128] = mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11100 + (32 * _11204) + 32
                                        mem[_8624 + (4 * ceil32(return_data.size)) + 160 len 32 * _11204] = mem[_8624 + (2 * ceil32(return_data.size)) + _11100 + 160 len 32 * _11204]
                                        if _11204 < 1:
                                            revert with 0, 17
                                        if _11204 - 1 >= _11204:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11204 - 1) + _8624 + (4 * ceil32(return_data.size)) + 160]
                                    else:
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 292] = mem[_8624]
                                        idx = 0
                                        s = _8624 + 32
                                        t = _8624 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8624]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8624 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8624]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8624 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8624 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11101 = mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8624 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11205 = mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8624 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8624 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                                        mem[_8624 + (4 * ceil32(return_data.size)) + 128] = mem[_8624 + (2 * ceil32(return_data.size)) + mem[_8624 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11101 + (32 * _11205) + 32
                                        mem[_8624 + (4 * ceil32(return_data.size)) + 160 len 32 * _11205] = mem[_8624 + (2 * ceil32(return_data.size)) + _11101 + 160 len 32 * _11205]
                                        if _11205 < 1:
                                            revert with 0, 17
                                        if _11205 - 1 >= _11205:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11205 - 1) + _8624 + (4 * ceil32(return_data.size)) + 160]
                    else:
                        if address(sub_0584aecfAddress) != msg.sender:
                            revert with 0, 'Access Denied!'
                        mem[132] = this.address
                        mem[164] = routerAddress
                        require ext_code.size(stor105)
                        staticcall stor105.allowance(address arg1, address arg2) with:
                                gas gas_remaining wei
                               args address(this.address), routerAddress
                        mem[128] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] >= arg3:
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if address(arg2) == ext_call.return_data[12 len 20]:
                                mem[(2 * ceil32(return_data.size)) + 128] = 2
                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                mem[(2 * ceil32(return_data.size)) + 260] = 64
                                mem[(2 * ceil32(return_data.size)) + 292] = 2
                                idx = 0
                                s = (2 * ceil32(return_data.size)) + 160
                                t = (2 * ceil32(return_data.size)) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (4 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4485 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                _4561 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4485 + (32 * _4561) + 32
                                mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4561] = mem[(2 * ceil32(return_data.size)) + _4485 + 256 len 32 * _4561]
                                if _4561 < 1:
                                    revert with 0, 17
                                if _4561 - 1 >= _4561:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4561 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4561 - 1) + (4 * ceil32(return_data.size)) + 256]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4561 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4561 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8213 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8213] == bool(mem[_8213])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8421 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8421] == mem[_8421 + 12 len 20]
                                if address(arg2) == mem[_8421 + 12 len 20]:
                                    _8639 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8639]:
                                        revert with 0, 50
                                    mem[_8639 + 32] = tokenAddress
                                    if 1 >= mem[_8639]:
                                        revert with 0, 50
                                    mem[_8639 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8639 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8639 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8639 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8639 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8639 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8639 + ceil32(return_data.size) + 164] = 160
                                        mem[_8639 + ceil32(return_data.size) + 260] = mem[_8639]
                                        idx = 0
                                        s = _8639 + 32
                                        t = _8639 + ceil32(return_data.size) + 292
                                        while idx < mem[_8639]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8639 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8639 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8639 + ceil32(return_data.size) + 260 len (32 * mem[_8639]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8639 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8639 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11114 = mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8639 + ceil32(return_data.size) + return_data.size + 96
                                        _11218 = mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8639 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8639 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8639 + (2 * ceil32(return_data.size)) + 96] = mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11114 + (32 * _11218) + 32
                                        mem[_8639 + (2 * ceil32(return_data.size)) + 128 len 32 * _11218] = mem[_8639 + ceil32(return_data.size) + _11114 + 128 len 32 * _11218]
                                        if _11218 < 1:
                                            revert with 0, 17
                                        if _11218 - 1 >= _11218:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11218 - 1) + _8639 + (2 * ceil32(return_data.size)) + 128]
                                    else:
                                        mem[_8639 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8639 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8639 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8639 + ceil32(return_data.size) + 164] = 160
                                        mem[_8639 + ceil32(return_data.size) + 260] = mem[_8639]
                                        idx = 0
                                        s = _8639 + 32
                                        t = _8639 + ceil32(return_data.size) + 292
                                        while idx < mem[_8639]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8639 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8639 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8639 + ceil32(return_data.size) + 260 len (32 * mem[_8639]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8639 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8639 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11115 = mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8639 + ceil32(return_data.size) + return_data.size + 96
                                        _11219 = mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8639 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8639 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8639 + (2 * ceil32(return_data.size)) + 96] = mem[_8639 + ceil32(return_data.size) + mem[_8639 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11115 + (32 * _11219) + 32
                                        mem[_8639 + (2 * ceil32(return_data.size)) + 128 len 32 * _11219] = mem[_8639 + ceil32(return_data.size) + _11115 + 128 len 32 * _11219]
                                        if _11219 < 1:
                                            revert with 0, 17
                                        if _11219 - 1 >= _11219:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11219 - 1) + _8639 + (2 * ceil32(return_data.size)) + 128]
                                else:
                                    _8636 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8636]:
                                        revert with 0, 50
                                    mem[_8636 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8636]:
                                        revert with 0, 50
                                    mem[_8636 + 32] = tokenAddress
                                    if 2 >= mem[_8636]:
                                        revert with 0, 50
                                    mem[_8636 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8636 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8636 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 292] = mem[_8636]
                                        idx = 0
                                        s = _8636 + 32
                                        t = _8636 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8636]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8636 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8636]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8636 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11112 = mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8636 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11216 = mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8636 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8636 + (4 * ceil32(return_data.size)) + 128] = mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11112 + (32 * _11216) + 32
                                        mem[_8636 + (4 * ceil32(return_data.size)) + 160 len 32 * _11216] = mem[_8636 + (2 * ceil32(return_data.size)) + _11112 + 160 len 32 * _11216]
                                        if _11216 < 1:
                                            revert with 0, 17
                                        if _11216 - 1 >= _11216:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11216 - 1) + _8636 + (4 * ceil32(return_data.size)) + 160]
                                    else:
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 292] = mem[_8636]
                                        idx = 0
                                        s = _8636 + 32
                                        t = _8636 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8636]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8636 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8636]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8636 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8636 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11113 = mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8636 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11217 = mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8636 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8636 + (4 * ceil32(return_data.size)) + 128] = mem[_8636 + (2 * ceil32(return_data.size)) + mem[_8636 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11113 + (32 * _11217) + 32
                                        mem[_8636 + (4 * ceil32(return_data.size)) + 160 len 32 * _11217] = mem[_8636 + (2 * ceil32(return_data.size)) + _11113 + 160 len 32 * _11217]
                                        if _11217 < 1:
                                            revert with 0, 17
                                        if _11217 - 1 >= _11217:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11217 - 1) + _8636 + (4 * ceil32(return_data.size)) + 160]
                            else:
                                mem[(2 * ceil32(return_data.size)) + 128] = 3
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(2 * ceil32(return_data.size)) + 224] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                mem[(4 * ceil32(return_data.size)) + 292] = 64
                                mem[(4 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = (2 * ceil32(return_data.size)) + 160
                                t = (4 * ceil32(return_data.size)) + 356
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                _4484 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                _4560 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                mem[(6 * ceil32(return_data.size)) + 256] = _4560
                                require return_data.size >= _4484 + (32 * _4560) + 32
                                mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4560] = mem[(4 * ceil32(return_data.size)) + _4484 + 288 len 32 * _4560]
                                if _4560 < 1:
                                    revert with 0, 17
                                if _4560 - 1 >= _4560:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4560 - 1) + (6 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4560 - 1) + (6 * ceil32(return_data.size)) + 288]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4560 - 1) + (6 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4560 - 1) + (6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8212 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8212] == bool(mem[_8212])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8420 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8420] == mem[_8420 + 12 len 20]
                                if address(arg2) == mem[_8420 + 12 len 20]:
                                    _8635 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8635]:
                                        revert with 0, 50
                                    mem[_8635 + 32] = tokenAddress
                                    if 1 >= mem[_8635]:
                                        revert with 0, 50
                                    mem[_8635 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8635 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8635 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8635 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8635 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8635 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8635 + ceil32(return_data.size) + 164] = 160
                                        mem[_8635 + ceil32(return_data.size) + 260] = mem[_8635]
                                        idx = 0
                                        s = _8635 + 32
                                        t = _8635 + ceil32(return_data.size) + 292
                                        while idx < mem[_8635]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8635 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8635 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8635 + ceil32(return_data.size) + 260 len (32 * mem[_8635]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8635 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8635 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11110 = mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8635 + ceil32(return_data.size) + return_data.size + 96
                                        _11214 = mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8635 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8635 + (2 * ceil32(return_data.size)) + 96] = mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11110 + (32 * _11214) + 32
                                        mem[_8635 + (2 * ceil32(return_data.size)) + 128 len 32 * _11214] = mem[_8635 + ceil32(return_data.size) + _11110 + 128 len 32 * _11214]
                                        if _11214 < 1:
                                            revert with 0, 17
                                        if _11214 - 1 >= _11214:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11214 - 1) + _8635 + (2 * ceil32(return_data.size)) + 128]
                                    else:
                                        mem[_8635 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8635 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8635 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8635 + ceil32(return_data.size) + 164] = 160
                                        mem[_8635 + ceil32(return_data.size) + 260] = mem[_8635]
                                        idx = 0
                                        s = _8635 + 32
                                        t = _8635 + ceil32(return_data.size) + 292
                                        while idx < mem[_8635]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8635 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8635 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8635 + ceil32(return_data.size) + 260 len (32 * mem[_8635]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8635 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8635 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11111 = mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8635 + ceil32(return_data.size) + return_data.size + 96
                                        _11215 = mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8635 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8635 + (2 * ceil32(return_data.size)) + 96] = mem[_8635 + ceil32(return_data.size) + mem[_8635 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11111 + (32 * _11215) + 32
                                        mem[_8635 + (2 * ceil32(return_data.size)) + 128 len 32 * _11215] = mem[_8635 + ceil32(return_data.size) + _11111 + 128 len 32 * _11215]
                                        if _11215 < 1:
                                            revert with 0, 17
                                        if _11215 - 1 >= _11215:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11215 - 1) + _8635 + (2 * ceil32(return_data.size)) + 128]
                                else:
                                    _8632 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8632]:
                                        revert with 0, 50
                                    mem[_8632 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8632]:
                                        revert with 0, 50
                                    mem[_8632 + 32] = tokenAddress
                                    if 2 >= mem[_8632]:
                                        revert with 0, 50
                                    mem[_8632 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8632 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8632 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 292] = mem[_8632]
                                        idx = 0
                                        s = _8632 + 32
                                        t = _8632 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8632]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8632 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8632]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8632 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11108 = mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8632 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11212 = mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8632 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8632 + (4 * ceil32(return_data.size)) + 128] = mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11108 + (32 * _11212) + 32
                                        mem[_8632 + (4 * ceil32(return_data.size)) + 160 len 32 * _11212] = mem[_8632 + (2 * ceil32(return_data.size)) + _11108 + 160 len 32 * _11212]
                                        if _11212 < 1:
                                            revert with 0, 17
                                        if _11212 - 1 >= _11212:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11212 - 1) + _8632 + (4 * ceil32(return_data.size)) + 160]
                                    else:
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 292] = mem[_8632]
                                        idx = 0
                                        s = _8632 + 32
                                        t = _8632 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8632]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8632 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8632]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8632 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8632 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11109 = mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8632 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11213 = mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8632 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8632 + (4 * ceil32(return_data.size)) + 128] = mem[_8632 + (2 * ceil32(return_data.size)) + mem[_8632 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11109 + (32 * _11213) + 32
                                        mem[_8632 + (4 * ceil32(return_data.size)) + 160 len 32 * _11213] = mem[_8632 + (2 * ceil32(return_data.size)) + _11109 + 160 len 32 * _11213]
                                        if _11213 < 1:
                                            revert with 0, 17
                                        if _11213 - 1 >= _11213:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11213 - 1) + _8632 + (4 * ceil32(return_data.size)) + 160]
                        else:
                            mem[ceil32(return_data.size) + 132] = routerAddress
                            mem[ceil32(return_data.size) + 164] = arg3
                            require ext_code.size(stor105)
                            call stor105.approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args routerAddress, arg3
                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            require ext_code.size(stor101)
                            staticcall stor101.WAVAX() with:
                                    gas gas_remaining wei
                            mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            if address(arg2) == ext_call.return_data[12 len 20]:
                                mem[(4 * ceil32(return_data.size)) + 128] = 2
                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                mem[(4 * ceil32(return_data.size)) + 260] = 64
                                mem[(4 * ceil32(return_data.size)) + 292] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 160
                                t = (4 * ceil32(return_data.size)) + 324
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                        gas gas_remaining wei
                                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _4487 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                _4563 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                require return_data.size >= _4487 + (32 * _4563) + 32
                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4563] = mem[(4 * ceil32(return_data.size)) + _4487 + 256 len 32 * _4563]
                                if _4563 < 1:
                                    revert with 0, 17
                                if _4563 - 1 >= _4563:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4563 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4563 - 1) + (6 * ceil32(return_data.size)) + 256]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4563 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4563 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8215 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8215] == bool(mem[_8215])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8423 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8423] == mem[_8423 + 12 len 20]
                                if address(arg2) == mem[_8423 + 12 len 20]:
                                    _8647 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8647]:
                                        revert with 0, 50
                                    mem[_8647 + 32] = tokenAddress
                                    if 1 >= mem[_8647]:
                                        revert with 0, 50
                                    mem[_8647 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8647 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8647 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8647 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8647 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8647 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8647 + ceil32(return_data.size) + 164] = 160
                                        mem[_8647 + ceil32(return_data.size) + 260] = mem[_8647]
                                        idx = 0
                                        s = _8647 + 32
                                        t = _8647 + ceil32(return_data.size) + 292
                                        while idx < mem[_8647]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8647 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8647 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8647 + ceil32(return_data.size) + 260 len (32 * mem[_8647]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8647 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8647 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11122 = mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8647 + ceil32(return_data.size) + return_data.size + 96
                                        _11226 = mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8647 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8647 + (2 * ceil32(return_data.size)) + 96] = mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11122 + (32 * _11226) + 32
                                        mem[_8647 + (2 * ceil32(return_data.size)) + 128 len 32 * _11226] = mem[_8647 + ceil32(return_data.size) + _11122 + 128 len 32 * _11226]
                                        if _11226 < 1:
                                            revert with 0, 17
                                        if _11226 - 1 >= _11226:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11226 - 1) + _8647 + (2 * ceil32(return_data.size)) + 128]
                                    else:
                                        mem[_8647 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8647 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8647 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8647 + ceil32(return_data.size) + 164] = 160
                                        mem[_8647 + ceil32(return_data.size) + 260] = mem[_8647]
                                        idx = 0
                                        s = _8647 + 32
                                        t = _8647 + ceil32(return_data.size) + 292
                                        while idx < mem[_8647]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8647 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8647 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8647 + ceil32(return_data.size) + 260 len (32 * mem[_8647]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8647 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8647 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11123 = mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8647 + ceil32(return_data.size) + return_data.size + 96
                                        _11227 = mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8647 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[_8647 + (2 * ceil32(return_data.size)) + 96] = mem[_8647 + ceil32(return_data.size) + mem[_8647 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11123 + (32 * _11227) + 32
                                        mem[_8647 + (2 * ceil32(return_data.size)) + 128 len 32 * _11227] = mem[_8647 + ceil32(return_data.size) + _11123 + 128 len 32 * _11227]
                                        if _11227 < 1:
                                            revert with 0, 17
                                        if _11227 - 1 >= _11227:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11227 - 1) + _8647 + (2 * ceil32(return_data.size)) + 128]
                                else:
                                    _8644 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8644]:
                                        revert with 0, 50
                                    mem[_8644 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8644]:
                                        revert with 0, 50
                                    mem[_8644 + 32] = tokenAddress
                                    if 2 >= mem[_8644]:
                                        revert with 0, 50
                                    mem[_8644 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8644 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8644 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 292] = mem[_8644]
                                        idx = 0
                                        s = _8644 + 32
                                        t = _8644 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8644]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8644 + (2 * ceil32(return_data.size)) + (32 * mem[_8644]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11016 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11120 = mem[_11016]
                                        require mem[_11016] <= test266151307()
                                        require _11016 + mem[_11016] + 31 < _11016 + return_data.size
                                        _11224 = mem[_11016 + mem[_11016]]
                                        if mem[_11016 + mem[_11016]] > test266151307():
                                            revert with 0, 65
                                        if _11016 + ceil32(return_data.size) + ceil32(32 * mem[_11016 + mem[_11016]]) + 1 > test266151307() or ceil32(32 * mem[_11016 + mem[_11016]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _11016 + ceil32(return_data.size) + ceil32(32 * mem[_11016 + mem[_11016]]) + 1
                                        mem[_11016 + ceil32(return_data.size)] = _11224
                                        require return_data.size >= _11120 + (32 * _11224) + 32
                                        mem[_11016 + ceil32(return_data.size) + 32 len 32 * _11224] = mem[_11016 + _11120 + 32 len 32 * _11224]
                                        if _11224 < 1:
                                            revert with 0, 17
                                        if _11224 - 1 >= _11224:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11224 - 1) + _11016 + ceil32(return_data.size) + 32]
                                    else:
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 292] = mem[_8644]
                                        idx = 0
                                        s = _8644 + 32
                                        t = _8644 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8644]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8644 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _8644 + (2 * ceil32(return_data.size)) + (32 * mem[_8644]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _11017 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _11121 = mem[_11017]
                                        require mem[_11017] <= test266151307()
                                        require _11017 + mem[_11017] + 31 < _11017 + return_data.size
                                        _11225 = mem[_11017 + mem[_11017]]
                                        if mem[_11017 + mem[_11017]] > test266151307():
                                            revert with 0, 65
                                        if _11017 + ceil32(return_data.size) + ceil32(32 * mem[_11017 + mem[_11017]]) + 1 > test266151307() or ceil32(32 * mem[_11017 + mem[_11017]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _11017 + ceil32(return_data.size) + ceil32(32 * mem[_11017 + mem[_11017]]) + 1
                                        mem[_11017 + ceil32(return_data.size)] = _11225
                                        require return_data.size >= _11121 + (32 * _11225) + 32
                                        mem[_11017 + ceil32(return_data.size) + 32 len 32 * _11225] = mem[_11017 + _11121 + 32 len 32 * _11225]
                                        if _11225 < 1:
                                            revert with 0, 17
                                        if _11225 - 1 >= _11225:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11225 - 1) + _11017 + ceil32(return_data.size) + 32]
                            else:
                                mem[(4 * ceil32(return_data.size)) + 128] = 3
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                mem[(4 * ceil32(return_data.size)) + 224] = address(arg2)
                                mem[(6 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                mem[(6 * ceil32(return_data.size)) + 292] = 64
                                mem[(6 * ceil32(return_data.size)) + 324] = 3
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 160
                                t = (6 * ceil32(return_data.size)) + 356
                                while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(stor101)
                                staticcall stor101.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4422 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _4486 = mem[_4422]
                                require mem[_4422] <= test266151307()
                                require _4422 + mem[_4422] + 31 < _4422 + return_data.size
                                _4562 = mem[_4422 + mem[_4422]]
                                if mem[_4422 + mem[_4422]] > test266151307():
                                    revert with 0, 65
                                if _4422 + ceil32(return_data.size) + ceil32(32 * mem[_4422 + mem[_4422]]) + 1 > test266151307() or ceil32(32 * mem[_4422 + mem[_4422]]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = _4422 + ceil32(return_data.size) + ceil32(32 * mem[_4422 + mem[_4422]]) + 1
                                mem[_4422 + ceil32(return_data.size)] = _4562
                                require return_data.size >= _4486 + (32 * _4562) + 32
                                mem[_4422 + ceil32(return_data.size) + 32 len 32 * _4562] = mem[_4422 + _4486 + 32 len 32 * _4562]
                                if _4562 < 1:
                                    revert with 0, 17
                                if _4562 - 1 >= _4562:
                                    revert with 0, 50
                                if 100 * 10^6 < sub_fd53fce0:
                                    revert with 0, 17
                                if mem[(32 * _4562 - 1) + _4422 + ceil32(return_data.size) + 32] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4562 - 1) + _4422 + ceil32(return_data.size) + 32]:
                                    revert with 0, 17
                                if (100 * 10^6 * mem[(32 * _4562 - 1) + _4422 + ceil32(return_data.size) + 32]) - (sub_fd53fce0 * mem[(32 * _4562 - 1) + _4422 + ceil32(return_data.size) + 32]) / 100 * 10^6 < arg4:
                                    revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                if arg3 and sub_fd53fce0 > -1 / arg3:
                                    revert with 0, 17
                                mem[mem[64] + 4] = sub_11eb47dcAddress
                                mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                require ext_code.size(stor105)
                                call stor105.transfer(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8214 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8214] == bool(mem[_8214])
                                require ext_code.size(stor101)
                                staticcall stor101.WAVAX() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8422 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8422] == mem[_8422 + 12 len 20]
                                if address(arg2) == mem[_8422 + 12 len 20]:
                                    _8643 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if not mem[_8643]:
                                        revert with 0, 50
                                    mem[_8643 + 32] = tokenAddress
                                    if 1 >= mem[_8643]:
                                        revert with 0, 50
                                    mem[_8643 + 64] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8643 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8643 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8643 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8643 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8643 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8643 + ceil32(return_data.size) + 164] = 160
                                        mem[_8643 + ceil32(return_data.size) + 260] = mem[_8643]
                                        idx = 0
                                        s = _8643 + 32
                                        t = _8643 + ceil32(return_data.size) + 292
                                        while idx < mem[_8643]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8643 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8643 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8643 + ceil32(return_data.size) + 260 len (32 * mem[_8643]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8643 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8643 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11118 = mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8643 + ceil32(return_data.size) + return_data.size + 96
                                        _11222 = mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8643 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8643 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8643 + (2 * ceil32(return_data.size)) + 96] = mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11118 + (32 * _11222) + 32
                                        mem[_8643 + (2 * ceil32(return_data.size)) + 128 len 32 * _11222] = mem[_8643 + ceil32(return_data.size) + _11118 + 128 len 32 * _11222]
                                        if _11222 < 1:
                                            revert with 0, 17
                                        if _11222 - 1 >= _11222:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11222 - 1) + _8643 + (2 * ceil32(return_data.size)) + 128]
                                    else:
                                        mem[_8643 + ceil32(return_data.size) + 96] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8643 + ceil32(return_data.size) + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8643 + ceil32(return_data.size) + 132] = arg4
                                        mem[_8643 + ceil32(return_data.size) + 164] = 160
                                        mem[_8643 + ceil32(return_data.size) + 260] = mem[_8643]
                                        idx = 0
                                        s = _8643 + 32
                                        t = _8643 + ceil32(return_data.size) + 292
                                        while idx < mem[_8643]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8643 + ceil32(return_data.size) + 196] = address(arg1)
                                        mem[_8643 + ceil32(return_data.size) + 228] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8643 + ceil32(return_data.size) + 260 len (32 * mem[_8643]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8643 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8643 + (2 * ceil32(return_data.size)) + 96
                                        require return_data.size >= 32
                                        _11119 = mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 127 < _8643 + ceil32(return_data.size) + return_data.size + 96
                                        _11223 = mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        if mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96] > test266151307():
                                            revert with 0, 65
                                        if _8643 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8643 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]) + 97
                                        mem[_8643 + (2 * ceil32(return_data.size)) + 96] = mem[_8643 + ceil32(return_data.size) + mem[_8643 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 96]
                                        require return_data.size >= _11119 + (32 * _11223) + 32
                                        mem[_8643 + (2 * ceil32(return_data.size)) + 128 len 32 * _11223] = mem[_8643 + ceil32(return_data.size) + _11119 + 128 len 32 * _11223]
                                        if _11223 < 1:
                                            revert with 0, 17
                                        if _11223 - 1 >= _11223:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11223 - 1) + _8643 + (2 * ceil32(return_data.size)) + 128]
                                else:
                                    _8640 = mem[64]
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_8640]:
                                        revert with 0, 50
                                    mem[_8640 + 64] = ext_call.return_data[12 len 20]
                                    if not mem[_8640]:
                                        revert with 0, 50
                                    mem[_8640 + 32] = tokenAddress
                                    if 2 >= mem[_8640]:
                                        revert with 0, 50
                                    mem[_8640 + 96] = address(arg2)
                                    require ext_code.size(stor101)
                                    staticcall stor101.WAVAX() with:
                                            gas gas_remaining wei
                                    mem[_8640 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _8640 + (2 * ceil32(return_data.size)) + 128
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                        revert with 0, 17
                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 292] = mem[_8640]
                                        idx = 0
                                        s = _8640 + 32
                                        t = _8640 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8640]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8640 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8640]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8640 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11116 = mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8640 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11220 = mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8640 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8640 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                                        mem[_8640 + (4 * ceil32(return_data.size)) + 128] = mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11116 + (32 * _11220) + 32
                                        mem[_8640 + (4 * ceil32(return_data.size)) + 160 len 32 * _11220] = mem[_8640 + (2 * ceil32(return_data.size)) + _11116 + 160 len 32 * _11220]
                                        if _11220 < 1:
                                            revert with 0, 17
                                        if _11220 - 1 >= _11220:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11220 - 1) + _8640 + (4 * ceil32(return_data.size)) + 160]
                                    else:
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 128] = 0x676528d100000000000000000000000000000000000000000000000000000000
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 164] = arg4
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 196] = 160
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 292] = mem[_8640]
                                        idx = 0
                                        s = _8640 + 32
                                        t = _8640 + (2 * ceil32(return_data.size)) + 324
                                        while idx < mem[_8640]:
                                            mem[t] = mem[s + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 260] = arg5
                                        require ext_code.size(stor101)
                                        call stor101.swapExactTokensForAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8640 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8640]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_8640 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _8640 + (4 * ceil32(return_data.size)) + 128
                                        require return_data.size >= 32
                                        _11117 = mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                        require mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                        require _8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8640 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                        _11221 = mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        if mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                            revert with 0, 65
                                        if _8640 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _8640 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                                        mem[_8640 + (4 * ceil32(return_data.size)) + 128] = mem[_8640 + (2 * ceil32(return_data.size)) + mem[_8640 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                        require return_data.size >= _11117 + (32 * _11221) + 32
                                        mem[_8640 + (4 * ceil32(return_data.size)) + 160 len 32 * _11221] = mem[_8640 + (2 * ceil32(return_data.size)) + _11117 + 160 len 32 * _11221]
                                        if _11221 < 1:
                                            revert with 0, 17
                                        if _11221 - 1 >= _11221:
                                            revert with 0, 50
                                        emit 0xfedb587d: tokenAddress, arg3, address(arg2), mem[(32 * _11221 - 1) + _8640 + (4 * ceil32(return_data.size)) + 160]
        else:
            if unknown_0x48b75044(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x0584aecf(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return address(sub_0584aecfAddress)
                if unknown_0x11eb47dc(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return sub_11eb47dcAddress
                if uint32(call.func_hash) >> 224 != unknown_0x144fa6d7(?????):
                    if uint32(call.func_hash) >> 224 != unknown_0x19165587(?????):
                        if unknown_0x3268cc56(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return routerAddress
                        if unknown_0x3a98ef39(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return totalShares
                        require unknown_0x406072a9(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require arg1 == address(arg1)
                        require arg2 == address(arg2)
                        return released[address(arg1)][address(arg2)]
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require arg1 == address(arg1)
                    if not shares[address(arg1)]:
                        revert with 0, 'PaymentSplitter: account has no shares'
                    if eth.balance(this.address) > !totalReleased:
                        revert with 0, 17
                    if eth.balance(this.address) + totalReleased and shares[address(arg1)] > -1 / eth.balance(this.address) + totalReleased:
                        revert with 0, 17
                    if not totalShares:
                        revert with 0, 18
                    if (eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares < released[address(arg1)]:
                        revert with 0, 17
                    if not ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]:
                        revert with 0, 'PaymentSplitter: account is not due payment'
                    if released[address(arg1)] > !(((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]):
                        revert with 0, 17
                    released[address(arg1)] = (eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares
                    if totalReleased > !(((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]):
                        revert with 0, 17
                    totalReleased = totalReleased + ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]
                    if eth.balance(this.address) < ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]:
                        revert with 0, 'Address: insufficient balance'
                    call address(arg1) with:
                       value ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)] wei
                         gas gas_remaining wei
                    if not ext_call.success:
                        revert with 0, 'Address: unable to send value, recipient may have reverted'
                    emit PaymentReleased(address(arg1), ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / totalShares) - released[address(arg1)]);
                else:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require arg1 == address(arg1)
                    if tokenAddress != msg.sender:
                        if address(sub_0584aecfAddress) != msg.sender:
                            revert with 0, 'Access Denied!'
                    if not address(arg1):
                        revert with 0, 'NEW_TOKEN: zero addr'
                    tokenAddress = address(arg1)
                    stor105 = address(arg1)
                    require ext_code.size(stor101)
                    staticcall stor101.factory() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
                         gas gas_remaining wei
                        args tokenAddress, address(ext_call.return_data[0])
                    if ext_call.success:
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(stor101)
                    staticcall stor101.factory() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(stor101)
                    staticcall stor101.WAVAX() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args tokenAddress, address(ext_call.return_data[0])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    uniswapV2PairAddress = ext_call.return_data[12 len 20]
            else:
                if unknown_0x48b75044(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require arg1 == address(arg1)
                    require arg2 == address(arg2)
                    if not shares[address(arg2)]:
                        revert with 0, 'PaymentSplitter: account has no shares'
                    mem[132] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).balanceOf(address arg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[128] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] > !totalReleased[address(arg1)]:
                        revert with 0, 17
                    if ext_call.return_data[0] + totalReleased[address(arg1)] and shares[address(arg2)] > -1 / ext_call.return_data[0] + totalReleased[address(arg1)]:
                        revert with 0, 17
                    if not totalShares:
                        revert with 0, 18
                    if (ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares < released[address(arg1)][address(arg2)]:
                        revert with 0, 17
                    if not ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]:
                        revert with 0, 'PaymentSplitter: account is not due payment'
                    if released[address(arg1)][address(arg2)] > !(((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]):
                        revert with 0, 17
                    released[address(arg1)][address(arg2)] = (ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares
                    if totalReleased[address(arg1)] > !(((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]):
                        revert with 0, 17
                    totalReleased[address(arg1)] = totalReleased[address(arg1)] + ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]
                    mem[ceil32(return_data.size) + 164] = address(arg2)
                    mem[ceil32(return_data.size) + 196] = ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)]
                    mem[ceil32(return_data.size) + 128] = 68
                    mem[ceil32(return_data.size) + 164 len 28] = address(arg2) << 64
                    mem[ceil32(return_data.size) + 160 len 4] = transfer(address arg1, uint256 arg2)
                    mem[ceil32(return_data.size) + 228] = 32
                    mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 'Address: insufficient balance for call'
                    if not ext_code.size(address(arg1)):
                        revert with 0, 'Address: call to non-contract'
                    mem[ceil32(return_data.size) + 292 len 96] = transfer(address arg1, uint256 arg2), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], 0
                    mem[ceil32(return_data.size) + 360] = 0
                    call address(arg1) with:
                       funct Mask(32, 224, transfer(address arg1, uint256 arg2), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, transfer(address arg1, uint256 arg2), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], 0) << 288)
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                            if not mem[ceil32(return_data.size) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit ERC20PaymentReleased(address(arg2), ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / totalShares) - released[address(arg1)][address(arg2)], address(arg1));
                else:
                    if unknown_0x49bd5a5e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return uniswapV2PairAddress
                    if unknown_0x65b8dbc0(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require arg1 == address(arg1)
                        if tokenAddress != msg.sender:
                            if address(sub_0584aecfAddress) != msg.sender:
                                revert with 0, 'Access Denied!'
                        if stor101 == address(arg1):
                            revert with 0, 'TKN: The router already has that address'
                        routerAddress = address(arg1)
                        stor101 = address(arg1)
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).factory() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
                             gas gas_remaining wei
                            args tokenAddress, address(ext_call.return_data[0])
                        if ext_call.success:
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(stor101)
                        staticcall stor101.factory() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(stor101)
                        staticcall stor101.WAVAX() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                gas gas_remaining wei
                               args tokenAddress, address(ext_call.return_data[0])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        uniswapV2PairAddress = ext_call.return_data[12 len 20]
                    else:
                        if unknown_0x6a63f5ee(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require arg1 == address(arg1)
                            if tokenAddress != msg.sender:
                                if address(sub_0584aecfAddress) != msg.sender:
                                    revert with 0, 'Access Denied!'
                            if not address(arg1):
                                revert with 0, 'UPD_WALL: zero addr'
                            sub_11eb47dcAddress = address(arg1)
                        else:
                            if unknown_0x6e54a8a0(?????) == uint32(call.func_hash) >> 224:
                                require not msg.value
                                require calldata.size - 4 >= 160
                                require arg1 == address(arg1)
                                require arg2 == address(arg2)
                                if tokenAddress != msg.sender:
                                    if address(sub_0584aecfAddress) != msg.sender:
                                        revert with 0, 'Access Denied!'
                                    mem[132] = this.address
                                    mem[164] = routerAddress
                                    require ext_code.size(address(arg2))
                                    staticcall address(arg2).allowance(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args address(this.address), routerAddress
                                    mem[128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] >= arg3:
                                        require ext_code.size(stor101)
                                        staticcall stor101.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if address(arg2) == ext_call.return_data[12 len 20]:
                                            mem[(2 * ceil32(return_data.size)) + 128] = 2
                                            mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                                            mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                            mem[(2 * ceil32(return_data.size)) + 260] = 64
                                            mem[(2 * ceil32(return_data.size)) + 292] = 2
                                            idx = 0
                                            s = (2 * ceil32(return_data.size)) + 160
                                            t = (2 * ceil32(return_data.size)) + 324
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (4 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _4461 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                            _4537 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                revert with 0, 65
                                            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            require return_data.size >= _4461 + (32 * _4537) + 32
                                            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4537] = mem[(2 * ceil32(return_data.size)) + _4461 + 256 len 32 * _4537]
                                            if _4537 < 1:
                                                revert with 0, 17
                                            if _4537 - 1 >= _4537:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4537 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4537 - 1) + (4 * ceil32(return_data.size)) + 256]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4537 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4537 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8205 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8205] == bool(mem[_8205])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8405 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8405] == mem[_8405 + 12 len 20]
                                            if address(arg2) == mem[_8405 + 12 len 20]:
                                                _8583 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8583]:
                                                    revert with 0, 50
                                                mem[_8583 + 32] = address(arg2)
                                                if 1 >= mem[_8583]:
                                                    revert with 0, 50
                                                mem[_8583 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8583 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8583 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8583 + 132] = arg4
                                                mem[_8583 + 164] = 160
                                                mem[_8583 + 260] = mem[_8583]
                                                idx = 0
                                                s = _8583 + 32
                                                t = _8583 + 292
                                                while idx < mem[_8583]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8583 + 196] = address(arg1)
                                                mem[_8583 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8583 + (32 * mem[_8583]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10935 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11039 = mem[_10935]
                                                require mem[_10935] <= test266151307()
                                                require _10935 + mem[_10935] + 31 < _10935 + return_data.size
                                                _11143 = mem[_10935 + mem[_10935]]
                                                if mem[_10935 + mem[_10935]] > test266151307():
                                                    revert with 0, 65
                                                if _10935 + ceil32(return_data.size) + ceil32(32 * mem[_10935 + mem[_10935]]) + 1 > test266151307() or ceil32(32 * mem[_10935 + mem[_10935]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10935 + ceil32(return_data.size) + ceil32(32 * mem[_10935 + mem[_10935]]) + 1
                                                mem[_10935 + ceil32(return_data.size)] = _11143
                                                require return_data.size >= _11039 + (32 * _11143) + 32
                                                mem[_10935 + ceil32(return_data.size) + 32 len 32 * _11143] = mem[_10935 + _11039 + 32 len 32 * _11143]
                                                if _11143 < 1:
                                                    revert with 0, 17
                                                if _11143 - 1 >= _11143:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11143 - 1) + _10935 + ceil32(return_data.size) + 32]
                                            else:
                                                _8580 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8580]:
                                                    revert with 0, 50
                                                mem[_8580 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8580]:
                                                    revert with 0, 50
                                                mem[_8580 + 32] = address(arg2)
                                                if 2 >= mem[_8580]:
                                                    revert with 0, 50
                                                mem[_8580 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8580 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8580 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8580 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8580 + ceil32(return_data.size) + 196] = 160
                                                mem[_8580 + ceil32(return_data.size) + 292] = mem[_8580]
                                                idx = 0
                                                s = _8580 + 32
                                                t = _8580 + ceil32(return_data.size) + 324
                                                while idx < mem[_8580]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8580 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8580 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8580 + ceil32(return_data.size) + (32 * mem[_8580]) + -mem[64] + 320]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10934 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11038 = mem[_10934]
                                                require mem[_10934] <= test266151307()
                                                require _10934 + mem[_10934] + 31 < _10934 + return_data.size
                                                _11142 = mem[_10934 + mem[_10934]]
                                                if mem[_10934 + mem[_10934]] > test266151307():
                                                    revert with 0, 65
                                                if _10934 + ceil32(return_data.size) + ceil32(32 * mem[_10934 + mem[_10934]]) + 1 > test266151307() or ceil32(32 * mem[_10934 + mem[_10934]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10934 + ceil32(return_data.size) + ceil32(32 * mem[_10934 + mem[_10934]]) + 1
                                                mem[_10934 + ceil32(return_data.size)] = _11142
                                                require return_data.size >= _11038 + (32 * _11142) + 32
                                                mem[_10934 + ceil32(return_data.size) + 32 len 32 * _11142] = mem[_10934 + _11038 + 32 len 32 * _11142]
                                                if _11142 < 1:
                                                    revert with 0, 17
                                                if _11142 - 1 >= _11142:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11142 - 1) + _10934 + ceil32(return_data.size) + 32]
                                        else:
                                            mem[(2 * ceil32(return_data.size)) + 128] = 3
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                            mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                                            mem[(4 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                            mem[(4 * ceil32(return_data.size)) + 292] = 64
                                            mem[(4 * ceil32(return_data.size)) + 324] = 3
                                            idx = 0
                                            s = (2 * ceil32(return_data.size)) + 160
                                            t = (4 * ceil32(return_data.size)) + 356
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 256
                                            require return_data.size >= 32
                                            _4460 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                            require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                            _4536 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                            mem[(6 * ceil32(return_data.size)) + 256] = _4536
                                            require return_data.size >= _4460 + (32 * _4536) + 32
                                            mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4536] = mem[(4 * ceil32(return_data.size)) + _4460 + 288 len 32 * _4536]
                                            if _4536 < 1:
                                                revert with 0, 17
                                            if _4536 - 1 >= _4536:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4536 - 1) + (6 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4536 - 1) + (6 * ceil32(return_data.size)) + 288]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4536 - 1) + (6 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4536 - 1) + (6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8204 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8204] == bool(mem[_8204])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8404 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8404] == mem[_8404 + 12 len 20]
                                            if address(arg2) == mem[_8404 + 12 len 20]:
                                                _8579 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8579]:
                                                    revert with 0, 50
                                                mem[_8579 + 32] = address(arg2)
                                                if 1 >= mem[_8579]:
                                                    revert with 0, 50
                                                mem[_8579 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8579 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8579 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8579 + 132] = arg4
                                                mem[_8579 + 164] = 160
                                                mem[_8579 + 260] = mem[_8579]
                                                idx = 0
                                                s = _8579 + 32
                                                t = _8579 + 292
                                                while idx < mem[_8579]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8579 + 196] = address(arg1)
                                                mem[_8579 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8579 + (32 * mem[_8579]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10933 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11037 = mem[_10933]
                                                require mem[_10933] <= test266151307()
                                                require _10933 + mem[_10933] + 31 < _10933 + return_data.size
                                                _11141 = mem[_10933 + mem[_10933]]
                                                if mem[_10933 + mem[_10933]] > test266151307():
                                                    revert with 0, 65
                                                if _10933 + ceil32(return_data.size) + ceil32(32 * mem[_10933 + mem[_10933]]) + 1 > test266151307() or ceil32(32 * mem[_10933 + mem[_10933]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10933 + ceil32(return_data.size) + ceil32(32 * mem[_10933 + mem[_10933]]) + 1
                                                mem[_10933 + ceil32(return_data.size)] = _11141
                                                require return_data.size >= _11037 + (32 * _11141) + 32
                                                mem[_10933 + ceil32(return_data.size) + 32 len 32 * _11141] = mem[_10933 + _11037 + 32 len 32 * _11141]
                                                if _11141 < 1:
                                                    revert with 0, 17
                                                if _11141 - 1 >= _11141:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11141 - 1) + _10933 + ceil32(return_data.size) + 32]
                                            else:
                                                _8576 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8576]:
                                                    revert with 0, 50
                                                mem[_8576 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8576]:
                                                    revert with 0, 50
                                                mem[_8576 + 32] = address(arg2)
                                                if 2 >= mem[_8576]:
                                                    revert with 0, 50
                                                mem[_8576 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8576 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8576 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8576 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8576 + ceil32(return_data.size) + 196] = 160
                                                mem[_8576 + ceil32(return_data.size) + 292] = mem[_8576]
                                                idx = 0
                                                s = _8576 + 32
                                                t = _8576 + ceil32(return_data.size) + 324
                                                while idx < mem[_8576]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8576 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8576 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8576 + ceil32(return_data.size) + (32 * mem[_8576]) + -mem[64] + 320]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10932 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11036 = mem[_10932]
                                                require mem[_10932] <= test266151307()
                                                require _10932 + mem[_10932] + 31 < _10932 + return_data.size
                                                _11140 = mem[_10932 + mem[_10932]]
                                                if mem[_10932 + mem[_10932]] > test266151307():
                                                    revert with 0, 65
                                                if _10932 + ceil32(return_data.size) + ceil32(32 * mem[_10932 + mem[_10932]]) + 1 > test266151307() or ceil32(32 * mem[_10932 + mem[_10932]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10932 + ceil32(return_data.size) + ceil32(32 * mem[_10932 + mem[_10932]]) + 1
                                                mem[_10932 + ceil32(return_data.size)] = _11140
                                                require return_data.size >= _11036 + (32 * _11140) + 32
                                                mem[_10932 + ceil32(return_data.size) + 32 len 32 * _11140] = mem[_10932 + _11036 + 32 len 32 * _11140]
                                                if _11140 < 1:
                                                    revert with 0, 17
                                                if _11140 - 1 >= _11140:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11140 - 1) + _10932 + ceil32(return_data.size) + 32]
                                    else:
                                        mem[ceil32(return_data.size) + 132] = routerAddress
                                        mem[ceil32(return_data.size) + 164] = arg3
                                        require ext_code.size(address(arg2))
                                        call address(arg2).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args routerAddress, arg3
                                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                        require ext_code.size(stor101)
                                        staticcall stor101.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if address(arg2) == ext_call.return_data[12 len 20]:
                                            mem[(4 * ceil32(return_data.size)) + 128] = 2
                                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                                            mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                            mem[(4 * ceil32(return_data.size)) + 260] = 64
                                            mem[(4 * ceil32(return_data.size)) + 292] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 160
                                            t = (4 * ceil32(return_data.size)) + 324
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _4463 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                            _4539 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            require return_data.size >= _4463 + (32 * _4539) + 32
                                            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4539] = mem[(4 * ceil32(return_data.size)) + _4463 + 256 len 32 * _4539]
                                            if _4539 < 1:
                                                revert with 0, 17
                                            if _4539 - 1 >= _4539:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4539 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4539 - 1) + (6 * ceil32(return_data.size)) + 256]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4539 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4539 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8207 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8207] == bool(mem[_8207])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8407 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8407] == mem[_8407 + 12 len 20]
                                            if address(arg2) == mem[_8407 + 12 len 20]:
                                                _8591 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8591]:
                                                    revert with 0, 50
                                                mem[_8591 + 32] = address(arg2)
                                                if 1 >= mem[_8591]:
                                                    revert with 0, 50
                                                mem[_8591 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8591 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8591 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8591 + 132] = arg4
                                                mem[_8591 + 164] = 160
                                                mem[_8591 + 260] = mem[_8591]
                                                idx = 0
                                                s = _8591 + 32
                                                t = _8591 + 292
                                                while idx < mem[_8591]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8591 + 196] = address(arg1)
                                                mem[_8591 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8591 + (32 * mem[_8591]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10939 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11043 = mem[_10939]
                                                require mem[_10939] <= test266151307()
                                                require _10939 + mem[_10939] + 31 < _10939 + return_data.size
                                                _11147 = mem[_10939 + mem[_10939]]
                                                if mem[_10939 + mem[_10939]] > test266151307():
                                                    revert with 0, 65
                                                if _10939 + ceil32(return_data.size) + ceil32(32 * mem[_10939 + mem[_10939]]) + 1 > test266151307() or ceil32(32 * mem[_10939 + mem[_10939]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10939 + ceil32(return_data.size) + ceil32(32 * mem[_10939 + mem[_10939]]) + 1
                                                mem[_10939 + ceil32(return_data.size)] = _11147
                                                require return_data.size >= _11043 + (32 * _11147) + 32
                                                mem[_10939 + ceil32(return_data.size) + 32 len 32 * _11147] = mem[_10939 + _11043 + 32 len 32 * _11147]
                                                if _11147 < 1:
                                                    revert with 0, 17
                                                if _11147 - 1 >= _11147:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11147 - 1) + _10939 + ceil32(return_data.size) + 32]
                                            else:
                                                _8588 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8588]:
                                                    revert with 0, 50
                                                mem[_8588 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8588]:
                                                    revert with 0, 50
                                                mem[_8588 + 32] = address(arg2)
                                                if 2 >= mem[_8588]:
                                                    revert with 0, 50
                                                mem[_8588 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8588 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8588 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8588 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8588 + ceil32(return_data.size) + 196] = 160
                                                mem[_8588 + ceil32(return_data.size) + 292] = mem[_8588]
                                                idx = 0
                                                s = _8588 + 32
                                                t = _8588 + ceil32(return_data.size) + 324
                                                while idx < mem[_8588]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8588 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8588 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8588 + ceil32(return_data.size) + (32 * mem[_8588]) + -mem[64] + 320]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10938 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11042 = mem[_10938]
                                                require mem[_10938] <= test266151307()
                                                require _10938 + mem[_10938] + 31 < _10938 + return_data.size
                                                _11146 = mem[_10938 + mem[_10938]]
                                                if mem[_10938 + mem[_10938]] > test266151307():
                                                    revert with 0, 65
                                                if _10938 + ceil32(return_data.size) + ceil32(32 * mem[_10938 + mem[_10938]]) + 1 > test266151307() or ceil32(32 * mem[_10938 + mem[_10938]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10938 + ceil32(return_data.size) + ceil32(32 * mem[_10938 + mem[_10938]]) + 1
                                                mem[_10938 + ceil32(return_data.size)] = _11146
                                                require return_data.size >= _11042 + (32 * _11146) + 32
                                                mem[_10938 + ceil32(return_data.size) + 32 len 32 * _11146] = mem[_10938 + _11042 + 32 len 32 * _11146]
                                                if _11146 < 1:
                                                    revert with 0, 17
                                                if _11146 - 1 >= _11146:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11146 - 1) + _10938 + ceil32(return_data.size) + 32]
                                        else:
                                            mem[(4 * ceil32(return_data.size)) + 128] = 3
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 256
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(4 * ceil32(return_data.size)) + 224] = tokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                            mem[(6 * ceil32(return_data.size)) + 292] = 64
                                            mem[(6 * ceil32(return_data.size)) + 324] = 3
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 160
                                            t = (6 * ceil32(return_data.size)) + 356
                                            while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4398 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4462 = mem[_4398]
                                            require mem[_4398] <= test266151307()
                                            require _4398 + mem[_4398] + 31 < _4398 + return_data.size
                                            _4538 = mem[_4398 + mem[_4398]]
                                            if mem[_4398 + mem[_4398]] > test266151307():
                                                revert with 0, 65
                                            if _4398 + ceil32(return_data.size) + ceil32(32 * mem[_4398 + mem[_4398]]) + 1 > test266151307() or ceil32(32 * mem[_4398 + mem[_4398]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _4398 + ceil32(return_data.size) + ceil32(32 * mem[_4398 + mem[_4398]]) + 1
                                            mem[_4398 + ceil32(return_data.size)] = _4538
                                            require return_data.size >= _4462 + (32 * _4538) + 32
                                            mem[_4398 + ceil32(return_data.size) + 32 len 32 * _4538] = mem[_4398 + _4462 + 32 len 32 * _4538]
                                            if _4538 < 1:
                                                revert with 0, 17
                                            if _4538 - 1 >= _4538:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4538 - 1) + _4398 + ceil32(return_data.size) + 32] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4538 - 1) + _4398 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4538 - 1) + _4398 + ceil32(return_data.size) + 32]) - (sub_fd53fce0 * mem[(32 * _4538 - 1) + _4398 + ceil32(return_data.size) + 32]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8206 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8206] == bool(mem[_8206])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8406 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8406] == mem[_8406 + 12 len 20]
                                            if address(arg2) == mem[_8406 + 12 len 20]:
                                                _8587 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8587]:
                                                    revert with 0, 50
                                                mem[_8587 + 32] = address(arg2)
                                                if 1 >= mem[_8587]:
                                                    revert with 0, 50
                                                mem[_8587 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8587 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8587 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8587 + 132] = arg4
                                                mem[_8587 + 164] = 160
                                                mem[_8587 + 260] = mem[_8587]
                                                idx = 0
                                                s = _8587 + 32
                                                t = _8587 + 292
                                                while idx < mem[_8587]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8587 + 196] = address(arg1)
                                                mem[_8587 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8587 + (32 * mem[_8587]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10937 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11041 = mem[_10937]
                                                require mem[_10937] <= test266151307()
                                                require _10937 + mem[_10937] + 31 < _10937 + return_data.size
                                                _11145 = mem[_10937 + mem[_10937]]
                                                if mem[_10937 + mem[_10937]] > test266151307():
                                                    revert with 0, 65
                                                if _10937 + ceil32(return_data.size) + ceil32(32 * mem[_10937 + mem[_10937]]) + 1 > test266151307() or ceil32(32 * mem[_10937 + mem[_10937]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10937 + ceil32(return_data.size) + ceil32(32 * mem[_10937 + mem[_10937]]) + 1
                                                mem[_10937 + ceil32(return_data.size)] = _11145
                                                require return_data.size >= _11041 + (32 * _11145) + 32
                                                mem[_10937 + ceil32(return_data.size) + 32 len 32 * _11145] = mem[_10937 + _11041 + 32 len 32 * _11145]
                                                if _11145 < 1:
                                                    revert with 0, 17
                                                if _11145 - 1 >= _11145:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11145 - 1) + _10937 + ceil32(return_data.size) + 32]
                                            else:
                                                _8584 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8584]:
                                                    revert with 0, 50
                                                mem[_8584 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8584]:
                                                    revert with 0, 50
                                                mem[_8584 + 32] = address(arg2)
                                                if 2 >= mem[_8584]:
                                                    revert with 0, 50
                                                mem[_8584 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8584 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8584 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8584 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8584 + ceil32(return_data.size) + 196] = 160
                                                mem[_8584 + ceil32(return_data.size) + 292] = mem[_8584]
                                                idx = 0
                                                s = _8584 + 32
                                                t = _8584 + ceil32(return_data.size) + 324
                                                while idx < mem[_8584]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8584 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8584 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8584 + ceil32(return_data.size) + 292 len (32 * mem[_8584]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_8584 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = _8584 + (2 * ceil32(return_data.size)) + 128
                                                require return_data.size >= 32
                                                _11040 = mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                                require mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                                require _8584 + ceil32(return_data.size) + mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8584 + ceil32(return_data.size) + return_data.size + 128
                                                _11144 = mem[_8584 + ceil32(return_data.size) + mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                                if mem[_8584 + ceil32(return_data.size) + mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                                    revert with 0, 65
                                                if _8584 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8584 + ceil32(return_data.size) + mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8584 + ceil32(return_data.size) + mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[_8584 + (2 * ceil32(return_data.size)) + 128] = mem[_8584 + ceil32(return_data.size) + mem[_8584 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                                require return_data.size >= _11040 + (32 * _11144) + 32
                                                mem[_8584 + (2 * ceil32(return_data.size)) + 160 len 32 * _11144] = mem[_8584 + ceil32(return_data.size) + _11040 + 160 len 32 * _11144]
                                                if _11144 < 1:
                                                    revert with 0, 17
                                                if _11144 - 1 >= _11144:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11144 - 1) + _8584 + (2 * ceil32(return_data.size)) + 160]
                                else:
                                    mem[132] = this.address
                                    mem[164] = routerAddress
                                    require ext_code.size(address(arg2))
                                    staticcall address(arg2).allowance(address arg1, address arg2) with:
                                            gas gas_remaining wei
                                           args address(this.address), routerAddress
                                    mem[128] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] >= arg3:
                                        require ext_code.size(stor101)
                                        staticcall stor101.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if address(arg2) == ext_call.return_data[12 len 20]:
                                            mem[(2 * ceil32(return_data.size)) + 128] = 2
                                            mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                                            mem[(2 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                            mem[(2 * ceil32(return_data.size)) + 260] = 64
                                            mem[(2 * ceil32(return_data.size)) + 292] = 2
                                            idx = 0
                                            s = (2 * ceil32(return_data.size)) + 160
                                            t = (2 * ceil32(return_data.size)) + 324
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (4 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _4457 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                            require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                            require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                            _4533 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                revert with 0, 65
                                            if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                            mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            require return_data.size >= _4457 + (32 * _4533) + 32
                                            mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4533] = mem[(2 * ceil32(return_data.size)) + _4457 + 256 len 32 * _4533]
                                            if _4533 < 1:
                                                revert with 0, 17
                                            if _4533 - 1 >= _4533:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4533 - 1) + (4 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4533 - 1) + (4 * ceil32(return_data.size)) + 256]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4533 - 1) + (4 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4533 - 1) + (4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8201 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8201] == bool(mem[_8201])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8401 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8401] == mem[_8401 + 12 len 20]
                                            if address(arg2) == mem[_8401 + 12 len 20]:
                                                _8567 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8567]:
                                                    revert with 0, 50
                                                mem[_8567 + 32] = address(arg2)
                                                if 1 >= mem[_8567]:
                                                    revert with 0, 50
                                                mem[_8567 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8567 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8567 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8567 + 132] = arg4
                                                mem[_8567 + 164] = 160
                                                mem[_8567 + 260] = mem[_8567]
                                                idx = 0
                                                s = _8567 + 32
                                                t = _8567 + 292
                                                while idx < mem[_8567]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8567 + 196] = address(arg1)
                                                mem[_8567 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8567 + (32 * mem[_8567]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10927 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11031 = mem[_10927]
                                                require mem[_10927] <= test266151307()
                                                require _10927 + mem[_10927] + 31 < _10927 + return_data.size
                                                _11135 = mem[_10927 + mem[_10927]]
                                                if mem[_10927 + mem[_10927]] > test266151307():
                                                    revert with 0, 65
                                                if _10927 + ceil32(return_data.size) + ceil32(32 * mem[_10927 + mem[_10927]]) + 1 > test266151307() or ceil32(32 * mem[_10927 + mem[_10927]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10927 + ceil32(return_data.size) + ceil32(32 * mem[_10927 + mem[_10927]]) + 1
                                                mem[_10927 + ceil32(return_data.size)] = _11135
                                                require return_data.size >= _11031 + (32 * _11135) + 32
                                                mem[_10927 + ceil32(return_data.size) + 32 len 32 * _11135] = mem[_10927 + _11031 + 32 len 32 * _11135]
                                                if _11135 < 1:
                                                    revert with 0, 17
                                                if _11135 - 1 >= _11135:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11135 - 1) + _10927 + ceil32(return_data.size) + 32]
                                            else:
                                                _8564 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8564]:
                                                    revert with 0, 50
                                                mem[_8564 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8564]:
                                                    revert with 0, 50
                                                mem[_8564 + 32] = address(arg2)
                                                if 2 >= mem[_8564]:
                                                    revert with 0, 50
                                                mem[_8564 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8564 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8564 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8564 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8564 + ceil32(return_data.size) + 196] = 160
                                                mem[_8564 + ceil32(return_data.size) + 292] = mem[_8564]
                                                idx = 0
                                                s = _8564 + 32
                                                t = _8564 + ceil32(return_data.size) + 324
                                                while idx < mem[_8564]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8564 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8564 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8564 + ceil32(return_data.size) + (32 * mem[_8564]) + -mem[64] + 320]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10926 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11030 = mem[_10926]
                                                require mem[_10926] <= test266151307()
                                                require _10926 + mem[_10926] + 31 < _10926 + return_data.size
                                                _11134 = mem[_10926 + mem[_10926]]
                                                if mem[_10926 + mem[_10926]] > test266151307():
                                                    revert with 0, 65
                                                if _10926 + ceil32(return_data.size) + ceil32(32 * mem[_10926 + mem[_10926]]) + 1 > test266151307() or ceil32(32 * mem[_10926 + mem[_10926]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10926 + ceil32(return_data.size) + ceil32(32 * mem[_10926 + mem[_10926]]) + 1
                                                mem[_10926 + ceil32(return_data.size)] = _11134
                                                require return_data.size >= _11030 + (32 * _11134) + 32
                                                mem[_10926 + ceil32(return_data.size) + 32 len 32 * _11134] = mem[_10926 + _11030 + 32 len 32 * _11134]
                                                if _11134 < 1:
                                                    revert with 0, 17
                                                if _11134 - 1 >= _11134:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11134 - 1) + _10926 + ceil32(return_data.size) + 32]
                                        else:
                                            mem[(2 * ceil32(return_data.size)) + 128] = 3
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                            mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                                            mem[(4 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                            mem[(4 * ceil32(return_data.size)) + 292] = 64
                                            mem[(4 * ceil32(return_data.size)) + 324] = 3
                                            idx = 0
                                            s = (2 * ceil32(return_data.size)) + 160
                                            t = (4 * ceil32(return_data.size)) + 356
                                            while idx < 3:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 256
                                            require return_data.size >= 32
                                            _4456 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                            require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                            _4532 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                            mem[(6 * ceil32(return_data.size)) + 256] = _4532
                                            require return_data.size >= _4456 + (32 * _4532) + 32
                                            mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4532] = mem[(4 * ceil32(return_data.size)) + _4456 + 288 len 32 * _4532]
                                            if _4532 < 1:
                                                revert with 0, 17
                                            if _4532 - 1 >= _4532:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4532 - 1) + (6 * ceil32(return_data.size)) + 288] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4532 - 1) + (6 * ceil32(return_data.size)) + 288]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4532 - 1) + (6 * ceil32(return_data.size)) + 288]) - (sub_fd53fce0 * mem[(32 * _4532 - 1) + (6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8200 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8200] == bool(mem[_8200])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8400 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8400] == mem[_8400 + 12 len 20]
                                            if address(arg2) == mem[_8400 + 12 len 20]:
                                                _8563 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8563]:
                                                    revert with 0, 50
                                                mem[_8563 + 32] = address(arg2)
                                                if 1 >= mem[_8563]:
                                                    revert with 0, 50
                                                mem[_8563 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8563 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8563 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8563 + 132] = arg4
                                                mem[_8563 + 164] = 160
                                                mem[_8563 + 260] = mem[_8563]
                                                idx = 0
                                                s = _8563 + 32
                                                t = _8563 + 292
                                                while idx < mem[_8563]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8563 + 196] = address(arg1)
                                                mem[_8563 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8563 + (32 * mem[_8563]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10925 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11029 = mem[_10925]
                                                require mem[_10925] <= test266151307()
                                                require _10925 + mem[_10925] + 31 < _10925 + return_data.size
                                                _11133 = mem[_10925 + mem[_10925]]
                                                if mem[_10925 + mem[_10925]] > test266151307():
                                                    revert with 0, 65
                                                if _10925 + ceil32(return_data.size) + ceil32(32 * mem[_10925 + mem[_10925]]) + 1 > test266151307() or ceil32(32 * mem[_10925 + mem[_10925]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10925 + ceil32(return_data.size) + ceil32(32 * mem[_10925 + mem[_10925]]) + 1
                                                mem[_10925 + ceil32(return_data.size)] = _11133
                                                require return_data.size >= _11029 + (32 * _11133) + 32
                                                mem[_10925 + ceil32(return_data.size) + 32 len 32 * _11133] = mem[_10925 + _11029 + 32 len 32 * _11133]
                                                if _11133 < 1:
                                                    revert with 0, 17
                                                if _11133 - 1 >= _11133:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11133 - 1) + _10925 + ceil32(return_data.size) + 32]
                                            else:
                                                _8560 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8560]:
                                                    revert with 0, 50
                                                mem[_8560 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8560]:
                                                    revert with 0, 50
                                                mem[_8560 + 32] = address(arg2)
                                                if 2 >= mem[_8560]:
                                                    revert with 0, 50
                                                mem[_8560 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8560 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8560 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8560 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8560 + ceil32(return_data.size) + 196] = 160
                                                mem[_8560 + ceil32(return_data.size) + 292] = mem[_8560]
                                                idx = 0
                                                s = _8560 + 32
                                                t = _8560 + ceil32(return_data.size) + 324
                                                while idx < mem[_8560]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8560 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8560 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8560 + ceil32(return_data.size) + (32 * mem[_8560]) + -mem[64] + 320]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10924 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11028 = mem[_10924]
                                                require mem[_10924] <= test266151307()
                                                require _10924 + mem[_10924] + 31 < _10924 + return_data.size
                                                _11132 = mem[_10924 + mem[_10924]]
                                                if mem[_10924 + mem[_10924]] > test266151307():
                                                    revert with 0, 65
                                                if _10924 + ceil32(return_data.size) + ceil32(32 * mem[_10924 + mem[_10924]]) + 1 > test266151307() or ceil32(32 * mem[_10924 + mem[_10924]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10924 + ceil32(return_data.size) + ceil32(32 * mem[_10924 + mem[_10924]]) + 1
                                                mem[_10924 + ceil32(return_data.size)] = _11132
                                                require return_data.size >= _11028 + (32 * _11132) + 32
                                                mem[_10924 + ceil32(return_data.size) + 32 len 32 * _11132] = mem[_10924 + _11028 + 32 len 32 * _11132]
                                                if _11132 < 1:
                                                    revert with 0, 17
                                                if _11132 - 1 >= _11132:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11132 - 1) + _10924 + ceil32(return_data.size) + 32]
                                    else:
                                        mem[ceil32(return_data.size) + 132] = routerAddress
                                        mem[ceil32(return_data.size) + 164] = arg3
                                        require ext_code.size(address(arg2))
                                        call address(arg2).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args routerAddress, arg3
                                        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                        require ext_code.size(stor101)
                                        staticcall stor101.WAVAX() with:
                                                gas gas_remaining wei
                                        mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if address(arg2) == ext_call.return_data[12 len 20]:
                                            mem[(4 * ceil32(return_data.size)) + 128] = 2
                                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                                            mem[(4 * ceil32(return_data.size)) + 224] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                            mem[(4 * ceil32(return_data.size)) + 260] = 64
                                            mem[(4 * ceil32(return_data.size)) + 292] = 2
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 160
                                            t = (4 * ceil32(return_data.size)) + 324
                                            while idx < 2:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.getAmountsOut(uint256 arg1, address[] arg2) with:
                                                    gas gas_remaining wei
                                                   args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 224
                                            require return_data.size >= 32
                                            _4459 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                            _4535 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                revert with 0, 65
                                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                            require return_data.size >= _4459 + (32 * _4535) + 32
                                            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4535] = mem[(4 * ceil32(return_data.size)) + _4459 + 256 len 32 * _4535]
                                            if _4535 < 1:
                                                revert with 0, 17
                                            if _4535 - 1 >= _4535:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4535 - 1) + (6 * ceil32(return_data.size)) + 256] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4535 - 1) + (6 * ceil32(return_data.size)) + 256]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4535 - 1) + (6 * ceil32(return_data.size)) + 256]) - (sub_fd53fce0 * mem[(32 * _4535 - 1) + (6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8203 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8203] == bool(mem[_8203])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8403 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8403] == mem[_8403 + 12 len 20]
                                            if address(arg2) == mem[_8403 + 12 len 20]:
                                                _8575 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8575]:
                                                    revert with 0, 50
                                                mem[_8575 + 32] = address(arg2)
                                                if 1 >= mem[_8575]:
                                                    revert with 0, 50
                                                mem[_8575 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8575 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8575 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8575 + 132] = arg4
                                                mem[_8575 + 164] = 160
                                                mem[_8575 + 260] = mem[_8575]
                                                idx = 0
                                                s = _8575 + 32
                                                t = _8575 + 292
                                                while idx < mem[_8575]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8575 + 196] = address(arg1)
                                                mem[_8575 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8575 + (32 * mem[_8575]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10931 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11035 = mem[_10931]
                                                require mem[_10931] <= test266151307()
                                                require _10931 + mem[_10931] + 31 < _10931 + return_data.size
                                                _11139 = mem[_10931 + mem[_10931]]
                                                if mem[_10931 + mem[_10931]] > test266151307():
                                                    revert with 0, 65
                                                if _10931 + ceil32(return_data.size) + ceil32(32 * mem[_10931 + mem[_10931]]) + 1 > test266151307() or ceil32(32 * mem[_10931 + mem[_10931]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10931 + ceil32(return_data.size) + ceil32(32 * mem[_10931 + mem[_10931]]) + 1
                                                mem[_10931 + ceil32(return_data.size)] = _11139
                                                require return_data.size >= _11035 + (32 * _11139) + 32
                                                mem[_10931 + ceil32(return_data.size) + 32 len 32 * _11139] = mem[_10931 + _11035 + 32 len 32 * _11139]
                                                if _11139 < 1:
                                                    revert with 0, 17
                                                if _11139 - 1 >= _11139:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11139 - 1) + _10931 + ceil32(return_data.size) + 32]
                                            else:
                                                _8572 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8572]:
                                                    revert with 0, 50
                                                mem[_8572 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8572]:
                                                    revert with 0, 50
                                                mem[_8572 + 32] = address(arg2)
                                                if 2 >= mem[_8572]:
                                                    revert with 0, 50
                                                mem[_8572 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8572 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8572 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8572 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8572 + ceil32(return_data.size) + 196] = 160
                                                mem[_8572 + ceil32(return_data.size) + 292] = mem[_8572]
                                                idx = 0
                                                s = _8572 + 32
                                                t = _8572 + ceil32(return_data.size) + 324
                                                while idx < mem[_8572]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8572 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8572 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                     gas gas_remaining wei
                                                    args arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6), arg4, 160, address(arg1), arg5, mem[_8572 + ceil32(return_data.size) + 292 len (32 * mem[_8572]) + 32]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[_8572 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = _8572 + (2 * ceil32(return_data.size)) + 128
                                                require return_data.size >= 32
                                                _11034 = mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32
                                                require mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 <= test266151307()
                                                require _8572 + ceil32(return_data.size) + mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 159 < _8572 + ceil32(return_data.size) + return_data.size + 128
                                                _11138 = mem[_8572 + ceil32(return_data.size) + mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                                if mem[_8572 + ceil32(return_data.size) + mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128] > test266151307():
                                                    revert with 0, 65
                                                if _8572 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8572 + ceil32(return_data.size) + mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8572 + ceil32(return_data.size) + mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _8572 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8572 + ceil32(return_data.size) + mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]) + 129
                                                mem[_8572 + (2 * ceil32(return_data.size)) + 128] = mem[_8572 + ceil32(return_data.size) + mem[_8572 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)) >> 32 + 128]
                                                require return_data.size >= _11034 + (32 * _11138) + 32
                                                mem[_8572 + (2 * ceil32(return_data.size)) + 160 len 32 * _11138] = mem[_8572 + ceil32(return_data.size) + _11034 + 160 len 32 * _11138]
                                                if _11138 < 1:
                                                    revert with 0, 17
                                                if _11138 - 1 >= _11138:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11138 - 1) + _8572 + (2 * ceil32(return_data.size)) + 160]
                                        else:
                                            mem[(4 * ceil32(return_data.size)) + 128] = 3
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = (6 * ceil32(return_data.size)) + 256
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                            mem[(4 * ceil32(return_data.size)) + 224] = tokenAddress
                                            mem[(6 * ceil32(return_data.size)) + 256] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                            mem[(6 * ceil32(return_data.size)) + 292] = 64
                                            mem[(6 * ceil32(return_data.size)) + 324] = 3
                                            idx = 0
                                            s = (4 * ceil32(return_data.size)) + 160
                                            t = (6 * ceil32(return_data.size)) + 356
                                            while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                                mem[t] = mem[s + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(stor101)
                                            staticcall stor101.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _4394 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _4458 = mem[_4394]
                                            require mem[_4394] <= test266151307()
                                            require _4394 + mem[_4394] + 31 < _4394 + return_data.size
                                            _4534 = mem[_4394 + mem[_4394]]
                                            if mem[_4394 + mem[_4394]] > test266151307():
                                                revert with 0, 65
                                            if _4394 + ceil32(return_data.size) + ceil32(32 * mem[_4394 + mem[_4394]]) + 1 > test266151307() or ceil32(32 * mem[_4394 + mem[_4394]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _4394 + ceil32(return_data.size) + ceil32(32 * mem[_4394 + mem[_4394]]) + 1
                                            mem[_4394 + ceil32(return_data.size)] = _4534
                                            require return_data.size >= _4458 + (32 * _4534) + 32
                                            mem[_4394 + ceil32(return_data.size) + 32 len 32 * _4534] = mem[_4394 + _4458 + 32 len 32 * _4534]
                                            if _4534 < 1:
                                                revert with 0, 17
                                            if _4534 - 1 >= _4534:
                                                revert with 0, 50
                                            if 100 * 10^6 < sub_fd53fce0:
                                                revert with 0, 17
                                            if mem[(32 * _4534 - 1) + _4394 + ceil32(return_data.size) + 32] and -sub_fd53fce0 + 100 * 10^6 > -1 / mem[(32 * _4534 - 1) + _4394 + ceil32(return_data.size) + 32]:
                                                revert with 0, 17
                                            if (100 * 10^6 * mem[(32 * _4534 - 1) + _4394 + ceil32(return_data.size) + 32]) - (sub_fd53fce0 * mem[(32 * _4534 - 1) + _4394 + ceil32(return_data.size) + 32]) / 100 * 10^6 < arg4:
                                                revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
                                            if arg3 and sub_fd53fce0 > -1 / arg3:
                                                revert with 0, 17
                                            mem[mem[64] + 4] = sub_11eb47dcAddress
                                            mem[mem[64] + 36] = arg3 * sub_fd53fce0 / 100 * 10^6
                                            require ext_code.size(address(arg2))
                                            call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args sub_11eb47dcAddress, arg3 * sub_fd53fce0 / 100 * 10^6
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8202 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8202] == bool(mem[_8202])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8402 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8402] == mem[_8402 + 12 len 20]
                                            if address(arg2) == mem[_8402 + 12 len 20]:
                                                _8571 = mem[64]
                                                mem[mem[64]] = 2
                                                mem[64] = mem[64] + 96
                                                if 0 >= mem[_8571]:
                                                    revert with 0, 50
                                                mem[_8571 + 32] = address(arg2)
                                                if 1 >= mem[_8571]:
                                                    revert with 0, 50
                                                mem[_8571 + 64] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8571 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8571 + 100] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8571 + 132] = arg4
                                                mem[_8571 + 164] = 160
                                                mem[_8571 + 260] = mem[_8571]
                                                idx = 0
                                                s = _8571 + 32
                                                t = _8571 + 292
                                                while idx < mem[_8571]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8571 + 196] = address(arg1)
                                                mem[_8571 + 228] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8571 + (32 * mem[_8571]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10929 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11033 = mem[_10929]
                                                require mem[_10929] <= test266151307()
                                                require _10929 + mem[_10929] + 31 < _10929 + return_data.size
                                                _11137 = mem[_10929 + mem[_10929]]
                                                if mem[_10929 + mem[_10929]] > test266151307():
                                                    revert with 0, 65
                                                if _10929 + ceil32(return_data.size) + ceil32(32 * mem[_10929 + mem[_10929]]) + 1 > test266151307() or ceil32(32 * mem[_10929 + mem[_10929]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10929 + ceil32(return_data.size) + ceil32(32 * mem[_10929 + mem[_10929]]) + 1
                                                mem[_10929 + ceil32(return_data.size)] = _11137
                                                require return_data.size >= _11033 + (32 * _11137) + 32
                                                mem[_10929 + ceil32(return_data.size) + 32 len 32 * _11137] = mem[_10929 + _11033 + 32 len 32 * _11137]
                                                if _11137 < 1:
                                                    revert with 0, 17
                                                if _11137 - 1 >= _11137:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11137 - 1) + _10929 + ceil32(return_data.size) + 32]
                                            else:
                                                _8568 = mem[64]
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64] + 128] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                if 1 >= mem[_8568]:
                                                    revert with 0, 50
                                                mem[_8568 + 64] = ext_call.return_data[12 len 20]
                                                if 0 >= mem[_8568]:
                                                    revert with 0, 50
                                                mem[_8568 + 32] = address(arg2)
                                                if 2 >= mem[_8568]:
                                                    revert with 0, 50
                                                mem[_8568 + 96] = tokenAddress
                                                if arg3 < arg3 * sub_fd53fce0 / 100 * 10^6:
                                                    revert with 0, 17
                                                mem[_8568 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_8568 + ceil32(return_data.size) + 132] = arg3 - (arg3 * sub_fd53fce0 / 100 * 10^6)
                                                mem[_8568 + ceil32(return_data.size) + 164] = arg4
                                                mem[_8568 + ceil32(return_data.size) + 196] = 160
                                                mem[_8568 + ceil32(return_data.size) + 292] = mem[_8568]
                                                idx = 0
                                                s = _8568 + 32
                                                t = _8568 + ceil32(return_data.size) + 324
                                                while idx < mem[_8568]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_8568 + ceil32(return_data.size) + 228] = address(arg1)
                                                mem[_8568 + ceil32(return_data.size) + 260] = arg5
                                                require ext_code.size(stor101)
                                                call stor101.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _8568 + ceil32(return_data.size) + (32 * mem[_8568]) + -mem[64] + 320]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _10928 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _11032 = mem[_10928]
                                                require mem[_10928] <= test266151307()
                                                require _10928 + mem[_10928] + 31 < _10928 + return_data.size
                                                _11136 = mem[_10928 + mem[_10928]]
                                                if mem[_10928 + mem[_10928]] > test266151307():
                                                    revert with 0, 65
                                                if _10928 + ceil32(return_data.size) + ceil32(32 * mem[_10928 + mem[_10928]]) + 1 > test266151307() or ceil32(32 * mem[_10928 + mem[_10928]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _10928 + ceil32(return_data.size) + ceil32(32 * mem[_10928 + mem[_10928]]) + 1
                                                mem[_10928 + ceil32(return_data.size)] = _11136
                                                require return_data.size >= _11032 + (32 * _11136) + 32
                                                mem[_10928 + ceil32(return_data.size) + 32 len 32 * _11136] = mem[_10928 + _11032 + 32 len 32 * _11136]
                                                if _11136 < 1:
                                                    revert with 0, 17
                                                if _11136 - 1 >= _11136:
                                                    revert with 0, 50
                                                emit 0xfedb587d: address(arg2), arg3, tokenAddress, mem[(32 * _11136 - 1) + _10928 + ceil32(return_data.size) + 32]
                            else:
                                if unknown_0x74cefd8a(?????) == uint32(call.func_hash) >> 224:
                                    require not msg.value
                                    require calldata.size - 4 >= 160
                                    require arg1 == address(arg1)
                                    require arg2 == address(arg2)
                                    if msg.sender == tokenAddress:
                                        mem[132] = this.address
                                        mem[164] = routerAddress
                                        require ext_code.size(address(arg2))
                                        staticcall address(arg2).allowance(address arg1, address arg2) with:
                                                gas gas_remaining wei
                                               args address(this.address), routerAddress
                                        mem[128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] >= arg4:
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 2
                                                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                                                mem[(2 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(2 * ceil32(return_data.size)) + 260] = 64
                                                mem[(2 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (2 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (4 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4465 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                                _4541 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4465 + (32 * _4541) + 32
                                                mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4541] = mem[(2 * ceil32(return_data.size)) + _4465 + 256 len 32 * _4541]
                                                if 0 >= _4541:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7973 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7973] == mem[_7973 + 12 len 20]
                                                if address(arg2) == mem[_7973 + 12 len 20]:
                                                    _8071 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8071]:
                                                        revert with 0, 50
                                                    mem[_8071 + 32] = address(arg2)
                                                    if 1 >= mem[_8071]:
                                                        revert with 0, 50
                                                    mem[_8071 + 64] = tokenAddress
                                                    mem[_8071 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8071 + 100] = arg3
                                                    mem[_8071 + 132] = arg4
                                                    mem[_8071 + 164] = 160
                                                    mem[_8071 + 260] = mem[_8071]
                                                    idx = 0
                                                    s = _8071 + 32
                                                    t = _8071 + 292
                                                    while idx < mem[_8071]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8071 + 196] = address(arg1)
                                                    mem[_8071 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8071 + (32 * mem[_8071]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10943 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11047 = mem[_10943]
                                                    require mem[_10943] <= test266151307()
                                                    require _10943 + mem[_10943] + 31 < _10943 + return_data.size
                                                    _11151 = mem[_10943 + mem[_10943]]
                                                    if mem[_10943 + mem[_10943]] > test266151307():
                                                        revert with 0, 65
                                                    if _10943 + ceil32(return_data.size) + ceil32(32 * mem[_10943 + mem[_10943]]) + 1 > test266151307() or ceil32(32 * mem[_10943 + mem[_10943]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10943 + ceil32(return_data.size) + ceil32(32 * mem[_10943 + mem[_10943]]) + 1
                                                    mem[_10943 + ceil32(return_data.size)] = _11151
                                                    require return_data.size >= _11047 + (32 * _11151) + 32
                                                    mem[_10943 + ceil32(return_data.size) + 32 len 32 * _11151] = mem[_10943 + _11047 + 32 len 32 * _11151]
                                                    if 0 >= _11151:
                                                        revert with 0, 50
                                                    _12671 = mem[_10943 + ceil32(return_data.size) + 32]
                                                    if mem[_10943 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10943 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12671 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12671 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13167 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13167] == bool(mem[_13167])
                                                    if arg4 < _12671:
                                                        revert with 0, 17
                                                    if arg4 - _12671 < _12671 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12671 - (_12671 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12671 - (_12671 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13359 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13359] == bool(mem[_13359])
                                                    emit 0xfedb587d: address(arg2), _12671, tokenAddress, arg3
                                                else:
                                                    _8068 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8068]:
                                                        revert with 0, 50
                                                    mem[_8068 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8068]:
                                                        revert with 0, 50
                                                    mem[_8068 + 32] = address(arg2)
                                                    if 2 >= mem[_8068]:
                                                        revert with 0, 50
                                                    mem[_8068 + 96] = tokenAddress
                                                    mem[_8068 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8068 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8068 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8068 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8068 + ceil32(return_data.size) + 292] = mem[_8068]
                                                    idx = 0
                                                    s = _8068 + 32
                                                    t = _8068 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8068]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8068 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8068 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8068 + ceil32(return_data.size) + (32 * mem[_8068]) + -mem[64] + 320]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10942 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11046 = mem[_10942]
                                                    require mem[_10942] <= test266151307()
                                                    require _10942 + mem[_10942] + 31 < _10942 + return_data.size
                                                    _11150 = mem[_10942 + mem[_10942]]
                                                    if mem[_10942 + mem[_10942]] > test266151307():
                                                        revert with 0, 65
                                                    if _10942 + ceil32(return_data.size) + ceil32(32 * mem[_10942 + mem[_10942]]) + 1 > test266151307() or ceil32(32 * mem[_10942 + mem[_10942]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10942 + ceil32(return_data.size) + ceil32(32 * mem[_10942 + mem[_10942]]) + 1
                                                    mem[_10942 + ceil32(return_data.size)] = _11150
                                                    require return_data.size >= _11046 + (32 * _11150) + 32
                                                    mem[_10942 + ceil32(return_data.size) + 32 len 32 * _11150] = mem[_10942 + _11046 + 32 len 32 * _11150]
                                                    if 0 >= _11150:
                                                        revert with 0, 50
                                                    _12670 = mem[_10942 + ceil32(return_data.size) + 32]
                                                    if mem[_10942 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10942 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12670 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12670 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13166 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13166] == bool(mem[_13166])
                                                    if arg4 < _12670:
                                                        revert with 0, 17
                                                    if arg4 - _12670 < _12670 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12670 - (_12670 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12670 - (_12670 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13358 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13358] == bool(mem[_13358])
                                                    emit 0xfedb587d: address(arg2), _12670, tokenAddress, arg3
                                            else:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 292] = 64
                                                mem[(4 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 356
                                                while idx < 3:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                _4464 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                                _4540 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                                mem[(6 * ceil32(return_data.size)) + 256] = _4540
                                                require return_data.size >= _4464 + (32 * _4540) + 32
                                                mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4540] = mem[(4 * ceil32(return_data.size)) + _4464 + 288 len 32 * _4540]
                                                if 0 >= _4540:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 288] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 288]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 288]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7972 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7972] == mem[_7972 + 12 len 20]
                                                if address(arg2) == mem[_7972 + 12 len 20]:
                                                    _8067 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8067]:
                                                        revert with 0, 50
                                                    mem[_8067 + 32] = address(arg2)
                                                    if 1 >= mem[_8067]:
                                                        revert with 0, 50
                                                    mem[_8067 + 64] = tokenAddress
                                                    mem[_8067 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8067 + 100] = arg3
                                                    mem[_8067 + 132] = arg4
                                                    mem[_8067 + 164] = 160
                                                    mem[_8067 + 260] = mem[_8067]
                                                    idx = 0
                                                    s = _8067 + 32
                                                    t = _8067 + 292
                                                    while idx < mem[_8067]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8067 + 196] = address(arg1)
                                                    mem[_8067 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8067 + (32 * mem[_8067]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10941 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11045 = mem[_10941]
                                                    require mem[_10941] <= test266151307()
                                                    require _10941 + mem[_10941] + 31 < _10941 + return_data.size
                                                    _11149 = mem[_10941 + mem[_10941]]
                                                    if mem[_10941 + mem[_10941]] > test266151307():
                                                        revert with 0, 65
                                                    if _10941 + ceil32(return_data.size) + ceil32(32 * mem[_10941 + mem[_10941]]) + 1 > test266151307() or ceil32(32 * mem[_10941 + mem[_10941]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10941 + ceil32(return_data.size) + ceil32(32 * mem[_10941 + mem[_10941]]) + 1
                                                    mem[_10941 + ceil32(return_data.size)] = _11149
                                                    require return_data.size >= _11045 + (32 * _11149) + 32
                                                    mem[_10941 + ceil32(return_data.size) + 32 len 32 * _11149] = mem[_10941 + _11045 + 32 len 32 * _11149]
                                                    if 0 >= _11149:
                                                        revert with 0, 50
                                                    _12669 = mem[_10941 + ceil32(return_data.size) + 32]
                                                    if mem[_10941 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10941 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12669 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12669 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13165 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13165] == bool(mem[_13165])
                                                    if arg4 < _12669:
                                                        revert with 0, 17
                                                    if arg4 - _12669 < _12669 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12669 - (_12669 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12669 - (_12669 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13357 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13357] == bool(mem[_13357])
                                                    emit 0xfedb587d: address(arg2), _12669, tokenAddress, arg3
                                                else:
                                                    _8064 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8064]:
                                                        revert with 0, 50
                                                    mem[_8064 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8064]:
                                                        revert with 0, 50
                                                    mem[_8064 + 32] = address(arg2)
                                                    if 2 >= mem[_8064]:
                                                        revert with 0, 50
                                                    mem[_8064 + 96] = tokenAddress
                                                    mem[_8064 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8064 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8064 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8064 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8064 + ceil32(return_data.size) + 292] = mem[_8064]
                                                    idx = 0
                                                    s = _8064 + 32
                                                    t = _8064 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8064]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8064 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8064 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args arg3, arg4, 160, address(arg1), arg5, mem[_8064 + ceil32(return_data.size) + 292 len (32 * mem[_8064]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_8064 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8064 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    _11044 = mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                    require mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                    require _8064 + ceil32(return_data.size) + mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8064 + ceil32(return_data.size) + return_data.size + 128
                                                    _11148 = mem[_8064 + ceil32(return_data.size) + mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                    if mem[_8064 + ceil32(return_data.size) + mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                        revert with 0, 65
                                                    if _8064 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8064 + ceil32(return_data.size) + mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8064 + ceil32(return_data.size) + mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8064 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8064 + ceil32(return_data.size) + mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                    mem[_8064 + (2 * ceil32(return_data.size)) + 128] = mem[_8064 + ceil32(return_data.size) + mem[_8064 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                    require return_data.size >= _11044 + (32 * _11148) + 32
                                                    mem[_8064 + (2 * ceil32(return_data.size)) + 160 len 32 * _11148] = mem[_8064 + ceil32(return_data.size) + _11044 + 160 len 32 * _11148]
                                                    if 0 >= _11148:
                                                        revert with 0, 50
                                                    _12668 = mem[_8064 + (2 * ceil32(return_data.size)) + 160]
                                                    if mem[_8064 + (2 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8064 + (2 * ceil32(return_data.size)) + 160]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12668 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12668 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13164 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13164] == bool(mem[_13164])
                                                    if arg4 < _12668:
                                                        revert with 0, 17
                                                    if arg4 - _12668 < _12668 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12668 - (_12668 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12668 - (_12668 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13356 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13356] == bool(mem[_13356])
                                                    emit 0xfedb587d: address(arg2), _12668, tokenAddress, arg3
                                        else:
                                            mem[ceil32(return_data.size) + 132] = routerAddress
                                            mem[ceil32(return_data.size) + 164] = arg4
                                            require ext_code.size(address(arg2))
                                            call address(arg2).approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, arg4
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 2
                                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 260] = 64
                                                mem[(4 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4467 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                                _4543 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4467 + (32 * _4543) + 32
                                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4543] = mem[(4 * ceil32(return_data.size)) + _4467 + 256 len 32 * _4543]
                                                if 0 >= _4543:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7975 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7975] == mem[_7975 + 12 len 20]
                                                if address(arg2) == mem[_7975 + 12 len 20]:
                                                    _8079 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8079]:
                                                        revert with 0, 50
                                                    mem[_8079 + 32] = address(arg2)
                                                    if 1 >= mem[_8079]:
                                                        revert with 0, 50
                                                    mem[_8079 + 64] = tokenAddress
                                                    mem[_8079 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8079 + 100] = arg3
                                                    mem[_8079 + 132] = arg4
                                                    mem[_8079 + 164] = 160
                                                    mem[_8079 + 260] = mem[_8079]
                                                    idx = 0
                                                    s = _8079 + 32
                                                    t = _8079 + 292
                                                    while idx < mem[_8079]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8079 + 196] = address(arg1)
                                                    mem[_8079 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8079 + (32 * mem[_8079]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10947 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11051 = mem[_10947]
                                                    require mem[_10947] <= test266151307()
                                                    require _10947 + mem[_10947] + 31 < _10947 + return_data.size
                                                    _11155 = mem[_10947 + mem[_10947]]
                                                    if mem[_10947 + mem[_10947]] > test266151307():
                                                        revert with 0, 65
                                                    if _10947 + ceil32(return_data.size) + ceil32(32 * mem[_10947 + mem[_10947]]) + 1 > test266151307() or ceil32(32 * mem[_10947 + mem[_10947]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10947 + ceil32(return_data.size) + ceil32(32 * mem[_10947 + mem[_10947]]) + 1
                                                    mem[_10947 + ceil32(return_data.size)] = _11155
                                                    require return_data.size >= _11051 + (32 * _11155) + 32
                                                    mem[_10947 + ceil32(return_data.size) + 32 len 32 * _11155] = mem[_10947 + _11051 + 32 len 32 * _11155]
                                                    if 0 >= _11155:
                                                        revert with 0, 50
                                                    _12675 = mem[_10947 + ceil32(return_data.size) + 32]
                                                    if mem[_10947 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10947 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12675 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12675 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13171 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13171] == bool(mem[_13171])
                                                    if arg4 < _12675:
                                                        revert with 0, 17
                                                    if arg4 - _12675 < _12675 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12675 - (_12675 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12675 - (_12675 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13363 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13363] == bool(mem[_13363])
                                                    emit 0xfedb587d: address(arg2), _12675, tokenAddress, arg3
                                                else:
                                                    _8076 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8076]:
                                                        revert with 0, 50
                                                    mem[_8076 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8076]:
                                                        revert with 0, 50
                                                    mem[_8076 + 32] = address(arg2)
                                                    if 2 >= mem[_8076]:
                                                        revert with 0, 50
                                                    mem[_8076 + 96] = tokenAddress
                                                    mem[_8076 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8076 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8076 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8076 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8076 + ceil32(return_data.size) + 292] = mem[_8076]
                                                    idx = 0
                                                    s = _8076 + 32
                                                    t = _8076 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8076]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8076 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8076 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                         gas gas_remaining wei
                                                        args arg3, arg4, 160, address(arg1), arg5, mem[_8076 + ceil32(return_data.size) + 292 len (32 * mem[_8076]) + 32]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[_8076 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8076 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    _11050 = mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                    require mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                    require _8076 + ceil32(return_data.size) + mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8076 + ceil32(return_data.size) + return_data.size + 128
                                                    _11154 = mem[_8076 + ceil32(return_data.size) + mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                    if mem[_8076 + ceil32(return_data.size) + mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                        revert with 0, 65
                                                    if _8076 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8076 + ceil32(return_data.size) + mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8076 + ceil32(return_data.size) + mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _8076 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8076 + ceil32(return_data.size) + mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                    mem[_8076 + (2 * ceil32(return_data.size)) + 128] = mem[_8076 + ceil32(return_data.size) + mem[_8076 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                    require return_data.size >= _11050 + (32 * _11154) + 32
                                                    mem[_8076 + (2 * ceil32(return_data.size)) + 160 len 32 * _11154] = mem[_8076 + ceil32(return_data.size) + _11050 + 160 len 32 * _11154]
                                                    if 0 >= _11154:
                                                        revert with 0, 50
                                                    _12674 = mem[_8076 + (2 * ceil32(return_data.size)) + 160]
                                                    if mem[_8076 + (2 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8076 + (2 * ceil32(return_data.size)) + 160]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12674 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12674 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13170 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13170] == bool(mem[_13170])
                                                    if arg4 < _12674:
                                                        revert with 0, 17
                                                    if arg4 - _12674 < _12674 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12674 - (_12674 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12674 - (_12674 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13362 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13362] == bool(mem[_13362])
                                                    emit 0xfedb587d: address(arg2), _12674, tokenAddress, arg3
                                            else:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 224] = tokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(6 * ceil32(return_data.size)) + 292] = 64
                                                mem[(6 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (6 * ceil32(return_data.size)) + 356
                                                while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.mem[mem[64] len 4] with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4402 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _4466 = mem[_4402]
                                                require mem[_4402] <= test266151307()
                                                require _4402 + mem[_4402] + 31 < _4402 + return_data.size
                                                _4542 = mem[_4402 + mem[_4402]]
                                                if mem[_4402 + mem[_4402]] > test266151307():
                                                    revert with 0, 65
                                                if _4402 + ceil32(return_data.size) + ceil32(32 * mem[_4402 + mem[_4402]]) + 1 > test266151307() or ceil32(32 * mem[_4402 + mem[_4402]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _4402 + ceil32(return_data.size) + ceil32(32 * mem[_4402 + mem[_4402]]) + 1
                                                mem[_4402 + ceil32(return_data.size)] = _4542
                                                require return_data.size >= _4466 + (32 * _4542) + 32
                                                mem[_4402 + ceil32(return_data.size) + 32 len 32 * _4542] = mem[_4402 + _4466 + 32 len 32 * _4542]
                                                if 0 >= _4542:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[_4402 + ceil32(return_data.size) + 32] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[_4402 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[_4402 + ceil32(return_data.size) + 32]) + (sub_fd53fce0 * mem[_4402 + ceil32(return_data.size) + 32]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7974 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7974] == mem[_7974 + 12 len 20]
                                                if address(arg2) == mem[_7974 + 12 len 20]:
                                                    _8075 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8075]:
                                                        revert with 0, 50
                                                    mem[_8075 + 32] = address(arg2)
                                                    if 1 >= mem[_8075]:
                                                        revert with 0, 50
                                                    mem[_8075 + 64] = tokenAddress
                                                    mem[_8075 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8075 + 100] = arg3
                                                    mem[_8075 + 132] = arg4
                                                    mem[_8075 + 164] = 160
                                                    mem[_8075 + 260] = mem[_8075]
                                                    idx = 0
                                                    s = _8075 + 32
                                                    t = _8075 + 292
                                                    while idx < mem[_8075]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8075 + 196] = address(arg1)
                                                    mem[_8075 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8075 + (32 * mem[_8075]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10945 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11049 = mem[_10945]
                                                    require mem[_10945] <= test266151307()
                                                    require _10945 + mem[_10945] + 31 < _10945 + return_data.size
                                                    _11153 = mem[_10945 + mem[_10945]]
                                                    if mem[_10945 + mem[_10945]] > test266151307():
                                                        revert with 0, 65
                                                    if _10945 + ceil32(return_data.size) + ceil32(32 * mem[_10945 + mem[_10945]]) + 1 > test266151307() or ceil32(32 * mem[_10945 + mem[_10945]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10945 + ceil32(return_data.size) + ceil32(32 * mem[_10945 + mem[_10945]]) + 1
                                                    mem[_10945 + ceil32(return_data.size)] = _11153
                                                    require return_data.size >= _11049 + (32 * _11153) + 32
                                                    mem[_10945 + ceil32(return_data.size) + 32 len 32 * _11153] = mem[_10945 + _11049 + 32 len 32 * _11153]
                                                    if 0 >= _11153:
                                                        revert with 0, 50
                                                    _12673 = mem[_10945 + ceil32(return_data.size) + 32]
                                                    if mem[_10945 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10945 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12673 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12673 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13169 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13169] == bool(mem[_13169])
                                                    if arg4 < _12673:
                                                        revert with 0, 17
                                                    if arg4 - _12673 < _12673 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12673 - (_12673 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12673 - (_12673 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13361 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13361] == bool(mem[_13361])
                                                    emit 0xfedb587d: address(arg2), _12673, tokenAddress, arg3
                                                else:
                                                    _8072 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8072]:
                                                        revert with 0, 50
                                                    mem[_8072 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8072]:
                                                        revert with 0, 50
                                                    mem[_8072 + 32] = address(arg2)
                                                    if 2 >= mem[_8072]:
                                                        revert with 0, 50
                                                    mem[_8072 + 96] = tokenAddress
                                                    mem[_8072 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8072 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8072 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8072 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8072 + ceil32(return_data.size) + 292] = mem[_8072]
                                                    idx = 0
                                                    s = _8072 + 32
                                                    t = _8072 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8072]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8072 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8072 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8072 + ceil32(return_data.size) + (32 * mem[_8072]) + -mem[64] + 320]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10944 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11048 = mem[_10944]
                                                    require mem[_10944] <= test266151307()
                                                    require _10944 + mem[_10944] + 31 < _10944 + return_data.size
                                                    _11152 = mem[_10944 + mem[_10944]]
                                                    if mem[_10944 + mem[_10944]] > test266151307():
                                                        revert with 0, 65
                                                    if _10944 + ceil32(return_data.size) + ceil32(32 * mem[_10944 + mem[_10944]]) + 1 > test266151307() or ceil32(32 * mem[_10944 + mem[_10944]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10944 + ceil32(return_data.size) + ceil32(32 * mem[_10944 + mem[_10944]]) + 1
                                                    mem[_10944 + ceil32(return_data.size)] = _11152
                                                    require return_data.size >= _11048 + (32 * _11152) + 32
                                                    mem[_10944 + ceil32(return_data.size) + 32 len 32 * _11152] = mem[_10944 + _11048 + 32 len 32 * _11152]
                                                    if 0 >= _11152:
                                                        revert with 0, 50
                                                    _12672 = mem[_10944 + ceil32(return_data.size) + 32]
                                                    if mem[_10944 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10944 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12672 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12672 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13168 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13168] == bool(mem[_13168])
                                                    if arg4 < _12672:
                                                        revert with 0, 17
                                                    if arg4 - _12672 < _12672 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12672 - (_12672 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12672 - (_12672 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13360 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13360] == bool(mem[_13360])
                                                    emit 0xfedb587d: address(arg2), _12672, tokenAddress, arg3
                                    else:
                                        if address(sub_0584aecfAddress) != msg.sender:
                                            revert with 0, 'Access Denied!'
                                        mem[132] = this.address
                                        mem[164] = routerAddress
                                        require ext_code.size(address(arg2))
                                        staticcall address(arg2).allowance(address arg1, address arg2) with:
                                                gas gas_remaining wei
                                               args address(this.address), routerAddress
                                        mem[128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] >= arg4:
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 2
                                                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(2 * ceil32(return_data.size)) + 192] = tokenAddress
                                                mem[(2 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(2 * ceil32(return_data.size)) + 260] = 64
                                                mem[(2 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (2 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (4 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4469 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                                _4545 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4469 + (32 * _4545) + 32
                                                mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4545] = mem[(2 * ceil32(return_data.size)) + _4469 + 256 len 32 * _4545]
                                                if 0 >= _4545:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7977 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7977] == mem[_7977 + 12 len 20]
                                                if address(arg2) == mem[_7977 + 12 len 20]:
                                                    _8087 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8087]:
                                                        revert with 0, 50
                                                    mem[_8087 + 32] = address(arg2)
                                                    if 1 >= mem[_8087]:
                                                        revert with 0, 50
                                                    mem[_8087 + 64] = tokenAddress
                                                    mem[_8087 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8087 + 100] = arg3
                                                    mem[_8087 + 132] = arg4
                                                    mem[_8087 + 164] = 160
                                                    mem[_8087 + 260] = mem[_8087]
                                                    idx = 0
                                                    s = _8087 + 32
                                                    t = _8087 + 292
                                                    while idx < mem[_8087]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8087 + 196] = address(arg1)
                                                    mem[_8087 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8087 + (32 * mem[_8087]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10951 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11055 = mem[_10951]
                                                    require mem[_10951] <= test266151307()
                                                    require _10951 + mem[_10951] + 31 < _10951 + return_data.size
                                                    _11159 = mem[_10951 + mem[_10951]]
                                                    if mem[_10951 + mem[_10951]] > test266151307():
                                                        revert with 0, 65
                                                    if _10951 + ceil32(return_data.size) + ceil32(32 * mem[_10951 + mem[_10951]]) + 1 > test266151307() or ceil32(32 * mem[_10951 + mem[_10951]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10951 + ceil32(return_data.size) + ceil32(32 * mem[_10951 + mem[_10951]]) + 1
                                                    mem[_10951 + ceil32(return_data.size)] = _11159
                                                    require return_data.size >= _11055 + (32 * _11159) + 32
                                                    mem[_10951 + ceil32(return_data.size) + 32 len 32 * _11159] = mem[_10951 + _11055 + 32 len 32 * _11159]
                                                    if 0 >= _11159:
                                                        revert with 0, 50
                                                    _12679 = mem[_10951 + ceil32(return_data.size) + 32]
                                                    if mem[_10951 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10951 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12679 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12679 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13175 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13175] == bool(mem[_13175])
                                                    if arg4 < _12679:
                                                        revert with 0, 17
                                                    if arg4 - _12679 < _12679 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12679 - (_12679 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12679 - (_12679 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13367 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13367] == bool(mem[_13367])
                                                    emit 0xfedb587d: address(arg2), _12679, tokenAddress, arg3
                                                else:
                                                    _8084 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8084]:
                                                        revert with 0, 50
                                                    mem[_8084 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8084]:
                                                        revert with 0, 50
                                                    mem[_8084 + 32] = address(arg2)
                                                    if 2 >= mem[_8084]:
                                                        revert with 0, 50
                                                    mem[_8084 + 96] = tokenAddress
                                                    mem[_8084 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8084 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8084 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8084 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8084 + ceil32(return_data.size) + 292] = mem[_8084]
                                                    idx = 0
                                                    s = _8084 + 32
                                                    t = _8084 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8084]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8084 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8084 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8084 + ceil32(return_data.size) + (32 * mem[_8084]) + -mem[64] + 320]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10950 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11054 = mem[_10950]
                                                    require mem[_10950] <= test266151307()
                                                    require _10950 + mem[_10950] + 31 < _10950 + return_data.size
                                                    _11158 = mem[_10950 + mem[_10950]]
                                                    if mem[_10950 + mem[_10950]] > test266151307():
                                                        revert with 0, 65
                                                    if _10950 + ceil32(return_data.size) + ceil32(32 * mem[_10950 + mem[_10950]]) + 1 > test266151307() or ceil32(32 * mem[_10950 + mem[_10950]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10950 + ceil32(return_data.size) + ceil32(32 * mem[_10950 + mem[_10950]]) + 1
                                                    mem[_10950 + ceil32(return_data.size)] = _11158
                                                    require return_data.size >= _11054 + (32 * _11158) + 32
                                                    mem[_10950 + ceil32(return_data.size) + 32 len 32 * _11158] = mem[_10950 + _11054 + 32 len 32 * _11158]
                                                    if 0 >= _11158:
                                                        revert with 0, 50
                                                    _12678 = mem[_10950 + ceil32(return_data.size) + 32]
                                                    if mem[_10950 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10950 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12678 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12678 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13174 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13174] == bool(mem[_13174])
                                                    if arg4 < _12678:
                                                        revert with 0, 17
                                                    if arg4 - _12678 < _12678 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12678 - (_12678 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12678 - (_12678 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13366 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13366] == bool(mem[_13366])
                                                    emit 0xfedb587d: address(arg2), _12678, tokenAddress, arg3
                                            else:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(2 * ceil32(return_data.size)) + 224] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 292] = 64
                                                mem[(4 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 356
                                                while idx < 3:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                _4468 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                                _4544 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                                mem[(6 * ceil32(return_data.size)) + 256] = _4544
                                                require return_data.size >= _4468 + (32 * _4544) + 32
                                                mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4544] = mem[(4 * ceil32(return_data.size)) + _4468 + 288 len 32 * _4544]
                                                if 0 >= _4544:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 288] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 288]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 288]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7976 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7976] == mem[_7976 + 12 len 20]
                                                if address(arg2) == mem[_7976 + 12 len 20]:
                                                    _8083 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8083]:
                                                        revert with 0, 50
                                                    mem[_8083 + 32] = address(arg2)
                                                    if 1 >= mem[_8083]:
                                                        revert with 0, 50
                                                    mem[_8083 + 64] = tokenAddress
                                                    mem[_8083 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8083 + 100] = arg3
                                                    mem[_8083 + 132] = arg4
                                                    mem[_8083 + 164] = 160
                                                    mem[_8083 + 260] = mem[_8083]
                                                    idx = 0
                                                    s = _8083 + 32
                                                    t = _8083 + 292
                                                    while idx < mem[_8083]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8083 + 196] = address(arg1)
                                                    mem[_8083 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8083 + (32 * mem[_8083]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10949 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11053 = mem[_10949]
                                                    require mem[_10949] <= test266151307()
                                                    require _10949 + mem[_10949] + 31 < _10949 + return_data.size
                                                    _11157 = mem[_10949 + mem[_10949]]
                                                    if mem[_10949 + mem[_10949]] > test266151307():
                                                        revert with 0, 65
                                                    if _10949 + ceil32(return_data.size) + ceil32(32 * mem[_10949 + mem[_10949]]) + 1 > test266151307() or ceil32(32 * mem[_10949 + mem[_10949]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10949 + ceil32(return_data.size) + ceil32(32 * mem[_10949 + mem[_10949]]) + 1
                                                    mem[_10949 + ceil32(return_data.size)] = _11157
                                                    require return_data.size >= _11053 + (32 * _11157) + 32
                                                    mem[_10949 + ceil32(return_data.size) + 32 len 32 * _11157] = mem[_10949 + _11053 + 32 len 32 * _11157]
                                                    if 0 >= _11157:
                                                        revert with 0, 50
                                                    _12677 = mem[_10949 + ceil32(return_data.size) + 32]
                                                    if mem[_10949 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10949 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12677 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12677 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13173 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13173] == bool(mem[_13173])
                                                    if arg4 < _12677:
                                                        revert with 0, 17
                                                    if arg4 - _12677 < _12677 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12677 - (_12677 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12677 - (_12677 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13365 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13365] == bool(mem[_13365])
                                                    emit 0xfedb587d: address(arg2), _12677, tokenAddress, arg3
                                                else:
                                                    _8080 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8080]:
                                                        revert with 0, 50
                                                    mem[_8080 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8080]:
                                                        revert with 0, 50
                                                    mem[_8080 + 32] = address(arg2)
                                                    if 2 >= mem[_8080]:
                                                        revert with 0, 50
                                                    mem[_8080 + 96] = tokenAddress
                                                    mem[_8080 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8080 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8080 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8080 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8080 + ceil32(return_data.size) + 292] = mem[_8080]
                                                    idx = 0
                                                    s = _8080 + 32
                                                    t = _8080 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8080]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8080 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8080 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8080 + ceil32(return_data.size) + (32 * mem[_8080]) + -mem[64] + 320]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10948 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11052 = mem[_10948]
                                                    require mem[_10948] <= test266151307()
                                                    require _10948 + mem[_10948] + 31 < _10948 + return_data.size
                                                    _11156 = mem[_10948 + mem[_10948]]
                                                    if mem[_10948 + mem[_10948]] > test266151307():
                                                        revert with 0, 65
                                                    if _10948 + ceil32(return_data.size) + ceil32(32 * mem[_10948 + mem[_10948]]) + 1 > test266151307() or ceil32(32 * mem[_10948 + mem[_10948]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10948 + ceil32(return_data.size) + ceil32(32 * mem[_10948 + mem[_10948]]) + 1
                                                    mem[_10948 + ceil32(return_data.size)] = _11156
                                                    require return_data.size >= _11052 + (32 * _11156) + 32
                                                    mem[_10948 + ceil32(return_data.size) + 32 len 32 * _11156] = mem[_10948 + _11052 + 32 len 32 * _11156]
                                                    if 0 >= _11156:
                                                        revert with 0, 50
                                                    _12676 = mem[_10948 + ceil32(return_data.size) + 32]
                                                    if mem[_10948 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10948 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12676 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12676 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13172 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13172] == bool(mem[_13172])
                                                    if arg4 < _12676:
                                                        revert with 0, 17
                                                    if arg4 - _12676 < _12676 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12676 - (_12676 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12676 - (_12676 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13364 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13364] == bool(mem[_13364])
                                                    emit 0xfedb587d: address(arg2), _12676, tokenAddress, arg3
                                        else:
                                            mem[ceil32(return_data.size) + 132] = routerAddress
                                            mem[ceil32(return_data.size) + 164] = arg4
                                            require ext_code.size(address(arg2))
                                            call address(arg2).approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, arg4
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 2
                                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 192] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 260] = 64
                                                mem[(4 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4471 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                                _4547 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4471 + (32 * _4547) + 32
                                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4547] = mem[(4 * ceil32(return_data.size)) + _4471 + 256 len 32 * _4547]
                                                if 0 >= _4547:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7979 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7979] == mem[_7979 + 12 len 20]
                                                if address(arg2) == mem[_7979 + 12 len 20]:
                                                    _8095 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8095]:
                                                        revert with 0, 50
                                                    mem[_8095 + 32] = address(arg2)
                                                    if 1 >= mem[_8095]:
                                                        revert with 0, 50
                                                    mem[_8095 + 64] = tokenAddress
                                                    mem[_8095 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8095 + 100] = arg3
                                                    mem[_8095 + 132] = arg4
                                                    mem[_8095 + 164] = 160
                                                    mem[_8095 + 260] = mem[_8095]
                                                    idx = 0
                                                    s = _8095 + 32
                                                    t = _8095 + 292
                                                    while idx < mem[_8095]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8095 + 196] = address(arg1)
                                                    mem[_8095 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8095 + (32 * mem[_8095]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10955 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11059 = mem[_10955]
                                                    require mem[_10955] <= test266151307()
                                                    require _10955 + mem[_10955] + 31 < _10955 + return_data.size
                                                    _11163 = mem[_10955 + mem[_10955]]
                                                    if mem[_10955 + mem[_10955]] > test266151307():
                                                        revert with 0, 65
                                                    if _10955 + ceil32(return_data.size) + ceil32(32 * mem[_10955 + mem[_10955]]) + 1 > test266151307() or ceil32(32 * mem[_10955 + mem[_10955]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10955 + ceil32(return_data.size) + ceil32(32 * mem[_10955 + mem[_10955]]) + 1
                                                    mem[_10955 + ceil32(return_data.size)] = _11163
                                                    require return_data.size >= _11059 + (32 * _11163) + 32
                                                    mem[_10955 + ceil32(return_data.size) + 32 len 32 * _11163] = mem[_10955 + _11059 + 32 len 32 * _11163]
                                                    if 0 >= _11163:
                                                        revert with 0, 50
                                                    _12683 = mem[_10955 + ceil32(return_data.size) + 32]
                                                    if mem[_10955 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10955 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12683 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12683 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13179 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13179] == bool(mem[_13179])
                                                    if arg4 < _12683:
                                                        revert with 0, 17
                                                    if arg4 - _12683 < _12683 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12683 - (_12683 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12683 - (_12683 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13371 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13371] == bool(mem[_13371])
                                                    emit 0xfedb587d: address(arg2), _12683, tokenAddress, arg3
                                                else:
                                                    _8092 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8092]:
                                                        revert with 0, 50
                                                    mem[_8092 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8092]:
                                                        revert with 0, 50
                                                    mem[_8092 + 32] = address(arg2)
                                                    if 2 >= mem[_8092]:
                                                        revert with 0, 50
                                                    mem[_8092 + 96] = tokenAddress
                                                    mem[_8092 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8092 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8092 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8092 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8092 + ceil32(return_data.size) + 292] = mem[_8092]
                                                    idx = 0
                                                    s = _8092 + 32
                                                    t = _8092 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8092]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8092 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8092 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8092 + ceil32(return_data.size) + (32 * mem[_8092]) + -mem[64] + 320]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10954 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11058 = mem[_10954]
                                                    require mem[_10954] <= test266151307()
                                                    require _10954 + mem[_10954] + 31 < _10954 + return_data.size
                                                    _11162 = mem[_10954 + mem[_10954]]
                                                    if mem[_10954 + mem[_10954]] > test266151307():
                                                        revert with 0, 65
                                                    if _10954 + ceil32(return_data.size) + ceil32(32 * mem[_10954 + mem[_10954]]) + 1 > test266151307() or ceil32(32 * mem[_10954 + mem[_10954]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10954 + ceil32(return_data.size) + ceil32(32 * mem[_10954 + mem[_10954]]) + 1
                                                    mem[_10954 + ceil32(return_data.size)] = _11162
                                                    require return_data.size >= _11058 + (32 * _11162) + 32
                                                    mem[_10954 + ceil32(return_data.size) + 32 len 32 * _11162] = mem[_10954 + _11058 + 32 len 32 * _11162]
                                                    if 0 >= _11162:
                                                        revert with 0, 50
                                                    _12682 = mem[_10954 + ceil32(return_data.size) + 32]
                                                    if mem[_10954 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10954 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12682 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12682 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13178 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13178] == bool(mem[_13178])
                                                    if arg4 < _12682:
                                                        revert with 0, 17
                                                    if arg4 - _12682 < _12682 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12682 - (_12682 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12682 - (_12682 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13370 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13370] == bool(mem[_13370])
                                                    emit 0xfedb587d: address(arg2), _12682, tokenAddress, arg3
                                            else:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 224] = tokenAddress
                                                mem[(6 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(6 * ceil32(return_data.size)) + 292] = 64
                                                mem[(6 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (6 * ceil32(return_data.size)) + 356
                                                while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.mem[mem[64] len 4] with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4406 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _4470 = mem[_4406]
                                                require mem[_4406] <= test266151307()
                                                require _4406 + mem[_4406] + 31 < _4406 + return_data.size
                                                _4546 = mem[_4406 + mem[_4406]]
                                                if mem[_4406 + mem[_4406]] > test266151307():
                                                    revert with 0, 65
                                                if _4406 + ceil32(return_data.size) + ceil32(32 * mem[_4406 + mem[_4406]]) + 1 > test266151307() or ceil32(32 * mem[_4406 + mem[_4406]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _4406 + ceil32(return_data.size) + ceil32(32 * mem[_4406 + mem[_4406]]) + 1
                                                mem[_4406 + ceil32(return_data.size)] = _4546
                                                require return_data.size >= _4470 + (32 * _4546) + 32
                                                mem[_4406 + ceil32(return_data.size) + 32 len 32 * _4546] = mem[_4406 + _4470 + 32 len 32 * _4546]
                                                if 0 >= _4546:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[_4406 + ceil32(return_data.size) + 32] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[_4406 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[_4406 + ceil32(return_data.size) + 32]) + (sub_fd53fce0 * mem[_4406 + ceil32(return_data.size) + 32]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7978 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7978] == mem[_7978 + 12 len 20]
                                                if address(arg2) == mem[_7978 + 12 len 20]:
                                                    _8091 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if 0 >= mem[_8091]:
                                                        revert with 0, 50
                                                    mem[_8091 + 32] = address(arg2)
                                                    if 1 >= mem[_8091]:
                                                        revert with 0, 50
                                                    mem[_8091 + 64] = tokenAddress
                                                    mem[_8091 + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8091 + 100] = arg3
                                                    mem[_8091 + 132] = arg4
                                                    mem[_8091 + 164] = 160
                                                    mem[_8091 + 260] = mem[_8091]
                                                    idx = 0
                                                    s = _8091 + 32
                                                    t = _8091 + 292
                                                    while idx < mem[_8091]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8091 + 196] = address(arg1)
                                                    mem[_8091 + 228] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8091 + (32 * mem[_8091]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10953 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11057 = mem[_10953]
                                                    require mem[_10953] <= test266151307()
                                                    require _10953 + mem[_10953] + 31 < _10953 + return_data.size
                                                    _11161 = mem[_10953 + mem[_10953]]
                                                    if mem[_10953 + mem[_10953]] > test266151307():
                                                        revert with 0, 65
                                                    if _10953 + ceil32(return_data.size) + ceil32(32 * mem[_10953 + mem[_10953]]) + 1 > test266151307() or ceil32(32 * mem[_10953 + mem[_10953]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10953 + ceil32(return_data.size) + ceil32(32 * mem[_10953 + mem[_10953]]) + 1
                                                    mem[_10953 + ceil32(return_data.size)] = _11161
                                                    require return_data.size >= _11057 + (32 * _11161) + 32
                                                    mem[_10953 + ceil32(return_data.size) + 32 len 32 * _11161] = mem[_10953 + _11057 + 32 len 32 * _11161]
                                                    if 0 >= _11161:
                                                        revert with 0, 50
                                                    _12681 = mem[_10953 + ceil32(return_data.size) + 32]
                                                    if mem[_10953 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10953 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12681 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12681 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13177 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13177] == bool(mem[_13177])
                                                    if arg4 < _12681:
                                                        revert with 0, 17
                                                    if arg4 - _12681 < _12681 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12681 - (_12681 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12681 - (_12681 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13369 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13369] == bool(mem[_13369])
                                                    emit 0xfedb587d: address(arg2), _12681, tokenAddress, arg3
                                                else:
                                                    _8088 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8088]:
                                                        revert with 0, 50
                                                    mem[_8088 + 64] = ext_call.return_data[12 len 20]
                                                    if 0 >= mem[_8088]:
                                                        revert with 0, 50
                                                    mem[_8088 + 32] = address(arg2)
                                                    if 2 >= mem[_8088]:
                                                        revert with 0, 50
                                                    mem[_8088 + 96] = tokenAddress
                                                    mem[_8088 + ceil32(return_data.size) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                    mem[_8088 + ceil32(return_data.size) + 132] = arg3
                                                    mem[_8088 + ceil32(return_data.size) + 164] = arg4
                                                    mem[_8088 + ceil32(return_data.size) + 196] = 160
                                                    mem[_8088 + ceil32(return_data.size) + 292] = mem[_8088]
                                                    idx = 0
                                                    s = _8088 + 32
                                                    t = _8088 + ceil32(return_data.size) + 324
                                                    while idx < mem[_8088]:
                                                        mem[t] = mem[s + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_8088 + ceil32(return_data.size) + 228] = address(arg1)
                                                    mem[_8088 + ceil32(return_data.size) + 260] = arg5
                                                    require ext_code.size(stor101)
                                                    call stor101.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _8088 + ceil32(return_data.size) + (32 * mem[_8088]) + -mem[64] + 320]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _10952 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _11056 = mem[_10952]
                                                    require mem[_10952] <= test266151307()
                                                    require _10952 + mem[_10952] + 31 < _10952 + return_data.size
                                                    _11160 = mem[_10952 + mem[_10952]]
                                                    if mem[_10952 + mem[_10952]] > test266151307():
                                                        revert with 0, 65
                                                    if _10952 + ceil32(return_data.size) + ceil32(32 * mem[_10952 + mem[_10952]]) + 1 > test266151307() or ceil32(32 * mem[_10952 + mem[_10952]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _10952 + ceil32(return_data.size) + ceil32(32 * mem[_10952 + mem[_10952]]) + 1
                                                    mem[_10952 + ceil32(return_data.size)] = _11160
                                                    require return_data.size >= _11056 + (32 * _11160) + 32
                                                    mem[_10952 + ceil32(return_data.size) + 32 len 32 * _11160] = mem[_10952 + _11056 + 32 len 32 * _11160]
                                                    if 0 >= _11160:
                                                        revert with 0, 50
                                                    _12680 = mem[_10952 + ceil32(return_data.size) + 32]
                                                    if mem[_10952 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10952 + ceil32(return_data.size) + 32]:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = sub_11eb47dcAddress
                                                    mem[mem[64] + 36] = _12680 * sub_fd53fce0 / 100 * 10^6
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args sub_11eb47dcAddress, _12680 * sub_fd53fce0 / 100 * 10^6
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13176 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13176] == bool(mem[_13176])
                                                    if arg4 < _12680:
                                                        revert with 0, 17
                                                    if arg4 - _12680 < _12680 * sub_fd53fce0 / 100 * 10^6:
                                                        revert with 0, 17
                                                    mem[mem[64] + 4] = address(arg1)
                                                    mem[mem[64] + 36] = arg4 - _12680 - (_12680 * sub_fd53fce0 / 100 * 10^6)
                                                    require ext_code.size(address(arg2))
                                                    call address(arg2).transfer(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(arg1), arg4 - _12680 - (_12680 * sub_fd53fce0 / 100 * 10^6)
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _13368 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_13368] == bool(mem[_13368])
                                                    emit 0xfedb587d: address(arg2), _12680, tokenAddress, arg3
                                else:
                                    require unknown_0x80be66cf(?????) == uint32(call.func_hash) >> 224
                                    require not msg.value
                                    require calldata.size - 4 >= 160
                                    require arg1 == address(arg1)
                                    require arg2 == address(arg2)
                                    if msg.sender == tokenAddress:
                                        mem[132] = this.address
                                        mem[164] = routerAddress
                                        require ext_code.size(stor105)
                                        staticcall stor105.allowance(address arg1, address arg2) with:
                                                gas gas_remaining wei
                                               args address(this.address), routerAddress
                                        mem[128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] >= arg4:
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 2
                                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                                                mem[(2 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(2 * ceil32(return_data.size)) + 260] = 64
                                                mem[(2 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (2 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (4 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4473 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                                _4549 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4473 + (32 * _4549) + 32
                                                mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4549] = mem[(2 * ceil32(return_data.size)) + _4473 + 256 len 32 * _4549]
                                                if 0 >= _4549:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7981 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7981] == mem[_7981 + 12 len 20]
                                                if address(arg2) == mem[_7981 + 12 len 20]:
                                                    _8103 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8103]:
                                                        revert with 0, 50
                                                    mem[_8103 + 32] = tokenAddress
                                                    if 1 >= mem[_8103]:
                                                        revert with 0, 50
                                                    mem[_8103 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8103 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8103 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8103 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8103 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8103 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8103 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8103 + ceil32(return_data.size) + 260] = mem[_8103]
                                                        idx = 0
                                                        s = _8103 + 32
                                                        t = _8103 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8103]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8103 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8103 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8103 + ceil32(return_data.size) + 260 len (32 * mem[_8103]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8103 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8103 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11066 = mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8103 + ceil32(return_data.size) + return_data.size + 96
                                                        _11170 = mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8103 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8103 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8103 + (2 * ceil32(return_data.size)) + 96] = mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        require return_data.size >= _11066 + (32 * _11170) + 32
                                                        mem[_8103 + (2 * ceil32(return_data.size)) + 128 len 32 * _11170] = mem[_8103 + ceil32(return_data.size) + _11066 + 128 len 32 * _11170]
                                                        if 0 >= _11170:
                                                            revert with 0, 50
                                                        _12818 = mem[_8103 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8103 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8103 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12818 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12818 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13186 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13186] == bool(mem[_13186])
                                                        if arg4 < _12818:
                                                            revert with 0, 17
                                                        if arg4 - _12818 < _12818 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12818 - (_12818 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12818 - (_12818 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13378 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13378] == bool(mem[_13378])
                                                        emit 0xfedb587d: tokenAddress, _12818, address(arg2), arg3
                                                    else:
                                                        mem[_8103 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8103 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8103 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8103 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8103 + ceil32(return_data.size) + 260] = mem[_8103]
                                                        idx = 0
                                                        s = _8103 + 32
                                                        t = _8103 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8103]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8103 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8103 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8103 + ceil32(return_data.size) + 260 len (32 * mem[_8103]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8103 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8103 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11067 = mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8103 + ceil32(return_data.size) + return_data.size + 96
                                                        _11171 = mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8103 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8103 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8103 + (2 * ceil32(return_data.size)) + 96] = mem[_8103 + ceil32(return_data.size) + mem[_8103 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        require return_data.size >= _11067 + (32 * _11171) + 32
                                                        mem[_8103 + (2 * ceil32(return_data.size)) + 128 len 32 * _11171] = mem[_8103 + ceil32(return_data.size) + _11067 + 128 len 32 * _11171]
                                                        if 0 >= _11171:
                                                            revert with 0, 50
                                                        _12819 = mem[_8103 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8103 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8103 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12819 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12819 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13187 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13187] == bool(mem[_13187])
                                                        if arg4 < _12819:
                                                            revert with 0, 17
                                                        if arg4 - _12819 < _12819 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12819 - (_12819 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12819 - (_12819 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13379 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13379] == bool(mem[_13379])
                                                        emit 0xfedb587d: tokenAddress, _12819, address(arg2), arg3
                                                else:
                                                    _8100 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8100]:
                                                        revert with 0, 50
                                                    mem[_8100 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8100]:
                                                        revert with 0, 50
                                                    mem[_8100 + 32] = tokenAddress
                                                    if 2 >= mem[_8100]:
                                                        revert with 0, 50
                                                    mem[_8100 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8100 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8100 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 292] = mem[_8100]
                                                        idx = 0
                                                        s = _8100 + 32
                                                        t = _8100 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8100]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8100 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8100]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8100 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11064 = mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8100 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11168 = mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8100 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8100 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8100 + (4 * ceil32(return_data.size)) + 128] = mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        require return_data.size >= _11064 + (32 * _11168) + 32
                                                        mem[_8100 + (4 * ceil32(return_data.size)) + 160 len 32 * _11168] = mem[_8100 + (2 * ceil32(return_data.size)) + _11064 + 160 len 32 * _11168]
                                                        if 0 >= _11168:
                                                            revert with 0, 50
                                                        _12816 = mem[_8100 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8100 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8100 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12816 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12816 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13184 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13184] == bool(mem[_13184])
                                                        if arg4 < _12816:
                                                            revert with 0, 17
                                                        if arg4 - _12816 < _12816 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12816 - (_12816 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12816 - (_12816 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13376 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13376] == bool(mem[_13376])
                                                        emit 0xfedb587d: tokenAddress, _12816, address(arg2), arg3
                                                    else:
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 292] = mem[_8100]
                                                        idx = 0
                                                        s = _8100 + 32
                                                        t = _8100 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8100]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8100 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8100]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8100 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8100 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11065 = mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8100 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11169 = mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8100 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8100 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8100 + (4 * ceil32(return_data.size)) + 128] = mem[_8100 + (2 * ceil32(return_data.size)) + mem[_8100 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        require return_data.size >= _11065 + (32 * _11169) + 32
                                                        mem[_8100 + (4 * ceil32(return_data.size)) + 160 len 32 * _11169] = mem[_8100 + (2 * ceil32(return_data.size)) + _11065 + 160 len 32 * _11169]
                                                        if 0 >= _11169:
                                                            revert with 0, 50
                                                        _12817 = mem[_8100 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8100 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8100 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12817 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12817 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13185 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13185] == bool(mem[_13185])
                                                        if arg4 < _12817:
                                                            revert with 0, 17
                                                        if arg4 - _12817 < _12817 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12817 - (_12817 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12817 - (_12817 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13377 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13377] == bool(mem[_13377])
                                                        emit 0xfedb587d: tokenAddress, _12817, address(arg2), arg3
                                            else:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(2 * ceil32(return_data.size)) + 224] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 292] = 64
                                                mem[(4 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 356
                                                while idx < 3:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                _4472 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                                _4548 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                                mem[(6 * ceil32(return_data.size)) + 256] = _4548
                                                require return_data.size >= _4472 + (32 * _4548) + 32
                                                mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4548] = mem[(4 * ceil32(return_data.size)) + _4472 + 288 len 32 * _4548]
                                                if 0 >= _4548:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 288] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 288]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 288]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7980 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7980] == mem[_7980 + 12 len 20]
                                                if address(arg2) == mem[_7980 + 12 len 20]:
                                                    _8099 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8099]:
                                                        revert with 0, 50
                                                    mem[_8099 + 32] = tokenAddress
                                                    if 1 >= mem[_8099]:
                                                        revert with 0, 50
                                                    mem[_8099 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8099 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8099 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8099 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8099 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8099 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8099 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8099 + ceil32(return_data.size) + 260] = mem[_8099]
                                                        idx = 0
                                                        s = _8099 + 32
                                                        t = _8099 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8099]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8099 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8099 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8099 + ceil32(return_data.size) + 260 len (32 * mem[_8099]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8099 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8099 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11062 = mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8099 + ceil32(return_data.size) + return_data.size + 96
                                                        _11166 = mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8099 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8099 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8099 + (2 * ceil32(return_data.size)) + 96] = _11166
                                                        require return_data.size >= _11062 + (32 * _11166) + 32
                                                        mem[_8099 + (2 * ceil32(return_data.size)) + 128 len 32 * _11166] = mem[_8099 + ceil32(return_data.size) + _11062 + 128 len 32 * _11166]
                                                        if 0 >= _11166:
                                                            revert with 0, 50
                                                        _12814 = mem[_8099 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8099 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8099 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12814 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12814 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13182 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13182] == bool(mem[_13182])
                                                        if arg4 < _12814:
                                                            revert with 0, 17
                                                        if arg4 - _12814 < _12814 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12814 - (_12814 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12814 - (_12814 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13374 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13374] == bool(mem[_13374])
                                                        emit 0xfedb587d: tokenAddress, _12814, address(arg2), arg3
                                                    else:
                                                        mem[_8099 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8099 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8099 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8099 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8099 + ceil32(return_data.size) + 260] = mem[_8099]
                                                        idx = 0
                                                        s = _8099 + 32
                                                        t = _8099 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8099]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8099 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8099 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8099 + ceil32(return_data.size) + 260 len (32 * mem[_8099]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8099 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8099 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11063 = mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8099 + ceil32(return_data.size) + return_data.size + 96
                                                        _11167 = mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8099 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8099 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8099 + ceil32(return_data.size) + mem[_8099 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8099 + (2 * ceil32(return_data.size)) + 96] = _11167
                                                        require return_data.size >= _11063 + (32 * _11167) + 32
                                                        mem[_8099 + (2 * ceil32(return_data.size)) + 128 len 32 * _11167] = mem[_8099 + ceil32(return_data.size) + _11063 + 128 len 32 * _11167]
                                                        if 0 >= _11167:
                                                            revert with 0, 50
                                                        _12815 = mem[_8099 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8099 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8099 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12815 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12815 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13183 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13183] == bool(mem[_13183])
                                                        if arg4 < _12815:
                                                            revert with 0, 17
                                                        if arg4 - _12815 < _12815 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12815 - (_12815 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12815 - (_12815 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13375 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13375] == bool(mem[_13375])
                                                        emit 0xfedb587d: tokenAddress, _12815, address(arg2), arg3
                                                else:
                                                    _8096 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8096]:
                                                        revert with 0, 50
                                                    mem[_8096 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8096]:
                                                        revert with 0, 50
                                                    mem[_8096 + 32] = tokenAddress
                                                    if 2 >= mem[_8096]:
                                                        revert with 0, 50
                                                    mem[_8096 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8096 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8096 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 292] = mem[_8096]
                                                        idx = 0
                                                        s = _8096 + 32
                                                        t = _8096 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8096]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8096 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8096]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8096 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11060 = mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8096 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11164 = mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8096 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8096 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8096 + (4 * ceil32(return_data.size)) + 128] = mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        require return_data.size >= _11060 + (32 * _11164) + 32
                                                        mem[_8096 + (4 * ceil32(return_data.size)) + 160 len 32 * _11164] = mem[_8096 + (2 * ceil32(return_data.size)) + _11060 + 160 len 32 * _11164]
                                                        if 0 >= _11164:
                                                            revert with 0, 50
                                                        _12812 = mem[_8096 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8096 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8096 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12812 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12812 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13180 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13180] == bool(mem[_13180])
                                                        if arg4 < _12812:
                                                            revert with 0, 17
                                                        if arg4 - _12812 < _12812 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12812 - (_12812 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12812 - (_12812 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13372 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13372] == bool(mem[_13372])
                                                        emit 0xfedb587d: tokenAddress, _12812, address(arg2), arg3
                                                    else:
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 292] = mem[_8096]
                                                        idx = 0
                                                        s = _8096 + 32
                                                        t = _8096 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8096]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8096 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8096]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8096 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8096 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11061 = mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8096 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11165 = mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8096 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8096 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8096 + (4 * ceil32(return_data.size)) + 128] = mem[_8096 + (2 * ceil32(return_data.size)) + mem[_8096 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        require return_data.size >= _11061 + (32 * _11165) + 32
                                                        mem[_8096 + (4 * ceil32(return_data.size)) + 160 len 32 * _11165] = mem[_8096 + (2 * ceil32(return_data.size)) + _11061 + 160 len 32 * _11165]
                                                        if 0 >= _11165:
                                                            revert with 0, 50
                                                        _12813 = mem[_8096 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8096 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8096 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12813 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12813 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13181 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13181] == bool(mem[_13181])
                                                        if arg4 < _12813:
                                                            revert with 0, 17
                                                        if arg4 - _12813 < _12813 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12813 - (_12813 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12813 - (_12813 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13373 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13373] == bool(mem[_13373])
                                                        emit 0xfedb587d: tokenAddress, _12813, address(arg2), arg3
                                        else:
                                            mem[ceil32(return_data.size) + 132] = routerAddress
                                            mem[ceil32(return_data.size) + 164] = arg4
                                            require ext_code.size(stor105)
                                            call stor105.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, arg4
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 2
                                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 260] = 64
                                                mem[(4 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4475 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                                _4551 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4475 + (32 * _4551) + 32
                                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4551] = mem[(4 * ceil32(return_data.size)) + _4475 + 256 len 32 * _4551]
                                                if 0 >= _4551:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7983 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7983] == mem[_7983 + 12 len 20]
                                                if address(arg2) == mem[_7983 + 12 len 20]:
                                                    _8111 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8111]:
                                                        revert with 0, 50
                                                    mem[_8111 + 32] = tokenAddress
                                                    if 1 >= mem[_8111]:
                                                        revert with 0, 50
                                                    mem[_8111 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8111 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8111 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8111 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8111 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8111 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8111 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8111 + ceil32(return_data.size) + 260] = mem[_8111]
                                                        idx = 0
                                                        s = _8111 + 32
                                                        t = _8111 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8111]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8111 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8111 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8111 + ceil32(return_data.size) + (32 * mem[_8111]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10970 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11074 = mem[_10970]
                                                        require mem[_10970] <= test266151307()
                                                        require _10970 + mem[_10970] + 31 < _10970 + return_data.size
                                                        _11178 = mem[_10970 + mem[_10970]]
                                                        if mem[_10970 + mem[_10970]] > test266151307():
                                                            revert with 0, 65
                                                        if _10970 + ceil32(return_data.size) + ceil32(32 * mem[_10970 + mem[_10970]]) + 1 > test266151307() or ceil32(32 * mem[_10970 + mem[_10970]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10970 + ceil32(return_data.size) + ceil32(32 * mem[_10970 + mem[_10970]]) + 1
                                                        mem[_10970 + ceil32(return_data.size)] = _11178
                                                        require return_data.size >= _11074 + (32 * _11178) + 32
                                                        mem[_10970 + ceil32(return_data.size) + 32 len 32 * _11178] = mem[_10970 + _11074 + 32 len 32 * _11178]
                                                        if 0 >= _11178:
                                                            revert with 0, 50
                                                        _12826 = mem[_10970 + ceil32(return_data.size) + 32]
                                                        if mem[_10970 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10970 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12826 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12826 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13194 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13194] == bool(mem[_13194])
                                                        if arg4 < _12826:
                                                            revert with 0, 17
                                                        if arg4 - _12826 < _12826 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12826 - (_12826 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12826 - (_12826 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13386 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13386] == bool(mem[_13386])
                                                        emit 0xfedb587d: tokenAddress, _12826, address(arg2), arg3
                                                    else:
                                                        mem[_8111 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8111 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8111 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8111 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8111 + ceil32(return_data.size) + 260] = mem[_8111]
                                                        idx = 0
                                                        s = _8111 + 32
                                                        t = _8111 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8111]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8111 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8111 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8111 + ceil32(return_data.size) + (32 * mem[_8111]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10971 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11075 = mem[_10971]
                                                        require mem[_10971] <= test266151307()
                                                        require _10971 + mem[_10971] + 31 < _10971 + return_data.size
                                                        _11179 = mem[_10971 + mem[_10971]]
                                                        if mem[_10971 + mem[_10971]] > test266151307():
                                                            revert with 0, 65
                                                        if _10971 + ceil32(return_data.size) + ceil32(32 * mem[_10971 + mem[_10971]]) + 1 > test266151307() or ceil32(32 * mem[_10971 + mem[_10971]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10971 + ceil32(return_data.size) + ceil32(32 * mem[_10971 + mem[_10971]]) + 1
                                                        mem[_10971 + ceil32(return_data.size)] = _11179
                                                        require return_data.size >= _11075 + (32 * _11179) + 32
                                                        mem[_10971 + ceil32(return_data.size) + 32 len 32 * _11179] = mem[_10971 + _11075 + 32 len 32 * _11179]
                                                        if 0 >= _11179:
                                                            revert with 0, 50
                                                        _12827 = mem[_10971 + ceil32(return_data.size) + 32]
                                                        if mem[_10971 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10971 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12827 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12827 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13195 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13195] == bool(mem[_13195])
                                                        if arg4 < _12827:
                                                            revert with 0, 17
                                                        if arg4 - _12827 < _12827 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12827 - (_12827 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12827 - (_12827 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13387 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13387] == bool(mem[_13387])
                                                        emit 0xfedb587d: tokenAddress, _12827, address(arg2), arg3
                                                else:
                                                    _8108 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8108]:
                                                        revert with 0, 50
                                                    mem[_8108 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8108]:
                                                        revert with 0, 50
                                                    mem[_8108 + 32] = tokenAddress
                                                    if 2 >= mem[_8108]:
                                                        revert with 0, 50
                                                    mem[_8108 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8108 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8108 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 292] = mem[_8108]
                                                        idx = 0
                                                        s = _8108 + 32
                                                        t = _8108 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8108]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8108 + (2 * ceil32(return_data.size)) + (32 * mem[_8108]) + -mem[64] + 320]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10968 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11072 = mem[_10968]
                                                        require mem[_10968] <= test266151307()
                                                        require _10968 + mem[_10968] + 31 < _10968 + return_data.size
                                                        _11176 = mem[_10968 + mem[_10968]]
                                                        if mem[_10968 + mem[_10968]] > test266151307():
                                                            revert with 0, 65
                                                        if _10968 + ceil32(return_data.size) + ceil32(32 * mem[_10968 + mem[_10968]]) + 1 > test266151307() or ceil32(32 * mem[_10968 + mem[_10968]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10968 + ceil32(return_data.size) + ceil32(32 * mem[_10968 + mem[_10968]]) + 1
                                                        mem[_10968 + ceil32(return_data.size)] = _11176
                                                        require return_data.size >= _11072 + (32 * _11176) + 32
                                                        mem[_10968 + ceil32(return_data.size) + 32 len 32 * _11176] = mem[_10968 + _11072 + 32 len 32 * _11176]
                                                        if 0 >= _11176:
                                                            revert with 0, 50
                                                        _12824 = mem[_10968 + ceil32(return_data.size) + 32]
                                                        if mem[_10968 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10968 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12824 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12824 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13192 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13192] == bool(mem[_13192])
                                                        if arg4 < _12824:
                                                            revert with 0, 17
                                                        if arg4 - _12824 < _12824 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12824 - (_12824 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12824 - (_12824 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13384 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13384] == bool(mem[_13384])
                                                        emit 0xfedb587d: tokenAddress, _12824, address(arg2), arg3
                                                    else:
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 292] = mem[_8108]
                                                        idx = 0
                                                        s = _8108 + 32
                                                        t = _8108 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8108]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8108 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8108 + (2 * ceil32(return_data.size)) + (32 * mem[_8108]) + -mem[64] + 320]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10969 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11073 = mem[_10969]
                                                        require mem[_10969] <= test266151307()
                                                        require _10969 + mem[_10969] + 31 < _10969 + return_data.size
                                                        _11177 = mem[_10969 + mem[_10969]]
                                                        if mem[_10969 + mem[_10969]] > test266151307():
                                                            revert with 0, 65
                                                        if _10969 + ceil32(return_data.size) + ceil32(32 * mem[_10969 + mem[_10969]]) + 1 > test266151307() or ceil32(32 * mem[_10969 + mem[_10969]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10969 + ceil32(return_data.size) + ceil32(32 * mem[_10969 + mem[_10969]]) + 1
                                                        mem[_10969 + ceil32(return_data.size)] = _11177
                                                        require return_data.size >= _11073 + (32 * _11177) + 32
                                                        mem[_10969 + ceil32(return_data.size) + 32 len 32 * _11177] = mem[_10969 + _11073 + 32 len 32 * _11177]
                                                        if 0 >= _11177:
                                                            revert with 0, 50
                                                        _12825 = mem[_10969 + ceil32(return_data.size) + 32]
                                                        if mem[_10969 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10969 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12825 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12825 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13193 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13193] == bool(mem[_13193])
                                                        if arg4 < _12825:
                                                            revert with 0, 17
                                                        if arg4 - _12825 < _12825 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12825 - (_12825 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12825 - (_12825 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13385 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13385] == bool(mem[_13385])
                                                        emit 0xfedb587d: tokenAddress, _12825, address(arg2), arg3
                                            else:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 224] = address(arg2)
                                                mem[(6 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(6 * ceil32(return_data.size)) + 292] = 64
                                                mem[(6 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (6 * ceil32(return_data.size)) + 356
                                                while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.mem[mem[64] len 4] with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4410 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _4474 = mem[_4410]
                                                require mem[_4410] <= test266151307()
                                                require _4410 + mem[_4410] + 31 < _4410 + return_data.size
                                                _4550 = mem[_4410 + mem[_4410]]
                                                if mem[_4410 + mem[_4410]] > test266151307():
                                                    revert with 0, 65
                                                if _4410 + ceil32(return_data.size) + ceil32(32 * mem[_4410 + mem[_4410]]) + 1 > test266151307() or ceil32(32 * mem[_4410 + mem[_4410]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _4410 + ceil32(return_data.size) + ceil32(32 * mem[_4410 + mem[_4410]]) + 1
                                                mem[_4410 + ceil32(return_data.size)] = _4550
                                                require return_data.size >= _4474 + (32 * _4550) + 32
                                                mem[_4410 + ceil32(return_data.size) + 32 len 32 * _4550] = mem[_4410 + _4474 + 32 len 32 * _4550]
                                                if 0 >= _4550:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[_4410 + ceil32(return_data.size) + 32] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[_4410 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[_4410 + ceil32(return_data.size) + 32]) + (sub_fd53fce0 * mem[_4410 + ceil32(return_data.size) + 32]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7982 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7982] == mem[_7982 + 12 len 20]
                                                if address(arg2) == mem[_7982 + 12 len 20]:
                                                    _8107 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8107]:
                                                        revert with 0, 50
                                                    mem[_8107 + 32] = tokenAddress
                                                    if 1 >= mem[_8107]:
                                                        revert with 0, 50
                                                    mem[_8107 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8107 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8107 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8107 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8107 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8107 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8107 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8107 + ceil32(return_data.size) + 260] = mem[_8107]
                                                        idx = 0
                                                        s = _8107 + 32
                                                        t = _8107 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8107]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8107 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8107 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8107 + ceil32(return_data.size) + (32 * mem[_8107]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10966 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11070 = mem[_10966]
                                                        require mem[_10966] <= test266151307()
                                                        require _10966 + mem[_10966] + 31 < _10966 + return_data.size
                                                        _11174 = mem[_10966 + mem[_10966]]
                                                        if mem[_10966 + mem[_10966]] > test266151307():
                                                            revert with 0, 65
                                                        if _10966 + ceil32(return_data.size) + ceil32(32 * mem[_10966 + mem[_10966]]) + 1 > test266151307() or ceil32(32 * mem[_10966 + mem[_10966]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10966 + ceil32(return_data.size) + ceil32(32 * mem[_10966 + mem[_10966]]) + 1
                                                        mem[_10966 + ceil32(return_data.size)] = _11174
                                                        require return_data.size >= _11070 + (32 * _11174) + 32
                                                        mem[_10966 + ceil32(return_data.size) + 32 len 32 * _11174] = mem[_10966 + _11070 + 32 len 32 * _11174]
                                                        if 0 >= _11174:
                                                            revert with 0, 50
                                                        _12822 = mem[_10966 + ceil32(return_data.size) + 32]
                                                        if mem[_10966 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10966 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12822 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12822 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13190 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13190] == bool(mem[_13190])
                                                        if arg4 < _12822:
                                                            revert with 0, 17
                                                        if arg4 - _12822 < _12822 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12822 - (_12822 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12822 - (_12822 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13382 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13382] == bool(mem[_13382])
                                                        emit 0xfedb587d: tokenAddress, _12822, address(arg2), arg3
                                                    else:
                                                        mem[_8107 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8107 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8107 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8107 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8107 + ceil32(return_data.size) + 260] = mem[_8107]
                                                        idx = 0
                                                        s = _8107 + 32
                                                        t = _8107 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8107]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8107 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8107 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8107 + ceil32(return_data.size) + (32 * mem[_8107]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10967 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11071 = mem[_10967]
                                                        require mem[_10967] <= test266151307()
                                                        require _10967 + mem[_10967] + 31 < _10967 + return_data.size
                                                        _11175 = mem[_10967 + mem[_10967]]
                                                        if mem[_10967 + mem[_10967]] > test266151307():
                                                            revert with 0, 65
                                                        if _10967 + ceil32(return_data.size) + ceil32(32 * mem[_10967 + mem[_10967]]) + 1 > test266151307() or ceil32(32 * mem[_10967 + mem[_10967]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10967 + ceil32(return_data.size) + ceil32(32 * mem[_10967 + mem[_10967]]) + 1
                                                        mem[_10967 + ceil32(return_data.size)] = _11175
                                                        require return_data.size >= _11071 + (32 * _11175) + 32
                                                        mem[_10967 + ceil32(return_data.size) + 32 len 32 * _11175] = mem[_10967 + _11071 + 32 len 32 * _11175]
                                                        if 0 >= _11175:
                                                            revert with 0, 50
                                                        _12823 = mem[_10967 + ceil32(return_data.size) + 32]
                                                        if mem[_10967 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10967 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12823 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12823 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13191 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13191] == bool(mem[_13191])
                                                        if arg4 < _12823:
                                                            revert with 0, 17
                                                        if arg4 - _12823 < _12823 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12823 - (_12823 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12823 - (_12823 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13383 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13383] == bool(mem[_13383])
                                                        emit 0xfedb587d: tokenAddress, _12823, address(arg2), arg3
                                                else:
                                                    _8104 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8104]:
                                                        revert with 0, 50
                                                    mem[_8104 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8104]:
                                                        revert with 0, 50
                                                    mem[_8104 + 32] = tokenAddress
                                                    if 2 >= mem[_8104]:
                                                        revert with 0, 50
                                                    mem[_8104 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8104 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8104 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 292] = mem[_8104]
                                                        idx = 0
                                                        s = _8104 + 32
                                                        t = _8104 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8104]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8104 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8104]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8104 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11068 = mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8104 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11172 = mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8104 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8104 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8104 + (4 * ceil32(return_data.size)) + 128] = _11172
                                                        require return_data.size >= _11068 + (32 * _11172) + 32
                                                        mem[_8104 + (4 * ceil32(return_data.size)) + 160 len 32 * _11172] = mem[_8104 + (2 * ceil32(return_data.size)) + _11068 + 160 len 32 * _11172]
                                                        if 0 >= _11172:
                                                            revert with 0, 50
                                                        _12820 = mem[_8104 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8104 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8104 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12820 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12820 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13188 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13188] == bool(mem[_13188])
                                                        if arg4 < _12820:
                                                            revert with 0, 17
                                                        if arg4 - _12820 < _12820 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12820 - (_12820 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12820 - (_12820 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13380 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13380] == bool(mem[_13380])
                                                        emit 0xfedb587d: tokenAddress, _12820, address(arg2), arg3
                                                    else:
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 292] = mem[_8104]
                                                        idx = 0
                                                        s = _8104 + 32
                                                        t = _8104 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8104]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8104 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8104]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8104 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8104 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11069 = mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8104 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11173 = mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8104 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8104 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8104 + (2 * ceil32(return_data.size)) + mem[_8104 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8104 + (4 * ceil32(return_data.size)) + 128] = _11173
                                                        require return_data.size >= _11069 + (32 * _11173) + 32
                                                        mem[_8104 + (4 * ceil32(return_data.size)) + 160 len 32 * _11173] = mem[_8104 + (2 * ceil32(return_data.size)) + _11069 + 160 len 32 * _11173]
                                                        if 0 >= _11173:
                                                            revert with 0, 50
                                                        _12821 = mem[_8104 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8104 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8104 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12821 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12821 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13189 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13189] == bool(mem[_13189])
                                                        if arg4 < _12821:
                                                            revert with 0, 17
                                                        if arg4 - _12821 < _12821 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12821 - (_12821 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12821 - (_12821 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13381 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13381] == bool(mem[_13381])
                                                        emit 0xfedb587d: tokenAddress, _12821, address(arg2), arg3
                                    else:
                                        if address(sub_0584aecfAddress) != msg.sender:
                                            revert with 0, 'Access Denied!'
                                        mem[132] = this.address
                                        mem[164] = routerAddress
                                        require ext_code.size(stor105)
                                        staticcall stor105.allowance(address arg1, address arg2) with:
                                                gas gas_remaining wei
                                               args address(this.address), routerAddress
                                        mem[128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0] >= arg4:
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 2
                                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(2 * ceil32(return_data.size)) + 192] = address(arg2)
                                                mem[(2 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(2 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(2 * ceil32(return_data.size)) + 260] = 64
                                                mem[(2 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (2 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(2 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (4 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4477 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
                                                _4553 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (4 * ceil32(return_data.size)) + ceil32(32 * mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(4 * ceil32(return_data.size)) + 224] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4477 + (32 * _4553) + 32
                                                mem[(4 * ceil32(return_data.size)) + 256 len 32 * _4553] = mem[(2 * ceil32(return_data.size)) + _4477 + 256 len 32 * _4553]
                                                if 0 >= _4553:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(4 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(4 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(4 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7985 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7985] == mem[_7985 + 12 len 20]
                                                if address(arg2) == mem[_7985 + 12 len 20]:
                                                    _8119 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8119]:
                                                        revert with 0, 50
                                                    mem[_8119 + 32] = tokenAddress
                                                    if 1 >= mem[_8119]:
                                                        revert with 0, 50
                                                    mem[_8119 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8119 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8119 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8119 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8119 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8119 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8119 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8119 + ceil32(return_data.size) + 260] = mem[_8119]
                                                        idx = 0
                                                        s = _8119 + 32
                                                        t = _8119 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8119]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8119 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8119 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8119 + ceil32(return_data.size) + (32 * mem[_8119]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10978 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11082 = mem[_10978]
                                                        require mem[_10978] <= test266151307()
                                                        require _10978 + mem[_10978] + 31 < _10978 + return_data.size
                                                        _11186 = mem[_10978 + mem[_10978]]
                                                        if mem[_10978 + mem[_10978]] > test266151307():
                                                            revert with 0, 65
                                                        if _10978 + ceil32(return_data.size) + ceil32(32 * mem[_10978 + mem[_10978]]) + 1 > test266151307() or ceil32(32 * mem[_10978 + mem[_10978]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10978 + ceil32(return_data.size) + ceil32(32 * mem[_10978 + mem[_10978]]) + 1
                                                        mem[_10978 + ceil32(return_data.size)] = _11186
                                                        require return_data.size >= _11082 + (32 * _11186) + 32
                                                        mem[_10978 + ceil32(return_data.size) + 32 len 32 * _11186] = mem[_10978 + _11082 + 32 len 32 * _11186]
                                                        if 0 >= _11186:
                                                            revert with 0, 50
                                                        _12834 = mem[_10978 + ceil32(return_data.size) + 32]
                                                        if mem[_10978 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10978 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12834 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12834 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13202 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13202] == bool(mem[_13202])
                                                        if arg4 < _12834:
                                                            revert with 0, 17
                                                        if arg4 - _12834 < _12834 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12834 - (_12834 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12834 - (_12834 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13394 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13394] == bool(mem[_13394])
                                                        emit 0xfedb587d: tokenAddress, _12834, address(arg2), arg3
                                                    else:
                                                        mem[_8119 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8119 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8119 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8119 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8119 + ceil32(return_data.size) + 260] = mem[_8119]
                                                        idx = 0
                                                        s = _8119 + 32
                                                        t = _8119 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8119]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8119 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8119 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8119 + ceil32(return_data.size) + (32 * mem[_8119]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10979 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11083 = mem[_10979]
                                                        require mem[_10979] <= test266151307()
                                                        require _10979 + mem[_10979] + 31 < _10979 + return_data.size
                                                        _11187 = mem[_10979 + mem[_10979]]
                                                        if mem[_10979 + mem[_10979]] > test266151307():
                                                            revert with 0, 65
                                                        if _10979 + ceil32(return_data.size) + ceil32(32 * mem[_10979 + mem[_10979]]) + 1 > test266151307() or ceil32(32 * mem[_10979 + mem[_10979]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10979 + ceil32(return_data.size) + ceil32(32 * mem[_10979 + mem[_10979]]) + 1
                                                        mem[_10979 + ceil32(return_data.size)] = _11187
                                                        require return_data.size >= _11083 + (32 * _11187) + 32
                                                        mem[_10979 + ceil32(return_data.size) + 32 len 32 * _11187] = mem[_10979 + _11083 + 32 len 32 * _11187]
                                                        if 0 >= _11187:
                                                            revert with 0, 50
                                                        _12835 = mem[_10979 + ceil32(return_data.size) + 32]
                                                        if mem[_10979 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10979 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12835 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12835 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13203 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13203] == bool(mem[_13203])
                                                        if arg4 < _12835:
                                                            revert with 0, 17
                                                        if arg4 - _12835 < _12835 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12835 - (_12835 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12835 - (_12835 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13395 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13395] == bool(mem[_13395])
                                                        emit 0xfedb587d: tokenAddress, _12835, address(arg2), arg3
                                                else:
                                                    _8116 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8116]:
                                                        revert with 0, 50
                                                    mem[_8116 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8116]:
                                                        revert with 0, 50
                                                    mem[_8116 + 32] = tokenAddress
                                                    if 2 >= mem[_8116]:
                                                        revert with 0, 50
                                                    mem[_8116 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8116 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8116 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 292] = mem[_8116]
                                                        idx = 0
                                                        s = _8116 + 32
                                                        t = _8116 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8116]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8116 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8116]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8116 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11080 = mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8116 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11184 = mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8116 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8116 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8116 + (4 * ceil32(return_data.size)) + 128] = _11184
                                                        require return_data.size >= _11080 + (32 * _11184) + 32
                                                        mem[_8116 + (4 * ceil32(return_data.size)) + 160 len 32 * _11184] = mem[_8116 + (2 * ceil32(return_data.size)) + _11080 + 160 len 32 * _11184]
                                                        if 0 >= _11184:
                                                            revert with 0, 50
                                                        _12832 = mem[_8116 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8116 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8116 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12832 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12832 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13200 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13200] == bool(mem[_13200])
                                                        if arg4 < _12832:
                                                            revert with 0, 17
                                                        if arg4 - _12832 < _12832 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12832 - (_12832 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12832 - (_12832 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13392 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13392] == bool(mem[_13392])
                                                        emit 0xfedb587d: tokenAddress, _12832, address(arg2), arg3
                                                    else:
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 292] = mem[_8116]
                                                        idx = 0
                                                        s = _8116 + 32
                                                        t = _8116 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8116]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8116 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8116]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8116 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8116 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11081 = mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8116 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11185 = mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8116 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8116 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8116 + (2 * ceil32(return_data.size)) + mem[_8116 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8116 + (4 * ceil32(return_data.size)) + 128] = _11185
                                                        require return_data.size >= _11081 + (32 * _11185) + 32
                                                        mem[_8116 + (4 * ceil32(return_data.size)) + 160 len 32 * _11185] = mem[_8116 + (2 * ceil32(return_data.size)) + _11081 + 160 len 32 * _11185]
                                                        if 0 >= _11185:
                                                            revert with 0, 50
                                                        _12833 = mem[_8116 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8116 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8116 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12833 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12833 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13201 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13201] == bool(mem[_13201])
                                                        if arg4 < _12833:
                                                            revert with 0, 17
                                                        if arg4 - _12833 < _12833 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12833 - (_12833 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12833 - (_12833 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13393 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13393] == bool(mem[_13393])
                                                        emit 0xfedb587d: tokenAddress, _12833, address(arg2), arg3
                                            else:
                                                mem[(2 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(2 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(2 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(2 * ceil32(return_data.size)) + 224] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 292] = 64
                                                mem[(4 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (2 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 356
                                                while idx < 3:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 356 len 96])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                _4476 = mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 287 < (4 * ceil32(return_data.size)) + return_data.size + 256
                                                _4552 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg3) >> 32 + 256]) + 257
                                                mem[(6 * ceil32(return_data.size)) + 256] = _4552
                                                require return_data.size >= _4476 + (32 * _4552) + 32
                                                mem[(6 * ceil32(return_data.size)) + 288 len 32 * _4552] = mem[(4 * ceil32(return_data.size)) + _4476 + 288 len 32 * _4552]
                                                if 0 >= _4552:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 288] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 288]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 288]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 288]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7984 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7984] == mem[_7984 + 12 len 20]
                                                if address(arg2) == mem[_7984 + 12 len 20]:
                                                    _8115 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8115]:
                                                        revert with 0, 50
                                                    mem[_8115 + 32] = tokenAddress
                                                    if 1 >= mem[_8115]:
                                                        revert with 0, 50
                                                    mem[_8115 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8115 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8115 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8115 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8115 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8115 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8115 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8115 + ceil32(return_data.size) + 260] = mem[_8115]
                                                        idx = 0
                                                        s = _8115 + 32
                                                        t = _8115 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8115]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8115 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8115 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8115 + ceil32(return_data.size) + (32 * mem[_8115]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10974 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11078 = mem[_10974]
                                                        require mem[_10974] <= test266151307()
                                                        require _10974 + mem[_10974] + 31 < _10974 + return_data.size
                                                        _11182 = mem[_10974 + mem[_10974]]
                                                        if mem[_10974 + mem[_10974]] > test266151307():
                                                            revert with 0, 65
                                                        if _10974 + ceil32(return_data.size) + ceil32(32 * mem[_10974 + mem[_10974]]) + 1 > test266151307() or ceil32(32 * mem[_10974 + mem[_10974]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10974 + ceil32(return_data.size) + ceil32(32 * mem[_10974 + mem[_10974]]) + 1
                                                        mem[_10974 + ceil32(return_data.size)] = _11182
                                                        require return_data.size >= _11078 + (32 * _11182) + 32
                                                        mem[_10974 + ceil32(return_data.size) + 32 len 32 * _11182] = mem[_10974 + _11078 + 32 len 32 * _11182]
                                                        if 0 >= _11182:
                                                            revert with 0, 50
                                                        _12830 = mem[_10974 + ceil32(return_data.size) + 32]
                                                        if mem[_10974 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10974 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12830 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12830 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13198 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13198] == bool(mem[_13198])
                                                        if arg4 < _12830:
                                                            revert with 0, 17
                                                        if arg4 - _12830 < _12830 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12830 - (_12830 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12830 - (_12830 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13390 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13390] == bool(mem[_13390])
                                                        emit 0xfedb587d: tokenAddress, _12830, address(arg2), arg3
                                                    else:
                                                        mem[_8115 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8115 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8115 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8115 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8115 + ceil32(return_data.size) + 260] = mem[_8115]
                                                        idx = 0
                                                        s = _8115 + 32
                                                        t = _8115 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8115]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8115 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8115 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8115 + ceil32(return_data.size) + (32 * mem[_8115]) + -mem[64] + 288]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10975 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11079 = mem[_10975]
                                                        require mem[_10975] <= test266151307()
                                                        require _10975 + mem[_10975] + 31 < _10975 + return_data.size
                                                        _11183 = mem[_10975 + mem[_10975]]
                                                        if mem[_10975 + mem[_10975]] > test266151307():
                                                            revert with 0, 65
                                                        if _10975 + ceil32(return_data.size) + ceil32(32 * mem[_10975 + mem[_10975]]) + 1 > test266151307() or ceil32(32 * mem[_10975 + mem[_10975]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10975 + ceil32(return_data.size) + ceil32(32 * mem[_10975 + mem[_10975]]) + 1
                                                        mem[_10975 + ceil32(return_data.size)] = _11183
                                                        require return_data.size >= _11079 + (32 * _11183) + 32
                                                        mem[_10975 + ceil32(return_data.size) + 32 len 32 * _11183] = mem[_10975 + _11079 + 32 len 32 * _11183]
                                                        if 0 >= _11183:
                                                            revert with 0, 50
                                                        _12831 = mem[_10975 + ceil32(return_data.size) + 32]
                                                        if mem[_10975 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10975 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12831 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12831 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13199 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13199] == bool(mem[_13199])
                                                        if arg4 < _12831:
                                                            revert with 0, 17
                                                        if arg4 - _12831 < _12831 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12831 - (_12831 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12831 - (_12831 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13391 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13391] == bool(mem[_13391])
                                                        emit 0xfedb587d: tokenAddress, _12831, address(arg2), arg3
                                                else:
                                                    _8112 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8112]:
                                                        revert with 0, 50
                                                    mem[_8112 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8112]:
                                                        revert with 0, 50
                                                    mem[_8112 + 32] = tokenAddress
                                                    if 2 >= mem[_8112]:
                                                        revert with 0, 50
                                                    mem[_8112 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8112 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8112 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 292] = mem[_8112]
                                                        idx = 0
                                                        s = _8112 + 32
                                                        t = _8112 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8112]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8112 + (2 * ceil32(return_data.size)) + (32 * mem[_8112]) + -mem[64] + 320]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10972 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11076 = mem[_10972]
                                                        require mem[_10972] <= test266151307()
                                                        require _10972 + mem[_10972] + 31 < _10972 + return_data.size
                                                        _11180 = mem[_10972 + mem[_10972]]
                                                        if mem[_10972 + mem[_10972]] > test266151307():
                                                            revert with 0, 65
                                                        if _10972 + ceil32(return_data.size) + ceil32(32 * mem[_10972 + mem[_10972]]) + 1 > test266151307() or ceil32(32 * mem[_10972 + mem[_10972]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10972 + ceil32(return_data.size) + ceil32(32 * mem[_10972 + mem[_10972]]) + 1
                                                        mem[_10972 + ceil32(return_data.size)] = _11180
                                                        require return_data.size >= _11076 + (32 * _11180) + 32
                                                        mem[_10972 + ceil32(return_data.size) + 32 len 32 * _11180] = mem[_10972 + _11076 + 32 len 32 * _11180]
                                                        if 0 >= _11180:
                                                            revert with 0, 50
                                                        _12828 = mem[_10972 + ceil32(return_data.size) + 32]
                                                        if mem[_10972 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10972 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12828 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12828 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13196 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13196] == bool(mem[_13196])
                                                        if arg4 < _12828:
                                                            revert with 0, 17
                                                        if arg4 - _12828 < _12828 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12828 - (_12828 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12828 - (_12828 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13388 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13388] == bool(mem[_13388])
                                                        emit 0xfedb587d: tokenAddress, _12828, address(arg2), arg3
                                                    else:
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 292] = mem[_8112]
                                                        idx = 0
                                                        s = _8112 + 32
                                                        t = _8112 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8112]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8112 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8112 + (2 * ceil32(return_data.size)) + (32 * mem[_8112]) + -mem[64] + 320]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10973 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11077 = mem[_10973]
                                                        require mem[_10973] <= test266151307()
                                                        require _10973 + mem[_10973] + 31 < _10973 + return_data.size
                                                        _11181 = mem[_10973 + mem[_10973]]
                                                        if mem[_10973 + mem[_10973]] > test266151307():
                                                            revert with 0, 65
                                                        if _10973 + ceil32(return_data.size) + ceil32(32 * mem[_10973 + mem[_10973]]) + 1 > test266151307() or ceil32(32 * mem[_10973 + mem[_10973]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10973 + ceil32(return_data.size) + ceil32(32 * mem[_10973 + mem[_10973]]) + 1
                                                        mem[_10973 + ceil32(return_data.size)] = _11181
                                                        require return_data.size >= _11077 + (32 * _11181) + 32
                                                        mem[_10973 + ceil32(return_data.size) + 32 len 32 * _11181] = mem[_10973 + _11077 + 32 len 32 * _11181]
                                                        if 0 >= _11181:
                                                            revert with 0, 50
                                                        _12829 = mem[_10973 + ceil32(return_data.size) + 32]
                                                        if mem[_10973 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10973 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12829 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12829 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13197 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13197] == bool(mem[_13197])
                                                        if arg4 < _12829:
                                                            revert with 0, 17
                                                        if arg4 - _12829 < _12829 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12829 - (_12829 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12829 - (_12829 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13389 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13389] == bool(mem[_13389])
                                                        emit 0xfedb587d: tokenAddress, _12829, address(arg2), arg3
                                        else:
                                            mem[ceil32(return_data.size) + 132] = routerAddress
                                            mem[ceil32(return_data.size) + 164] = arg4
                                            require ext_code.size(stor105)
                                            call stor105.approve(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args routerAddress, arg4
                                            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            require ext_code.size(stor101)
                                            staticcall stor101.WAVAX() with:
                                                    gas gas_remaining wei
                                            mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if address(arg2) == ext_call.return_data[12 len 20]:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 2
                                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                                mem[(4 * ceil32(return_data.size)) + 224] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(4 * ceil32(return_data.size)) + 228] = arg3
                                                mem[(4 * ceil32(return_data.size)) + 260] = 64
                                                mem[(4 * ceil32(return_data.size)) + 292] = 2
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (4 * ceil32(return_data.size)) + 324
                                                while idx < 2:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.getAmountsIn(uint256 arg1, address[] arg2) with:
                                                        gas gas_remaining wei
                                                       args arg3, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 324 len 64])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                                require return_data.size >= 32
                                                _4479 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32
                                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 255 < (4 * ceil32(return_data.size)) + return_data.size + 224
                                                _4555 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224] > test266151307():
                                                    revert with 0, 65
                                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]) + 225
                                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg3) >> 32 + 224]
                                                require return_data.size >= _4479 + (32 * _4555) + 32
                                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _4555] = mem[(4 * ceil32(return_data.size)) + _4479 + 256 len 32 * _4555]
                                                if 0 >= _4555:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[(6 * ceil32(return_data.size)) + 256] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[(6 * ceil32(return_data.size)) + 256]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[(6 * ceil32(return_data.size)) + 256]) + (sub_fd53fce0 * mem[(6 * ceil32(return_data.size)) + 256]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7987 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7987] == mem[_7987 + 12 len 20]
                                                if address(arg2) == mem[_7987 + 12 len 20]:
                                                    _8127 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8127]:
                                                        revert with 0, 50
                                                    mem[_8127 + 32] = tokenAddress
                                                    if 1 >= mem[_8127]:
                                                        revert with 0, 50
                                                    mem[_8127 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8127 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8127 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8127 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8127 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8127 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8127 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8127 + ceil32(return_data.size) + 260] = mem[_8127]
                                                        idx = 0
                                                        s = _8127 + 32
                                                        t = _8127 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8127]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8127 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8127 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8127 + ceil32(return_data.size) + 260 len (32 * mem[_8127]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8127 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8127 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11090 = mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8127 + ceil32(return_data.size) + return_data.size + 96
                                                        _11194 = mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8127 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8127 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8127 + (2 * ceil32(return_data.size)) + 96] = _11194
                                                        require return_data.size >= _11090 + (32 * _11194) + 32
                                                        mem[_8127 + (2 * ceil32(return_data.size)) + 128 len 32 * _11194] = mem[_8127 + ceil32(return_data.size) + _11090 + 128 len 32 * _11194]
                                                        if 0 >= _11194:
                                                            revert with 0, 50
                                                        _12842 = mem[_8127 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8127 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8127 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12842 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12842 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13210 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13210] == bool(mem[_13210])
                                                        if arg4 < _12842:
                                                            revert with 0, 17
                                                        if arg4 - _12842 < _12842 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12842 - (_12842 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12842 - (_12842 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13402 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13402] == bool(mem[_13402])
                                                        emit 0xfedb587d: tokenAddress, _12842, address(arg2), arg3
                                                    else:
                                                        mem[_8127 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8127 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8127 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8127 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8127 + ceil32(return_data.size) + 260] = mem[_8127]
                                                        idx = 0
                                                        s = _8127 + 32
                                                        t = _8127 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8127]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8127 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8127 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8127 + ceil32(return_data.size) + 260 len (32 * mem[_8127]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8127 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8127 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11091 = mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8127 + ceil32(return_data.size) + return_data.size + 96
                                                        _11195 = mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8127 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8127 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8127 + ceil32(return_data.size) + mem[_8127 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8127 + (2 * ceil32(return_data.size)) + 96] = _11195
                                                        require return_data.size >= _11091 + (32 * _11195) + 32
                                                        mem[_8127 + (2 * ceil32(return_data.size)) + 128 len 32 * _11195] = mem[_8127 + ceil32(return_data.size) + _11091 + 128 len 32 * _11195]
                                                        if 0 >= _11195:
                                                            revert with 0, 50
                                                        _12843 = mem[_8127 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8127 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8127 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12843 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12843 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13211 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13211] == bool(mem[_13211])
                                                        if arg4 < _12843:
                                                            revert with 0, 17
                                                        if arg4 - _12843 < _12843 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12843 - (_12843 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12843 - (_12843 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13403 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13403] == bool(mem[_13403])
                                                        emit 0xfedb587d: tokenAddress, _12843, address(arg2), arg3
                                                else:
                                                    _8124 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8124]:
                                                        revert with 0, 50
                                                    mem[_8124 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8124]:
                                                        revert with 0, 50
                                                    mem[_8124 + 32] = tokenAddress
                                                    if 2 >= mem[_8124]:
                                                        revert with 0, 50
                                                    mem[_8124 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8124 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8124 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 292] = mem[_8124]
                                                        idx = 0
                                                        s = _8124 + 32
                                                        t = _8124 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8124]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8124 + (2 * ceil32(return_data.size)) + (32 * mem[_8124]) + -mem[64] + 320]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10984 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11088 = mem[_10984]
                                                        require mem[_10984] <= test266151307()
                                                        require _10984 + mem[_10984] + 31 < _10984 + return_data.size
                                                        _11192 = mem[_10984 + mem[_10984]]
                                                        if mem[_10984 + mem[_10984]] > test266151307():
                                                            revert with 0, 65
                                                        if _10984 + ceil32(return_data.size) + ceil32(32 * mem[_10984 + mem[_10984]]) + 1 > test266151307() or ceil32(32 * mem[_10984 + mem[_10984]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10984 + ceil32(return_data.size) + ceil32(32 * mem[_10984 + mem[_10984]]) + 1
                                                        mem[_10984 + ceil32(return_data.size)] = _11192
                                                        require return_data.size >= _11088 + (32 * _11192) + 32
                                                        mem[_10984 + ceil32(return_data.size) + 32 len 32 * _11192] = mem[_10984 + _11088 + 32 len 32 * _11192]
                                                        if 0 >= _11192:
                                                            revert with 0, 50
                                                        _12840 = mem[_10984 + ceil32(return_data.size) + 32]
                                                        if mem[_10984 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10984 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12840 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12840 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13208 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13208] == bool(mem[_13208])
                                                        if arg4 < _12840:
                                                            revert with 0, 17
                                                        if arg4 - _12840 < _12840 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12840 - (_12840 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12840 - (_12840 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13400 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13400] == bool(mem[_13400])
                                                        emit 0xfedb587d: tokenAddress, _12840, address(arg2), arg3
                                                    else:
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 292] = mem[_8124]
                                                        idx = 0
                                                        s = _8124 + 32
                                                        t = _8124 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8124]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8124 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.mem[mem[64] len 4] with:
                                                             gas gas_remaining wei
                                                            args mem[mem[64] + 4 len _8124 + (2 * ceil32(return_data.size)) + (32 * mem[_8124]) + -mem[64] + 320]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _10985 = mem[64]
                                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        _11089 = mem[_10985]
                                                        require mem[_10985] <= test266151307()
                                                        require _10985 + mem[_10985] + 31 < _10985 + return_data.size
                                                        _11193 = mem[_10985 + mem[_10985]]
                                                        if mem[_10985 + mem[_10985]] > test266151307():
                                                            revert with 0, 65
                                                        if _10985 + ceil32(return_data.size) + ceil32(32 * mem[_10985 + mem[_10985]]) + 1 > test266151307() or ceil32(32 * mem[_10985 + mem[_10985]]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _10985 + ceil32(return_data.size) + ceil32(32 * mem[_10985 + mem[_10985]]) + 1
                                                        mem[_10985 + ceil32(return_data.size)] = _11193
                                                        require return_data.size >= _11089 + (32 * _11193) + 32
                                                        mem[_10985 + ceil32(return_data.size) + 32 len 32 * _11193] = mem[_10985 + _11089 + 32 len 32 * _11193]
                                                        if 0 >= _11193:
                                                            revert with 0, 50
                                                        _12841 = mem[_10985 + ceil32(return_data.size) + 32]
                                                        if mem[_10985 + ceil32(return_data.size) + 32] and sub_fd53fce0 > -1 / mem[_10985 + ceil32(return_data.size) + 32]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12841 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12841 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13209 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13209] == bool(mem[_13209])
                                                        if arg4 < _12841:
                                                            revert with 0, 17
                                                        if arg4 - _12841 < _12841 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12841 - (_12841 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12841 - (_12841 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13401 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13401] == bool(mem[_13401])
                                                        emit 0xfedb587d: tokenAddress, _12841, address(arg2), arg3
                                            else:
                                                mem[(4 * ceil32(return_data.size)) + 128] = 3
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[(4 * ceil32(return_data.size)) + 256] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[64] = (6 * ceil32(return_data.size)) + 256
                                                require return_data.size >= 32
                                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 192] = ext_call.return_data[12 len 20]
                                                mem[(4 * ceil32(return_data.size)) + 160] = tokenAddress
                                                mem[(4 * ceil32(return_data.size)) + 224] = address(arg2)
                                                mem[(6 * ceil32(return_data.size)) + 256] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
                                                mem[(6 * ceil32(return_data.size)) + 260] = arg3
                                                mem[(6 * ceil32(return_data.size)) + 292] = 64
                                                mem[(6 * ceil32(return_data.size)) + 324] = 3
                                                idx = 0
                                                s = (4 * ceil32(return_data.size)) + 160
                                                t = (6 * ceil32(return_data.size)) + 356
                                                while idx < mem[(4 * ceil32(return_data.size)) + 128]:
                                                    mem[t] = mem[s + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                require ext_code.size(stor101)
                                                staticcall stor101.mem[mem[64] len 4] with:
                                                        gas gas_remaining wei
                                                       args mem[mem[64] + 4 len (6 * ceil32(return_data.size)) + -mem[64] + 448]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _4414 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _4478 = mem[_4414]
                                                require mem[_4414] <= test266151307()
                                                require _4414 + mem[_4414] + 31 < _4414 + return_data.size
                                                _4554 = mem[_4414 + mem[_4414]]
                                                if mem[_4414 + mem[_4414]] > test266151307():
                                                    revert with 0, 65
                                                if _4414 + ceil32(return_data.size) + ceil32(32 * mem[_4414 + mem[_4414]]) + 1 > test266151307() or ceil32(32 * mem[_4414 + mem[_4414]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _4414 + ceil32(return_data.size) + ceil32(32 * mem[_4414 + mem[_4414]]) + 1
                                                mem[_4414 + ceil32(return_data.size)] = _4554
                                                require return_data.size >= _4478 + (32 * _4554) + 32
                                                mem[_4414 + ceil32(return_data.size) + 32 len 32 * _4554] = mem[_4414 + _4478 + 32 len 32 * _4554]
                                                if 0 >= _4554:
                                                    revert with 0, 50
                                                if 100 * 10^6 > !sub_fd53fce0:
                                                    revert with 0, 17
                                                if mem[_4414 + ceil32(return_data.size) + 32] and sub_fd53fce0 + 100 * 10^6 > -1 / mem[_4414 + ceil32(return_data.size) + 32]:
                                                    revert with 0, 17
                                                if (100 * 10^6 * mem[_4414 + ceil32(return_data.size) + 32]) + (sub_fd53fce0 * mem[_4414 + ceil32(return_data.size) + 32]) / 100 * 10^6 > arg4:
                                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                                require ext_code.size(stor101)
                                                staticcall stor101.WAVAX() with:
                                                        gas gas_remaining wei
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7986 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_7986] == mem[_7986 + 12 len 20]
                                                if address(arg2) == mem[_7986 + 12 len 20]:
                                                    _8123 = mem[64]
                                                    mem[mem[64]] = 2
                                                    mem[64] = mem[64] + 96
                                                    if not mem[_8123]:
                                                        revert with 0, 50
                                                    mem[_8123 + 32] = tokenAddress
                                                    if 1 >= mem[_8123]:
                                                        revert with 0, 50
                                                    mem[_8123 + 64] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8123 + 96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8123 + ceil32(return_data.size) + 96
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8123 + ceil32(return_data.size) + 96] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8123 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8123 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8123 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8123 + ceil32(return_data.size) + 260] = mem[_8123]
                                                        idx = 0
                                                        s = _8123 + 32
                                                        t = _8123 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8123]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8123 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8123 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8123 + ceil32(return_data.size) + 260 len (32 * mem[_8123]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8123 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8123 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11086 = mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8123 + ceil32(return_data.size) + return_data.size + 96
                                                        _11190 = mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8123 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8123 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8123 + (2 * ceil32(return_data.size)) + 96] = mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        require return_data.size >= _11086 + (32 * _11190) + 32
                                                        mem[_8123 + (2 * ceil32(return_data.size)) + 128 len 32 * _11190] = mem[_8123 + ceil32(return_data.size) + _11086 + 128 len 32 * _11190]
                                                        if 0 >= _11190:
                                                            revert with 0, 50
                                                        _12838 = mem[_8123 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8123 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8123 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12838 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12838 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13206 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13206] == bool(mem[_13206])
                                                        if arg4 < _12838:
                                                            revert with 0, 17
                                                        if arg4 - _12838 < _12838 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12838 - (_12838 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12838 - (_12838 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13398 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13398] == bool(mem[_13398])
                                                        emit 0xfedb587d: tokenAddress, _12838, address(arg2), arg3
                                                    else:
                                                        mem[_8123 + ceil32(return_data.size) + 96] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8123 + ceil32(return_data.size) + 100] = arg3
                                                        mem[_8123 + ceil32(return_data.size) + 132] = arg4
                                                        mem[_8123 + ceil32(return_data.size) + 164] = 160
                                                        mem[_8123 + ceil32(return_data.size) + 260] = mem[_8123]
                                                        idx = 0
                                                        s = _8123 + 32
                                                        t = _8123 + ceil32(return_data.size) + 292
                                                        while idx < mem[_8123]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8123 + ceil32(return_data.size) + 196] = address(arg1)
                                                        mem[_8123 + ceil32(return_data.size) + 228] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8123 + ceil32(return_data.size) + 260 len (32 * mem[_8123]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8123 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8123 + (2 * ceil32(return_data.size)) + 96
                                                        require return_data.size >= 32
                                                        _11087 = mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 127 < _8123 + ceil32(return_data.size) + return_data.size + 96
                                                        _11191 = mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        if mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96] > test266151307():
                                                            revert with 0, 65
                                                        if _8123 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97 > test266151307() or ceil32(32 * mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8123 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]) + 97
                                                        mem[_8123 + (2 * ceil32(return_data.size)) + 96] = mem[_8123 + ceil32(return_data.size) + mem[_8123 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, arg3) >> 32 + 96]
                                                        require return_data.size >= _11087 + (32 * _11191) + 32
                                                        mem[_8123 + (2 * ceil32(return_data.size)) + 128 len 32 * _11191] = mem[_8123 + ceil32(return_data.size) + _11087 + 128 len 32 * _11191]
                                                        if 0 >= _11191:
                                                            revert with 0, 50
                                                        _12839 = mem[_8123 + (2 * ceil32(return_data.size)) + 128]
                                                        if mem[_8123 + (2 * ceil32(return_data.size)) + 128] and sub_fd53fce0 > -1 / mem[_8123 + (2 * ceil32(return_data.size)) + 128]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12839 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12839 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13207 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13207] == bool(mem[_13207])
                                                        if arg4 < _12839:
                                                            revert with 0, 17
                                                        if arg4 - _12839 < _12839 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12839 - (_12839 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12839 - (_12839 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13399 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13399] == bool(mem[_13399])
                                                        emit 0xfedb587d: tokenAddress, _12839, address(arg2), arg3
                                                else:
                                                    _8120 = mem[64]
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[mem[64] + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if 1 >= mem[_8120]:
                                                        revert with 0, 50
                                                    mem[_8120 + 64] = ext_call.return_data[12 len 20]
                                                    if not mem[_8120]:
                                                        revert with 0, 50
                                                    mem[_8120 + 32] = tokenAddress
                                                    if 2 >= mem[_8120]:
                                                        revert with 0, 50
                                                    mem[_8120 + 96] = address(arg2)
                                                    require ext_code.size(stor101)
                                                    staticcall stor101.WAVAX() with:
                                                            gas gas_remaining wei
                                                    mem[_8120 + ceil32(return_data.size) + 128] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[64] = _8120 + (2 * ceil32(return_data.size)) + 128
                                                    require return_data.size >= 32
                                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                                    if address(arg2) != ext_call.return_data[12 len 20]:
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 128] = 0x8803dbee00000000000000000000000000000000000000000000000000000000
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 292] = mem[_8120]
                                                        idx = 0
                                                        s = _8120 + 32
                                                        t = _8120 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8120]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8120 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8120]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8120 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11084 = mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8120 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11188 = mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8120 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8120 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8120 + (4 * ceil32(return_data.size)) + 128] = mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        require return_data.size >= _11084 + (32 * _11188) + 32
                                                        mem[_8120 + (4 * ceil32(return_data.size)) + 160 len 32 * _11188] = mem[_8120 + (2 * ceil32(return_data.size)) + _11084 + 160 len 32 * _11188]
                                                        if 0 >= _11188:
                                                            revert with 0, 50
                                                        _12836 = mem[_8120 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8120 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8120 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12836 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12836 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13204 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13204] == bool(mem[_13204])
                                                        if arg4 < _12836:
                                                            revert with 0, 17
                                                        if arg4 - _12836 < _12836 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12836 - (_12836 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12836 - (_12836 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13396 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13396] == bool(mem[_13396])
                                                        emit 0xfedb587d: tokenAddress, _12836, address(arg2), arg3
                                                    else:
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 128] = 0x7a42416a00000000000000000000000000000000000000000000000000000000
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 132] = arg3
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 164] = arg4
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 196] = 160
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 292] = mem[_8120]
                                                        idx = 0
                                                        s = _8120 + 32
                                                        t = _8120 + (2 * ceil32(return_data.size)) + 324
                                                        while idx < mem[_8120]:
                                                            mem[t] = mem[s + 12 len 20]
                                                            idx = idx + 1
                                                            s = s + 32
                                                            t = t + 32
                                                            continue 
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 228] = address(arg1)
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 260] = arg5
                                                        require ext_code.size(stor101)
                                                        call stor101.swapTokensForExactAVAX(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                             gas gas_remaining wei
                                                            args arg3, arg4, 160, address(arg1), arg5, mem[_8120 + (2 * ceil32(return_data.size)) + 292 len (32 * mem[_8120]) + 32]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        mem[_8120 + (2 * ceil32(return_data.size)) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                        mem[64] = _8120 + (4 * ceil32(return_data.size)) + 128
                                                        require return_data.size >= 32
                                                        _11085 = mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32
                                                        require mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
                                                        require _8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 159 < _8120 + (2 * ceil32(return_data.size)) + return_data.size + 128
                                                        _11189 = mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        if mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128] > test266151307():
                                                            revert with 0, 65
                                                        if _8120 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129 > test266151307() or ceil32(32 * mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 1 < 0:
                                                            revert with 0, 65
                                                        mem[64] = _8120 + (4 * ceil32(return_data.size)) + ceil32(32 * mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]) + 129
                                                        mem[_8120 + (4 * ceil32(return_data.size)) + 128] = mem[_8120 + (2 * ceil32(return_data.size)) + mem[_8120 + (2 * ceil32(return_data.size)) + 128 len 4], Mask(224, 32, arg3) >> 32 + 128]
                                                        require return_data.size >= _11085 + (32 * _11189) + 32
                                                        mem[_8120 + (4 * ceil32(return_data.size)) + 160 len 32 * _11189] = mem[_8120 + (2 * ceil32(return_data.size)) + _11085 + 160 len 32 * _11189]
                                                        if 0 >= _11189:
                                                            revert with 0, 50
                                                        _12837 = mem[_8120 + (4 * ceil32(return_data.size)) + 160]
                                                        if mem[_8120 + (4 * ceil32(return_data.size)) + 160] and sub_fd53fce0 > -1 / mem[_8120 + (4 * ceil32(return_data.size)) + 160]:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = sub_11eb47dcAddress
                                                        mem[mem[64] + 36] = _12837 * sub_fd53fce0 / 100 * 10^6
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args sub_11eb47dcAddress, _12837 * sub_fd53fce0 / 100 * 10^6
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13205 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13205] == bool(mem[_13205])
                                                        if arg4 < _12837:
                                                            revert with 0, 17
                                                        if arg4 - _12837 < _12837 * sub_fd53fce0 / 100 * 10^6:
                                                            revert with 0, 17
                                                        mem[mem[64] + 4] = address(arg1)
                                                        mem[mem[64] + 36] = arg4 - _12837 - (_12837 * sub_fd53fce0 / 100 * 10^6)
                                                        require ext_code.size(stor105)
                                                        call stor105.transfer(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(arg1), arg4 - _12837 - (_12837 * sub_fd53fce0 / 100 * 10^6)
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _13397 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_13397] == bool(mem[_13397])
                                                        emit 0xfedb587d: tokenAddress, _12837, address(arg2), arg3
}



}

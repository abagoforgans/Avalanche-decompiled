contract main {




// =====================  Runtime code  =====================


#
#  - sub_4f08a863(?)
#  - sub_8706b531(?)
#  - tokenURI(uint256 arg1)
#
array of uint256 stor1;
array of uint256 stor2;
array of uint256 stor4;
array of uint256 stor5;
array of uint256 stor6;
array of struct stor101;
array of struct stor102;
mapping of address ownerOf;
mapping of uint256 balanceOf;
mapping of address approved;
mapping of uint8 stor106;
address owner;
mapping of struct sub_79ba2fa2;
mapping of uint256 sub_2b1331a8;
uint256 numMinted;
mapping of struct sub_be75288d;
uint256 presaleStartTime;
uint256 presaleEndTime;
uint8 transfersEnabled; offset 160
address _signerAddress;
uint256 launchTime;
uint256 sub_f9caa583;
address sub_cd38b90aAddress;
address sub_77b53eceAddress;
address sub_40c397daAddress;
address treasuryAddress;
address teamWalletAddress;
address sub_18551108Address;
uint256 sub_11a040ac;
uint256 stor217;
uint8 paused;
array of struct stor317;
uint256 stor2149;
uint256 storB469;

function getApproved(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function sub_11a040ac(?) payable {
    return sub_11a040ac
}

function teamWalletAddress() payable {
    return teamWalletAddress
}

function sub_18551108(?) payable {
    return sub_18551108Address
}

function presaleEndTime() payable {
    return presaleEndTime
}

function sub_2b1331a8(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[arg1][arg2]
}

function sub_30ec18c2(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_2b1331a8[address(arg1)][arg2]
}

function sub_40c397da(?) payable {
    return sub_40c397daAddress
}

function paused() payable {
    return bool(paused)
}

function ownerOf(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    return ownerOf[arg1]
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function sub_77b53ece(?) payable {
    return sub_77b53eceAddress
}

function launchTime() payable {
    return launchTime
}

function sub_79ba2fa2(?) payable {
    require calldata.size - 4 >= 32
    return sub_79ba2fa2[arg1].field_512
}

function owner() payable {
    return owner
}

function presaleStartTime() payable {
    return presaleStartTime
}

function sub_be75288d(?) payable {
    require calldata.size - 4 >= 32
    return sub_be75288d[arg1].field_256
}

function transfersEnabled() payable {
    return bool(transfersEnabled)
}

function _signerAddress() payable {
    return _signerAddress
}

function treasuryAddress() payable {
    return treasuryAddress
}

function sub_cd38b90a(?) payable {
    return sub_cd38b90aAddress
}

function numMinted() payable {
    return numMinted
}

function sub_e31ffb63(?) payable {
    require calldata.size - 4 >= 32
    return sub_be75288d[stor201[arg1].field_0].field_1024
}

function isApprovedForAll(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor106[address(arg1)][address(arg2)])
}

function sub_f9caa583(?) payable {
    return sub_f9caa583
}

function _fallback() payable {
    revert
}

function totalSupply() payable {
    if numMinted < sub_11a040ac:
        revert with 0, 17
    return (numMinted - sub_11a040ac)
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function setLaunchTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    launchTime = arg1
}

function setBondDiscount(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_f9caa583 = arg1
}

function sub_1593d8a5(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_256 = arg2
}

function sub_e345c564(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_512 = arg2
}

function sub_135ee927(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1536 = arg2
}

function sub_72c0ab83(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1024 = arg2
}

function sub_d010ad7f(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_be75288d[arg1].field_1280 = arg2
}

function pause() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if paused:
        revert with 0, 'Pausable: paused'
    paused = 1
    emit Paused(msg.sender);
}

function unpause() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not paused:
        revert with 0, 'Pausable: not paused'
    paused = 0
    emit Unpaused(msg.sender);
}

function setTreasuryAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    treasuryAddress = arg1
}

function setTeamWalletAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    teamWalletAddress = arg1
}

function sub_76496784(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_18551108Address = address(arg1)
}

function sub_baabc801(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_cd38b90aAddress = address(arg1)
}

function sub_f3fd622f(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_77b53eceAddress = address(arg1)
}

function setLiquidityPairAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_40c397daAddress = arg1
}

function setApprovalForAll(address arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor106[address(msg.sender)][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function Sweep(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call arg1 with:
       value arg2 wei
         gas gas_remaining wei
    if not ext_call.success:
        revert with 0, 'Failed to send AVAX'
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000
}

function supportsInterface(bytes4 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2] != msg.sender:
        if not stor106[stor103[arg2]][address(msg.sender)]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function sub_b38344cf(?) payable {
    require ext_code.size(sub_cd38b90aAddress)
    staticcall sub_cd38b90aAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sub_77b53eceAddress)
    staticcall sub_77b53eceAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'divison by zero error'
    if ext_call.return_data[0] > 0x14484bfeebc29f863424b06f3529a051a31be599:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    return (1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0])
}

function getShares(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    if not balanceOf[address(arg1)]:
        return 0
    idx = 1
    s = 0
    while idx <= numMinted:
        mem[0] = idx
        mem[32] = 103
        if not ownerOf[idx]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        mem[0] = idx
        mem[32] = 103
        if not ownerOf[idx]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
        if ownerOf[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        mem[0] = sub_79ba2fa2[idx].field_0
        mem[32] = 204
        if s > !(sub_be75288d[stor201[idx].field_0].field_512 / 10^18):
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + (sub_be75288d[stor201[idx].field_0].field_512 / 10^18)
        continue 
    return s
}

function sub_1d70dbdc(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if not address(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    if not balanceOf[address(arg1)]:
        return ''
    if balanceOf[address(arg1)] > test266151307():
        revert with 0, 65
    if balanceOf[address(arg1)]:
        mem[128 len 32 * balanceOf[address(arg1)]] = call.data[calldata.size len 32 * balanceOf[address(arg1)]]
    idx = 1
    s = 0
    while idx <= numMinted:
        mem[0] = idx
        mem[32] = 103
        if not ownerOf[idx]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        mem[0] = idx
        mem[32] = 103
        if not ownerOf[idx]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        if ownerOf[idx] != address(arg1):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if s >= balanceOf[address(arg1)]:
            revert with 0, 50
        mem[(32 * s) + 128] = idx
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    return Array(len=balanceOf[address(arg1)], data=mem[128 len 32 * balanceOf[address(arg1)]])
}

function sub_3a0a52e4(?) payable {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(sub_be75288d[arg1].field_1792):
        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
            revert with 0, 34
        if arg2.length:
            sub_be75288d[arg1][7][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            sub_be75288d[arg1].field_1792 = 0
            idx = 0
            while sub_be75288d[arg1].field_1793 % 128 + 31 / 32 > idx:
                sub_be75288d[arg1][idx + 7].field_0 = 0
                idx = idx + 1
                continue 
}

function sub_d83b2611(?) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(sub_cd38b90aAddress)
    staticcall sub_cd38b90aAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sub_77b53eceAddress)
    staticcall sub_77b53eceAddress.0x70a08231 with:
            gas gas_remaining wei
           args sub_40c397daAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        revert with 0, 'divison by zero error'
    if ext_call.return_data[0] > 0x14484bfeebc29f863424b06f3529a051a31be599:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    if sub_be75288d[arg1].field_512 / 10^18 and 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] > -1 / sub_be75288d[arg1].field_512 / 10^18:
        revert with 0, 17
    if 100 < sub_f9caa583:
        revert with 0, 17
    if sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12 and -sub_f9caa583 + 100 > -1 / sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12:
        revert with 0, 17
    return ((100 * sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12) - (sub_f9caa583 * sub_be75288d[arg1].field_512 / 10^18 * 1000000000000 * 10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 10^12) / 100)
}

function sub_6ccf4a4a(?) payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    staticcall 'console.log'.log(string arg1) with:
            gas gas_remaining wei
           args 0, 'Increasing tier for 598 and 604', 0
    if sub_2b1331a8[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49][0] < 1:
        revert with 0, 17
    sub_2b1331a8[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49][0]--
    if sub_2b1331a8[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49][1] > -2:
        revert with 0, 17
    sub_2b1331a8[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49][1]++
    if storB469 > -2:
        revert with 0, 17
    storB469++
    if sub_2b1331a8[0xa27c2f691282b39cd52228d12a905dceefd6ee18][1] < 1:
        revert with 0, 17
    sub_2b1331a8[0xa27c2f691282b39cd52228d12a905dceefd6ee18][1]--
    if sub_2b1331a8[0xa27c2f691282b39cd52228d12a905dceefd6ee18][2] > -2:
        revert with 0, 17
    sub_2b1331a8[0xa27c2f691282b39cd52228d12a905dceefd6ee18][2]++
    if stor2149 > -2:
        revert with 0, 17
    stor2149++
    if 0 >= stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49].field_0:
        revert with 0, 50
    staticcall 'console.log'.0x969cdd03 with:
            gas gas_remaining wei
           args 0, 96, stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49].field_0, stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49].field_0, 13, 'Before %s, %s', 0
    if not stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49][1][598].field_0:
        stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49].field_0++
        stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49][stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49].field_0].field_0 = 598
        stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49][1][598].field_0 = stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49].field_0
    staticcall 'console.log'.0x9710a9d0 with:
            gas gas_remaining wei
           args 0, 64, stor317[0xd5adc02d2cc2316837b0b6d4d8cb95b43e26ef49].field_0, 8, 'After %s', 0
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
    if not arg1:
        if not arg2:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
    else:
        if not arg2:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
        else:
            if not transfersEnabled:
                if arg1 != this.address:
                    revert with 0, 'Transfers not enabled yet'
            if not arg2:
                if sub_11a040ac > -2:
                    revert with 0, 17
                sub_11a040ac++
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    require ext_code.size(sub_18551108Address)
    call sub_18551108Address.0x95ff495a with:
         gas gas_remaining wei
        args address(arg1), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if not arg1:
        if not arg2:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
    else:
        if not arg2:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
        else:
            if not transfersEnabled:
                if arg1 != this.address:
                    revert with 0, 'Transfers not enabled yet'
            if not arg2:
                if sub_11a040ac > -2:
                    revert with 0, 17
                sub_11a040ac++
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    require ext_code.size(sub_18551108Address)
    call sub_18551108Address.0x95ff495a with:
         gas gas_remaining wei
        args address(arg1), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.0x150b7a02 with:
             gas gas_remaining wei
            args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
        if not ext_call.success:
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    require arg4 + arg4.length + 36 <= calldata.size
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if not arg1:
        if not arg2:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
    else:
        if not arg2:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
        else:
            if not transfersEnabled:
                if arg1 != this.address:
                    revert with 0, 'Transfers not enabled yet'
            if not arg2:
                if sub_11a040ac > -2:
                    revert with 0, 17
                sub_11a040ac++
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    require ext_code.size(sub_18551108Address)
    call sub_18551108Address.0x95ff495a with:
         gas gas_remaining wei
        args address(arg1), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if ext_code.size(arg2):
        require ext_code.size(arg2)
        call arg2.0x150b7a02 with:
             gas gas_remaining wei
            args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
        if not ext_call.success:
            if not return_data.size:
                if not arg4.length:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with arg4[all]
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function sub_52b391b2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if not address(arg1):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    mem[128 len 128] = call.data[calldata.size len 128]
    if not balanceOf[address(arg1)]:
        mem[256] = 0
        idx = 1
        s = 0
        while idx <= numMinted:
            mem[0] = idx
            mem[32] = 103
            if not ownerOf[idx]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if sub_79ba2fa2[idx].field_0 >= 4:
                revert with 0, 50
            if mem[(32 * sub_79ba2fa2[idx].field_0) + 128] == -1:
                revert with 0, 17
            mem[(32 * sub_79ba2fa2[idx].field_0) + 128] = mem[(32 * sub_79ba2fa2[idx].field_0) + 128] + 1
            mem[0] = idx
            mem[32] = 103
            if not ownerOf[idx]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[idx] != address(arg1):
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if s == -1:
                revert with 0, 17
            if s >= mem[256]:
                revert with 0, 50
            mem[(32 * s) + 288] = idx
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 1
            continue 
        mem[288] = 64
        mem[352] = mem[256]
        mem[384 len 32 * mem[256]] = mem[288 len 32 * mem[256]]
        mem[(32 * mem[256]) + 384] = 4
        return Array(len=mem[256], data=mem[384 len (32 * mem[256]) + 32], mem[128 len 128]), (32 * mem[256]) + 96
    if balanceOf[address(arg1)] > test266151307():
        revert with 0, 65
    mem[256] = balanceOf[address(arg1)]
    if balanceOf[address(arg1)]:
        mem[288 len 32 * balanceOf[address(arg1)]] = call.data[calldata.size len 32 * balanceOf[address(arg1)]]
    idx = 1
    s = 0
    while idx <= numMinted:
        mem[0] = idx
        mem[32] = 103
        if not ownerOf[idx]:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if sub_79ba2fa2[idx].field_0 >= 4:
            revert with 0, 50
        if mem[(32 * sub_79ba2fa2[idx].field_0) + 128] == -1:
            revert with 0, 17
        mem[(32 * sub_79ba2fa2[idx].field_0) + 128] = mem[(32 * sub_79ba2fa2[idx].field_0) + 128] + 1
        mem[0] = idx
        mem[32] = 103
        if not ownerOf[idx]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        if ownerOf[idx] != address(arg1):
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if s == -1:
            revert with 0, 17
        if s >= mem[256]:
            revert with 0, 50
        mem[(32 * s) + 288] = idx
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 1
        continue 
    mem[(32 * balanceOf[address(arg1)]) + 288] = 64
    mem[(32 * balanceOf[address(arg1)]) + 352] = mem[256]
    mem[(32 * balanceOf[address(arg1)]) + 384 len 32 * mem[256]] = mem[288 len 32 * mem[256]]
    mem[(32 * balanceOf[address(arg1)]) + (32 * mem[256]) + 384] = 4
    return Array(len=mem[256], data=mem[(32 * balanceOf[address(arg1)]) + 384 len (32 * mem[256]) + 32], mem[128 len 128]), 
           (32 * mem[256]) + 96
}

function name() payable {
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor101.length):
            if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor101.length):
                if 31 < uint255(stor101.length) * 0.5:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor101.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
        else:
            if bool(stor101.length) == stor101.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor101.length.field_1 % 128:
                if 31 < stor101.length.field_1 % 128:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while stor101.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
        mem[ceil32(uint255(stor101.length) * 0.5) + 192 len ceil32(uint255(stor101.length) * 0.5)] = mem[128 len ceil32(uint255(stor101.length) * 0.5)]
        if ceil32(uint255(stor101.length) * 0.5) > uint255(stor101.length) * 0.5:
            mem[(uint255(stor101.length) * 0.5) + ceil32(uint255(stor101.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)], mem[(2 * ceil32(uint255(stor101.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor101.length) * 0.5)]), 
    if bool(stor101.length) == stor101.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor101.length):
            if 31 < uint255(stor101.length) * 0.5:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while (uint255(stor101.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
    else:
        if bool(stor101.length) == stor101.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor101.length.field_1 % 128:
            if 31 < stor101.length.field_1 % 128:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while stor101.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor101.length.field_8)
    mem[ceil32(stor101.length.field_1 % 128) + 192 len ceil32(stor101.length.field_1 % 128)] = mem[128 len ceil32(stor101.length.field_1 % 128)]
    if ceil32(stor101.length.field_1 % 128) > stor101.length.field_1 % 128:
        mem[stor101.length.field_1 % 128 + ceil32(stor101.length.field_1 % 128) + 192] = 0
    return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1 % 128)], mem[(2 * ceil32(stor101.length.field_1 % 128)) + 192 len 2 * ceil32(stor101.length.field_1 % 128)]), 
}

function symbol() payable {
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor102.length):
            if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor102.length):
                if 31 < uint255(stor102.length) * 0.5:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor102.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
        else:
            if bool(stor102.length) == stor102.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor102.length.field_1 % 128:
                if 31 < stor102.length.field_1 % 128:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while stor102.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
        mem[ceil32(uint255(stor102.length) * 0.5) + 192 len ceil32(uint255(stor102.length) * 0.5)] = mem[128 len ceil32(uint255(stor102.length) * 0.5)]
        if ceil32(uint255(stor102.length) * 0.5) > uint255(stor102.length) * 0.5:
            mem[(uint255(stor102.length) * 0.5) + ceil32(uint255(stor102.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)], mem[(2 * ceil32(uint255(stor102.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor102.length) * 0.5)]), 
    if bool(stor102.length) == stor102.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor102.length):
            if 31 < uint255(stor102.length) * 0.5:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while (uint255(stor102.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
    else:
        if bool(stor102.length) == stor102.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor102.length.field_1 % 128:
            if 31 < stor102.length.field_1 % 128:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while stor102.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor102.length.field_8)
    mem[ceil32(stor102.length.field_1 % 128) + 192 len ceil32(stor102.length.field_1 % 128)] = mem[128 len ceil32(stor102.length.field_1 % 128)]
    if ceil32(stor102.length.field_1 % 128) > stor102.length.field_1 % 128:
        mem[stor102.length.field_1 % 128 + ceil32(stor102.length.field_1 % 128) + 192] = 0
    return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1 % 128)], mem[(2 * ceil32(stor102.length.field_1 % 128)) + 192 len 2 * ceil32(stor102.length.field_1 % 128)]), 
}

function getPendingRewards(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if sub_79ba2fa2[arg1].field_512 >= launchTime:
        if block.timestamp < sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if block.timestamp - sub_79ba2fa2[arg1].field_512 <= sub_be75288d[stor201[arg1].field_0].field_1280:
            if block.timestamp - sub_79ba2fa2[arg1].field_512 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[arg1].field_512:
                revert with 0, 17
            return ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600)
        if block.timestamp - sub_79ba2fa2[arg1].field_512 < sub_be75288d[stor201[arg1].field_0].field_1280:
            revert with 0, 17
        if block.timestamp - sub_79ba2fa2[arg1].field_512 - sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[arg1].field_512 - sub_be75288d[stor201[arg1].field_0].field_1280:
            revert with 0, 17
        if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024):
            revert with 0, 17
        if sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / sub_be75288d[stor201[arg1].field_0].field_1280:
            revert with 0, 17
        if sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 > !((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100):
            revert with 0, 17
        return ((sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600)
    if block.timestamp < launchTime:
        revert with 0, 17
    if block.timestamp - launchTime <= sub_be75288d[stor201[arg1].field_0].field_1280:
        if block.timestamp - launchTime and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - launchTime:
            revert with 0, 17
        return ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600)
    if block.timestamp - launchTime < sub_be75288d[stor201[arg1].field_0].field_1280:
        revert with 0, 17
    if block.timestamp - launchTime - sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - launchTime - sub_be75288d[stor201[arg1].field_0].field_1280:
        revert with 0, 17
    if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024):
        revert with 0, 17
    if sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / sub_be75288d[stor201[arg1].field_0].field_1280:
        revert with 0, 17
    if sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 > !((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100):
        revert with 0, 17
    return ((sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600)
}

function sub_ffeab7d1(?) payable {
    if paused:
        revert with 0, 'Pausable: paused'
    if stor217 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor217 = 2
    mem[96] = 17
    mem[128] = 'Claimer sender %s' << 120
    mem[196] = 64
    mem[260] = 17
    mem[292] = 'Claimer sender %s' << 120
    mem[309] = 0
    mem[228] = msg.sender
    mem[160] = 132
    mem[64] = 324
    mem[196 len 28] = 0
    mem[192 len 4] = log(string arg1, address arg2)
    staticcall 'console.log'.log(string arg1, address arg2) with:
            gas gas_remaining wei
           args 0, 0, msg.sender, 17, 'Claimer sender %s', 0
    if stor317[msg.sender].field_0 <= 0:
        revert with 0, 'No nodes to claim'
    if var118002 >= var118001:
        if not var118003:
            revert with 0, 'No nodes to claim'
        stor217 = 1
    if var124001 >= stor[var124002]:
        revert with 0, 50
    if block.timestamp < sub_79ba2fa2[var130001].field_512:
        if var130003 == -1:
            revert with 0, 17
        if var130003 + 1 >= stor317[msg.sender].field_0:
            if not var130004:
                revert with 0, 'No nodes to claim'
            stor217 = 1
        mem[32] = 317
        if var130003 + 1 >= stor317[msg.sender].field_0:
            revert with 0, 50
        mem[0] = sha3(msg.sender, 317)
        var130001 = stor317[msg.sender][var130003].field_256
        var130003 = var130003 + 1
        var130004 = var130004
        continue 
    if not ownerOf[var130001]:
        if var130003 == -1:
            revert with 0, 17
        if var130003 + 1 >= stor317[msg.sender].field_0:
            if not var130004:
                revert with 0, 'No nodes to claim'
            stor217 = 1
        mem[32] = 317
        if var130003 + 1 >= stor317[msg.sender].field_0:
            revert with 0, 50
        mem[0] = sha3(msg.sender, 317)
        var130001 = stor317[msg.sender][var130003].field_256
        var130003 = var130003 + 1
        var130004 = var130004
        continue 
    if not ownerOf[var130001]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[var130001] != this.address:
        if var130003 == -1:
            revert with 0, 17
        if var130003 + 1 >= stor317[msg.sender].field_0:
            if not var130004:
                revert with 0, 'No nodes to claim'
            stor217 = 1
        mem[32] = 317
        if var130003 + 1 >= stor317[msg.sender].field_0:
            revert with 0, 50
        mem[0] = sha3(msg.sender, 317)
        var130001 = stor317[msg.sender][var130003].field_256
        var130003 = var130003 + 1
        var130004 = var130004
        continue 
    mem[64] = 356
    mem[324] = 0
    if not ownerOf[var130001]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[var130001] != this.address:
        revert with 0, 'ERC721: transfer from incorrect owner'
    if not msg.sender:
        revert with 0, 'ERC721: transfer to the zero address'
    if not this.address:
        if not msg.sender:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
    else:
        if not msg.sender:
            if sub_11a040ac > -2:
                revert with 0, 17
            sub_11a040ac++
        else:
            if not transfersEnabled:
                if this.address != this.address:
                    revert with 0, 'Transfers not enabled yet'
            if not msg.sender:
                if sub_11a040ac > -2:
                    revert with 0, 17
                sub_11a040ac++
    approved[var130001] = 0
    if not ownerOf[var130001]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[var130001], 0, var130001);
    if balanceOf[address(this.address)] < 1:
        revert with 0, 17
    balanceOf[address(this.address)]--
    if balanceOf[address(msg.sender)] > -2:
        revert with 0, 17
    balanceOf[address(msg.sender)]++
    ownerOf[var130001] = msg.sender
    emit Transfer(this.address, msg.sender, var130001);
    mem[356] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
    mem[360] = this.address
    mem[392] = msg.sender
    require ext_code.size(sub_18551108Address)
    call sub_18551108Address.0x95ff495a with:
         gas gas_remaining wei
        args address(this.address), msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if ext_code.size(msg.sender):
        mem[360] = msg.sender
        mem[392] = this.address
        mem[424] = var130001
        mem[456] = 128
        mem[488] = 0
        mem[520 len 0] = None
        require ext_code.size(msg.sender)
        call msg.sender.0x150b7a02 with:
             gas gas_remaining wei
            args msg.sender, address(this.address), var130001, 128, 0
        mem[356] = ext_call.return_data[0]
        if not ext_call.success:
            if not return_data.size:
                revert with 'Claimer sender %s'
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 356
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
    if not sub_79ba2fa2[var130001].field_768:
        if 720 * 24 * 3600 > !sub_79ba2fa2[var130001].field_512:
            revert with 0, 17
        sub_79ba2fa2[var130001].field_768 = sub_79ba2fa2[var130001].field_512 + (720 * 24 * 3600)
    if var130003 == -1:
        revert with 0, 17
    if var130003 + 1 >= stor317[msg.sender].field_0:
        stor217 = 1
    mem[32] = 317
    if var130003 + 1 >= stor317[msg.sender].field_0:
        revert with 0, 50
    mem[0] = sha3(msg.sender, 317)
    var130001 = stor317[msg.sender][var130003].field_256
    var130003 = var130003 + 1
    var130004 = 1
    continue 
}

function sub_c35f6368(?) payable {
    require calldata.size - 4 >= 32
    if paused:
        revert with 0, 'Pausable: paused'
    if stor217 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor217 = 2
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg1] != msg.sender:
        revert with 0, 'This is not your Node!'
    if this.address == msg.sender:
        revert with 0, 'Can't claim from the contract'
    if block.timestamp < launchTime:
        revert with 0, 'Not launched yet'
    if not launchTime:
        revert with 0, 'Not launched yet'
    if 24 * 3600 > !launchTime:
        revert with 0, 17
    if block.timestamp <= launchTime + (24 * 3600):
        revert with 0, 'Must wait 24h from launch'
    if sub_79ba2fa2[arg1].field_512 >= launchTime:
        if block.timestamp < sub_79ba2fa2[arg1].field_512:
            revert with 0, 17
        if block.timestamp - sub_79ba2fa2[arg1].field_512 <= sub_be75288d[stor201[arg1].field_0].field_1280:
            if block.timestamp - sub_79ba2fa2[arg1].field_512 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[arg1].field_512:
                revert with 0, 17
            if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600:
                revert with 0, 17
            sub_79ba2fa2[arg1].field_512 = block.timestamp
            if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000:
                revert with 0, 17
            require ext_code.size(sub_cd38b90aAddress)
            call sub_cd38b90aAddress.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000)
        else:
            if block.timestamp - sub_79ba2fa2[arg1].field_512 < sub_be75288d[stor201[arg1].field_0].field_1280:
                revert with 0, 17
            if block.timestamp - sub_79ba2fa2[arg1].field_512 - sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[arg1].field_512 - sub_be75288d[stor201[arg1].field_0].field_1280:
                revert with 0, 17
            if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024):
                revert with 0, 17
            if sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / sub_be75288d[stor201[arg1].field_0].field_1280:
                revert with 0, 17
            if sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 > !((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100):
                revert with 0, 17
            if (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 and sub_79ba2fa2[arg1].field_256 > -1 / (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600:
                revert with 0, 17
            sub_79ba2fa2[arg1].field_512 = block.timestamp
            if (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 < (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000:
                revert with 0, 17
            require ext_code.size(sub_cd38b90aAddress)
            call sub_cd38b90aAddress.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ((sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600) - ((sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_79ba2fa2[arg1].field_512 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000)
    else:
        if block.timestamp < launchTime:
            revert with 0, 17
        if block.timestamp - launchTime <= sub_be75288d[stor201[arg1].field_0].field_1280:
            if block.timestamp - launchTime and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - launchTime:
                revert with 0, 17
            if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 and sub_79ba2fa2[arg1].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600:
                revert with 0, 17
            sub_79ba2fa2[arg1].field_512 = block.timestamp
            if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 < (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000:
                revert with 0, 17
            require ext_code.size(sub_cd38b90aAddress)
            call sub_cd38b90aAddress.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600) - ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000)
        else:
            if block.timestamp - launchTime < sub_be75288d[stor201[arg1].field_0].field_1280:
                revert with 0, 17
            if block.timestamp - launchTime - sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / block.timestamp - launchTime - sub_be75288d[stor201[arg1].field_0].field_1280:
                revert with 0, 17
            if (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) and sub_be75288d[stor201[arg1].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024):
                revert with 0, 17
            if sub_be75288d[stor201[arg1].field_0].field_1280 and sub_be75288d[stor201[arg1].field_0].field_1024 > -1 / sub_be75288d[stor201[arg1].field_0].field_1280:
                revert with 0, 17
            if sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 > !((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100):
                revert with 0, 17
            if (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 and sub_79ba2fa2[arg1].field_256 > -1 / (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600:
                revert with 0, 17
            sub_79ba2fa2[arg1].field_512 = block.timestamp
            if (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 < (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000:
                revert with 0, 17
            require ext_code.size(sub_cd38b90aAddress)
            call sub_cd38b90aAddress.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ((sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600) - ((sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (launchTime * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) - (sub_be75288d[stor201[arg1].field_0].field_1280 * sub_be75288d[stor201[arg1].field_0].field_1024 * sub_be75288d[stor201[arg1].field_0].field_1536) / 100) / 24 * 3600 * sub_79ba2fa2[arg1].field_256 / 10000)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    stor217 = 1
}

function sub_ab3cc8d8(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor317[address(arg1)].field_0 > test266151307():
        revert with 0, 65
    mem[96] = stor317[address(arg1)].field_0
    if not stor317[address(arg1)].field_0:
        if stor317[address(arg1)].field_0 > test266151307():
            revert with 0, 65
        mem[(32 * stor317[address(arg1)].field_0) + 128] = stor317[address(arg1)].field_0
        if not stor317[address(arg1)].field_0:
            mem[(64 * stor317[address(arg1)].field_0) + 160] = 5
            mem[(64 * stor317[address(arg1)].field_0) + 192] = 0x6964202573000000000000000000000000000000000000000000000000000000
            mem[(64 * stor317[address(arg1)].field_0) + 260] = 64
            mem[(64 * stor317[address(arg1)].field_0) + 324] = 5
            mem[(64 * stor317[address(arg1)].field_0) + 356] = 0x6964202573000000000000000000000000000000000000000000000000000000
            mem[(64 * stor317[address(arg1)].field_0) + 361] = 0
            mem[(64 * stor317[address(arg1)].field_0) + 292] = stor317[address(arg1)].field_0
            mem[(64 * stor317[address(arg1)].field_0) + 224] = (127 * stor317[address(arg1)].field_0) + 132
            mem[(64 * stor317[address(arg1)].field_0) + 260 len 28] = 0
            mem[(64 * stor317[address(arg1)].field_0) + 256 len 4] = 2534451664
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args mem[(64 * stor317[address(arg1)].field_0) + 260 len (127 * stor317[address(arg1)].field_0) + 128]
            if var82002 >= var82001:
                mem[(64 * stor317[address(arg1)].field_0) + 388] = 64
                mem[(64 * stor317[address(arg1)].field_0) + 452] = stor317[address(arg1)].field_0
                mem[(64 * stor317[address(arg1)].field_0) + 484 len 32 * stor317[address(arg1)].field_0] = mem[128 len 32 * stor317[address(arg1)].field_0]
                mem[(64 * stor317[address(arg1)].field_0) + 420] = (32 * stor317[address(arg1)].field_0) + 96
                mem[(98 * stor317[address(arg1)].field_0) + 484] = stor317[address(arg1)].field_0
                mem[(98 * stor317[address(arg1)].field_0) + 516 len 32 * stor317[address(arg1)].field_0] = mem[(32 * stor317[address(arg1)].field_0) + 160 len 32 * stor317[address(arg1)].field_0]
                return memory
                  from (64 * stor317[address(arg1)].field_0) + 388
                   len (194 * stor317[address(arg1)].field_0) + 128
            mem[32] = 317
            if var88001 >= stor[var88002]:
                revert with 0, 50
            mem[0] = var90002
            mem[64] = (64 * stor317[address(arg1)].field_0) + 452
            mem[(64 * stor317[address(arg1)].field_0) + 388] = 12
            mem[(64 * stor317[address(arg1)].field_0) + 420] = 'Next node %s' << 160
            mem[var98001] = 64
            mem[var100002] = mem[var100001]
            if var66001 < var102003:
                mem[var66001 + var102002] = mem[var66001 + var102001]
                var66001 = var66001 + 32
                continue 
            if var66001 > var102003:
                mem[var102003 + var102002] = 0
            mem[var102011 + 32] = var102012
            mem[(64 * stor317[address(arg1)].field_0) + 452] = ceil32(var102005) + var102008 + -(64 * stor317[address(arg1)].field_0) - 452
            mem[(64 * stor317[address(arg1)].field_0) + 484 len 4] = 2534451664
            staticcall 'console.log'.0x9710a9d0 with:
                    gas gas_remaining wei
                   args mem[(64 * stor317[address(arg1)].field_0) + 488 len ceil32(var102005) + var102008 + -(64 * stor317[address(arg1)].field_0) - 456]
            if ownerOf[var102019]:
                if not ownerOf[var102019]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                if ownerOf[var102019] == this.address:
                    if var102021 >= stor317[address(arg1)].field_0:
                        revert with 0, 50
                    mem[(32 * var102021) + 128] = var102019
                    if var102021 >= stor317[address(arg1)].field_0:
                        revert with 0, 50
                    mem[(32 * var102021) + (32 * stor317[address(arg1)].field_0) + 160] = sub_79ba2fa2[var102019].field_512
                    if var102021 == -1:
                        revert with 0, 17
            if var102020 == -1:
                revert with 0, 17
            if var102020 + 1 >= stor317[address(arg1)].field_0:
                mem[ceil32(var102005) + var102008 + 32] = 64
                mem[ceil32(var102005) + var102008 + 96] = stor317[address(arg1)].field_0
                mem[ceil32(var102005) + var102008 + 128 len 32 * stor317[address(arg1)].field_0] = mem[128 len 32 * stor317[address(arg1)].field_0]
                mem[ceil32(var102005) + var102008 + (32 * stor317[address(arg1)].field_0) + 128] = stor317[address(arg1)].field_0
                return Array(len=stor317[address(arg1)].field_0, data=mem[ceil32(var102005) + var102008 + 128 len (64 * stor317[address(arg1)].field_0) + 32]), 
                       (32 * stor317[address(arg1)].field_0) + 96
            mem[32] = 317
            if var102020 + 1 >= stor317[address(arg1)].field_0:
                revert with 0, 50
            mem[0] = sha3(address(arg1), 317)
            mem[64] = ceil32(var102005) + var102008 + 96
            mem[ceil32(var102005) + var102008 + 32] = 12
            mem[ceil32(var102005) + var102008 + 64] = 'Next node %s' << 160
            mem[ceil32(var102005) + var102008 + 132] = 64
            mem[ceil32(var102005) + var102008 + 196] = 12
            var66001 = 0
            continue 
        mem[(32 * stor317[address(arg1)].field_0) + 160 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
        mem[(64 * stor317[address(arg1)].field_0) + 160] = 5
        mem[(64 * stor317[address(arg1)].field_0) + 192] = 0x6964202573000000000000000000000000000000000000000000000000000000
        mem[(64 * stor317[address(arg1)].field_0) + 260] = 64
        mem[(64 * stor317[address(arg1)].field_0) + 324] = 5
        mem[(64 * stor317[address(arg1)].field_0) + 356] = 0x6964202573000000000000000000000000000000000000000000000000000000
        mem[(64 * stor317[address(arg1)].field_0) + 361] = 0
        mem[(64 * stor317[address(arg1)].field_0) + 292] = stor317[address(arg1)].field_0
        mem[(64 * stor317[address(arg1)].field_0) + 224] = (127 * stor317[address(arg1)].field_0) + 132
        mem[(64 * stor317[address(arg1)].field_0) + 260 len 28] = 0
        mem[(64 * stor317[address(arg1)].field_0) + 256 len 4] = 2534451664
        staticcall 'console.log'.0x9710a9d0 with:
                gas gas_remaining wei
               args mem[(64 * stor317[address(arg1)].field_0) + 260 len (127 * stor317[address(arg1)].field_0) + 128]
        if var83002 >= var83001:
            mem[(64 * stor317[address(arg1)].field_0) + 388] = 64
            mem[(64 * stor317[address(arg1)].field_0) + 452] = stor317[address(arg1)].field_0
            mem[(64 * stor317[address(arg1)].field_0) + 484 len 32 * stor317[address(arg1)].field_0] = mem[128 len 32 * stor317[address(arg1)].field_0]
            mem[(64 * stor317[address(arg1)].field_0) + 420] = (32 * stor317[address(arg1)].field_0) + 96
            mem[(98 * stor317[address(arg1)].field_0) + 484] = stor317[address(arg1)].field_0
            mem[(98 * stor317[address(arg1)].field_0) + 516 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
            return memory
              from (64 * stor317[address(arg1)].field_0) + 388
               len (194 * stor317[address(arg1)].field_0) + 128
        mem[32] = 317
        if var89001 >= stor[var89002]:
            revert with 0, 50
        mem[0] = var91002
        mem[64] = (64 * stor317[address(arg1)].field_0) + 452
        mem[(64 * stor317[address(arg1)].field_0) + 388] = 12
        mem[(64 * stor317[address(arg1)].field_0) + 420] = 'Next node %s' << 160
        mem[var99001] = 64
        mem[var101002] = mem[var101001]
        if var67001 < var103003:
            mem[var67001 + var103002] = mem[var67001 + var103001]
            var67001 = var67001 + 32
            continue 
        if var67001 > var103003:
            mem[var103003 + var103002] = 0
        mem[var103011 + 32] = var103012
        mem[(64 * stor317[address(arg1)].field_0) + 452] = ceil32(var103005) + var103008 + -(64 * stor317[address(arg1)].field_0) - 452
        mem[(64 * stor317[address(arg1)].field_0) + 484 len 4] = 2534451664
        staticcall 'console.log'.0x9710a9d0 with:
                gas gas_remaining wei
               args mem[(64 * stor317[address(arg1)].field_0) + 488 len ceil32(var103005) + var103008 + -(64 * stor317[address(arg1)].field_0) - 456]
        if ownerOf[var103019]:
            if not ownerOf[var103019]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[var103019] == this.address:
                if var103021 >= stor317[address(arg1)].field_0:
                    revert with 0, 50
                mem[(32 * var103021) + 128] = var103019
                if var103021 >= stor317[address(arg1)].field_0:
                    revert with 0, 50
                mem[(32 * var103021) + (32 * stor317[address(arg1)].field_0) + 160] = sub_79ba2fa2[var103019].field_512
                if var103021 == -1:
                    revert with 0, 17
        if var103020 == -1:
            revert with 0, 17
        if var103020 + 1 >= stor317[address(arg1)].field_0:
            mem[ceil32(var103005) + var103008 + 32] = 64
            mem[ceil32(var103005) + var103008 + 96] = stor317[address(arg1)].field_0
            mem[ceil32(var103005) + var103008 + 128 len 32 * stor317[address(arg1)].field_0] = mem[128 len 32 * stor317[address(arg1)].field_0]
            mem[ceil32(var103005) + var103008 + (32 * stor317[address(arg1)].field_0) + 128] = stor317[address(arg1)].field_0
            return Array(len=stor317[address(arg1)].field_0, data=mem[ceil32(var103005) + var103008 + 128 len (64 * stor317[address(arg1)].field_0) + 32]), 
                   (32 * stor317[address(arg1)].field_0) + 96
        mem[32] = 317
        if var103020 + 1 >= stor317[address(arg1)].field_0:
            revert with 0, 50
        mem[0] = sha3(address(arg1), 317)
        mem[64] = ceil32(var103005) + var103008 + 96
        mem[ceil32(var103005) + var103008 + 32] = 12
        mem[ceil32(var103005) + var103008 + 64] = 'Next node %s' << 160
        mem[ceil32(var103005) + var103008 + 132] = 64
        mem[ceil32(var103005) + var103008 + 196] = 12
        var67001 = 0
        continue 
    mem[128 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
    if stor317[address(arg1)].field_0 > test266151307():
        revert with 0, 65
    mem[(32 * stor317[address(arg1)].field_0) + 128] = stor317[address(arg1)].field_0
    if not stor317[address(arg1)].field_0:
        mem[(64 * stor317[address(arg1)].field_0) + 160] = 5
        mem[(64 * stor317[address(arg1)].field_0) + 192] = 0x6964202573000000000000000000000000000000000000000000000000000000
        mem[(64 * stor317[address(arg1)].field_0) + 260] = 64
        mem[(64 * stor317[address(arg1)].field_0) + 324] = 5
        mem[(64 * stor317[address(arg1)].field_0) + 356] = 0x6964202573000000000000000000000000000000000000000000000000000000
        mem[(64 * stor317[address(arg1)].field_0) + 361] = 0
        mem[(64 * stor317[address(arg1)].field_0) + 292] = stor317[address(arg1)].field_0
        mem[(64 * stor317[address(arg1)].field_0) + 224] = (127 * stor317[address(arg1)].field_0) + 132
        mem[(64 * stor317[address(arg1)].field_0) + 260 len 28] = 0
        mem[(64 * stor317[address(arg1)].field_0) + 256 len 4] = 2534451664
        staticcall 'console.log'.0x9710a9d0 with:
                gas gas_remaining wei
               args mem[(64 * stor317[address(arg1)].field_0) + 260 len (127 * stor317[address(arg1)].field_0) + 128]
        if var83002 >= var83001:
            mem[(64 * stor317[address(arg1)].field_0) + 388] = 64
            mem[(64 * stor317[address(arg1)].field_0) + 452] = stor317[address(arg1)].field_0
            mem[(64 * stor317[address(arg1)].field_0) + 484 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
            mem[(64 * stor317[address(arg1)].field_0) + 420] = (32 * stor317[address(arg1)].field_0) + 96
            mem[(98 * stor317[address(arg1)].field_0) + 484] = stor317[address(arg1)].field_0
            mem[(98 * stor317[address(arg1)].field_0) + 516 len 32 * stor317[address(arg1)].field_0] = mem[(32 * stor317[address(arg1)].field_0) + 160 len 32 * stor317[address(arg1)].field_0]
            return memory
              from (64 * stor317[address(arg1)].field_0) + 388
               len (194 * stor317[address(arg1)].field_0) + 128
        mem[32] = 317
        if var89001 >= stor[var89002]:
            revert with 0, 50
        mem[0] = var91002
        mem[64] = (64 * stor317[address(arg1)].field_0) + 452
        mem[(64 * stor317[address(arg1)].field_0) + 388] = 12
        mem[(64 * stor317[address(arg1)].field_0) + 420] = 'Next node %s' << 160
        mem[var99001] = 64
        mem[var101002] = mem[var101001]
        if var67001 < var103003:
            mem[var67001 + var103002] = mem[var67001 + var103001]
            var67001 = var67001 + 32
            continue 
        if var67001 > var103003:
            mem[var103003 + var103002] = 0
        mem[var103011 + 32] = var103012
        mem[(64 * stor317[address(arg1)].field_0) + 452] = ceil32(var103005) + var103008 + -(64 * stor317[address(arg1)].field_0) - 452
        mem[(64 * stor317[address(arg1)].field_0) + 484 len 4] = 2534451664
        staticcall 'console.log'.0x9710a9d0 with:
                gas gas_remaining wei
               args mem[(64 * stor317[address(arg1)].field_0) + 488 len ceil32(var103005) + var103008 + -(64 * stor317[address(arg1)].field_0) - 456]
        if ownerOf[var103019]:
            if not ownerOf[var103019]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[var103019] == this.address:
                if var103021 >= stor317[address(arg1)].field_0:
                    revert with 0, 50
                mem[(32 * var103021) + 128] = var103019
                if var103021 >= stor317[address(arg1)].field_0:
                    revert with 0, 50
                mem[(32 * var103021) + (32 * stor317[address(arg1)].field_0) + 160] = sub_79ba2fa2[var103019].field_512
                if var103021 == -1:
                    revert with 0, 17
        if var103020 == -1:
            revert with 0, 17
        if var103020 + 1 >= stor317[address(arg1)].field_0:
            mem[ceil32(var103005) + var103008 + 128 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
            mem[ceil32(var103005) + var103008 + (32 * stor317[address(arg1)].field_0) + 128] = stor317[address(arg1)].field_0
            return Array(len=stor317[address(arg1)].field_0, data=mem[ceil32(var103005) + var103008 + 128 len (64 * stor317[address(arg1)].field_0) + 32]), 
                   (32 * stor317[address(arg1)].field_0) + 96
        mem[32] = 317
        if var103020 + 1 >= stor317[address(arg1)].field_0:
            revert with 0, 50
        mem[0] = sha3(address(arg1), 317)
        mem[64] = ceil32(var103005) + var103008 + 96
        mem[ceil32(var103005) + var103008 + 32] = 12
        mem[ceil32(var103005) + var103008 + 64] = 'Next node %s' << 160
        mem[ceil32(var103005) + var103008 + 132] = 64
        mem[ceil32(var103005) + var103008 + 196] = 12
        var67001 = 0
        continue 
    mem[(32 * stor317[address(arg1)].field_0) + 160 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
    mem[(64 * stor317[address(arg1)].field_0) + 160] = 5
    mem[(64 * stor317[address(arg1)].field_0) + 192] = 0x6964202573000000000000000000000000000000000000000000000000000000
    mem[(64 * stor317[address(arg1)].field_0) + 260] = 64
    mem[(64 * stor317[address(arg1)].field_0) + 324] = 5
    mem[(64 * stor317[address(arg1)].field_0) + 356] = 0x6964202573000000000000000000000000000000000000000000000000000000
    mem[(64 * stor317[address(arg1)].field_0) + 361] = 0
    mem[(64 * stor317[address(arg1)].field_0) + 292] = stor317[address(arg1)].field_0
    mem[(64 * stor317[address(arg1)].field_0) + 224] = (127 * stor317[address(arg1)].field_0) + 132
    mem[(64 * stor317[address(arg1)].field_0) + 260 len 28] = 0
    mem[(64 * stor317[address(arg1)].field_0) + 256 len 4] = 2534451664
    staticcall 'console.log'.0x9710a9d0 with:
            gas gas_remaining wei
           args mem[(64 * stor317[address(arg1)].field_0) + 260 len (127 * stor317[address(arg1)].field_0) + 128]
    if var84002 >= var84001:
        mem[(64 * stor317[address(arg1)].field_0) + 388] = 64
        mem[(64 * stor317[address(arg1)].field_0) + 452] = stor317[address(arg1)].field_0
        mem[(64 * stor317[address(arg1)].field_0) + 484 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
        mem[(64 * stor317[address(arg1)].field_0) + 420] = (32 * stor317[address(arg1)].field_0) + 96
        mem[(98 * stor317[address(arg1)].field_0) + 484] = stor317[address(arg1)].field_0
        mem[(98 * stor317[address(arg1)].field_0) + 516 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
        return memory
          from (64 * stor317[address(arg1)].field_0) + 388
           len (194 * stor317[address(arg1)].field_0) + 128
    mem[32] = 317
    if var90001 >= stor[var90002]:
        revert with 0, 50
    mem[0] = var92002
    mem[64] = (64 * stor317[address(arg1)].field_0) + 452
    mem[(64 * stor317[address(arg1)].field_0) + 388] = 12
    mem[(64 * stor317[address(arg1)].field_0) + 420] = 'Next node %s' << 160
    mem[var100001] = 64
    mem[var102002] = mem[var102001]
    if var68001 < var104003:
        mem[var68001 + var104002] = mem[var68001 + var104001]
        var68001 = var68001 + 32
        continue 
    if var68001 > var104003:
        mem[var104003 + var104002] = 0
    mem[var104011 + 32] = var104012
    mem[(64 * stor317[address(arg1)].field_0) + 452] = ceil32(var104005) + var104008 + -(64 * stor317[address(arg1)].field_0) - 452
    mem[(64 * stor317[address(arg1)].field_0) + 484 len 4] = 2534451664
    staticcall 'console.log'.0x9710a9d0 with:
            gas gas_remaining wei
           args mem[(64 * stor317[address(arg1)].field_0) + 488 len ceil32(var104005) + var104008 + -(64 * stor317[address(arg1)].field_0) - 456]
    if ownerOf[var104019]:
        if not ownerOf[var104019]:
            revert with 0, 'ERC721: owner query for nonexistent token'
        if ownerOf[var104019] == this.address:
            if var104021 >= stor317[address(arg1)].field_0:
                revert with 0, 50
            mem[(32 * var104021) + 128] = var104019
            if var104021 >= stor317[address(arg1)].field_0:
                revert with 0, 50
            mem[(32 * var104021) + (32 * stor317[address(arg1)].field_0) + 160] = sub_79ba2fa2[var104019].field_512
            if var104021 == -1:
                revert with 0, 17
    if var104020 == -1:
        revert with 0, 17
    if var104020 + 1 >= stor317[address(arg1)].field_0:
        mem[ceil32(var104005) + var104008 + 128 len 32 * stor317[address(arg1)].field_0] = call.data[calldata.size len 32 * stor317[address(arg1)].field_0]
        mem[ceil32(var104005) + var104008 + (32 * stor317[address(arg1)].field_0) + 128] = stor317[address(arg1)].field_0
        return Array(len=stor317[address(arg1)].field_0, data=mem[ceil32(var104005) + var104008 + 128 len (64 * stor317[address(arg1)].field_0) + 32]), 
               (32 * stor317[address(arg1)].field_0) + 96
    mem[32] = 317
    if var104020 + 1 >= stor317[address(arg1)].field_0:
        revert with 0, 50
    mem[0] = sha3(address(arg1), 317)
    mem[64] = ceil32(var104005) + var104008 + 96
    mem[ceil32(var104005) + var104008 + 32] = 12
    mem[ceil32(var104005) + var104008 + 64] = 'Next node %s' << 160
    mem[ceil32(var104005) + var104008 + 132] = 64
    mem[ceil32(var104005) + var104008 + 196] = 12
    var68001 = 0
    continue 
}

function sub_58bf8027(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + 97
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    if paused:
        revert with 0, 'Pausable: paused'
    if stor217 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor217 = 2
    if not ('cd', 4).length:
        revert with 0, 'Must claim at least one node'
    if this.address == msg.sender:
        revert with 0, 'Can't claim from the contract'
    if block.timestamp < launchTime:
        revert with 0, 'Not launched yet'
    if not launchTime:
        revert with 0, 'Not launched yet'
    if 24 * 3600 > !launchTime:
        revert with 0, 17
    if block.timestamp <= launchTime + (24 * 3600):
        revert with 0, 'Must wait 24h from launch'
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _115 = sha3(mem[(32 * idx) + 128], 201)
        if sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 >= launchTime:
            if block.timestamp < sub_79ba2fa2[mem[(32 * idx) + 128]].field_512:
                revert with 0, 17
            if block.timestamp - sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 <= sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                _119 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if block.timestamp - sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[mem[(32 * idx) + 128]].field_512:
                    revert with 0, 17
                _126 = sha3(mem[(32 * idx) + 128], 201)
                if (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600 and sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600:
                    revert with 0, 17
                mem[0] = mem[(32 * idx) + 128]
                mem[32] = 201
                sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 = block.timestamp
                if (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600 < (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 / 10000:
                    revert with 0, 17
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = ((block.timestamp * stor4[_119]) - (stor2[_115] * stor4[_119]) / 24 * 3600) - ((block.timestamp * stor4[_119]) - (stor2[_115] * stor4[_119]) / 24 * 3600 * stor1[_126] / 10000)
                require ext_code.size(sub_cd38b90aAddress)
                call sub_cd38b90aAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((block.timestamp * stor4[_119]) - (stor2[_115] * stor4[_119]) / 24 * 3600) - ((block.timestamp * stor4[_119]) - (stor2[_115] * stor4[_119]) / 24 * 3600 * stor1[_126] / 10000)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _136 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_136] == bool(mem[_136])
            else:
                _120 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if block.timestamp - sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 < sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                    revert with 0, 17
                _124 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if block.timestamp - sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 - sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > -1 / block.timestamp - sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 - sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                    revert with 0, 17
                if (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024):
                    revert with 0, 17
                _128 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > -1 / sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                    revert with 0, 17
                if sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > !((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100):
                    revert with 0, 17
                _140 = sha3(mem[(32 * idx) + 128], 201)
                if (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600 and sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 > -1 / (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600:
                    revert with 0, 17
                mem[0] = mem[(32 * idx) + 128]
                mem[32] = 201
                sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 = block.timestamp
                if (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600 < (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600 * sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 / 10000:
                    revert with 0, 17
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = ((stor5[_128] * stor4[_128]) + ((block.timestamp * stor4[_124] * stor6[_124]) - (stor2[_115] * stor4[_124] * stor6[_124]) - (stor5[_120] * stor4[_124] * stor6[_124]) / 100) / 24 * 3600) - ((stor5[_128] * stor4[_128]) + ((block.timestamp * stor4[_124] * stor6[_124]) - (stor2[_115] * stor4[_124] * stor6[_124]) - (stor5[_120] * stor4[_124] * stor6[_124]) / 100) / 24 * 3600 * stor1[_140] / 10000)
                require ext_code.size(sub_cd38b90aAddress)
                call sub_cd38b90aAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((stor5[_128] * stor4[_128]) + ((block.timestamp * stor4[_124] * stor6[_124]) - (stor2[_115] * stor4[_124] * stor6[_124]) - (stor5[_120] * stor4[_124] * stor6[_124]) / 100) / 24 * 3600) - ((stor5[_128] * stor4[_128]) + ((block.timestamp * stor4[_124] * stor6[_124]) - (stor2[_115] * stor4[_124] * stor6[_124]) - (stor5[_120] * stor4[_124] * stor6[_124]) / 100) / 24 * 3600 * stor1[_140] / 10000)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _148 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_148] == bool(mem[_148])
        else:
            if block.timestamp < launchTime:
                revert with 0, 17
            if block.timestamp - launchTime <= sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                _122 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if block.timestamp - launchTime and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > -1 / block.timestamp - launchTime:
                    revert with 0, 17
                _127 = sha3(mem[(32 * idx) + 128], 201)
                if (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600 and sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 > -1 / (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600:
                    revert with 0, 17
                mem[0] = mem[(32 * idx) + 128]
                mem[32] = 201
                sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 = block.timestamp
                if (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600 < (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) / 24 * 3600 * sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 / 10000:
                    revert with 0, 17
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = ((block.timestamp * stor4[_122]) - (launchTime * stor4[_122]) / 24 * 3600) - ((block.timestamp * stor4[_122]) - (launchTime * stor4[_122]) / 24 * 3600 * stor1[_127] / 10000)
                require ext_code.size(sub_cd38b90aAddress)
                call sub_cd38b90aAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((block.timestamp * stor4[_122]) - (launchTime * stor4[_122]) / 24 * 3600) - ((block.timestamp * stor4[_122]) - (launchTime * stor4[_122]) / 24 * 3600 * stor1[_127] / 10000)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _137 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_137] == bool(mem[_137])
            else:
                _123 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if block.timestamp - launchTime < sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                    revert with 0, 17
                _125 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if block.timestamp - launchTime - sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > -1 / block.timestamp - launchTime - sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                    revert with 0, 17
                if (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536 > -1 / (block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024):
                    revert with 0, 17
                _130 = sha3(sub_79ba2fa2[mem[(32 * idx) + 128]].field_0, 204)
                if sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 and sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > -1 / sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280:
                    revert with 0, 17
                if sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 > !((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100):
                    revert with 0, 17
                _141 = sha3(mem[(32 * idx) + 128], 201)
                if (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600 and sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 > -1 / (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600:
                    revert with 0, 17
                mem[0] = mem[(32 * idx) + 128]
                mem[32] = 201
                sub_79ba2fa2[mem[(32 * idx) + 128]].field_512 = block.timestamp
                if (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600 < (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024) + ((block.timestamp * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (launchTime * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) - (sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1280 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1024 * sub_be75288d[stor201[mem[(32 * idx) + 128]].field_0].field_1536) / 100) / 24 * 3600 * sub_79ba2fa2[mem[(32 * idx) + 128]].field_256 / 10000:
                    revert with 0, 17
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = ((stor5[_130] * stor4[_130]) + ((block.timestamp * stor4[_125] * stor6[_125]) - (launchTime * stor4[_125] * stor6[_125]) - (stor5[_123] * stor4[_125] * stor6[_125]) / 100) / 24 * 3600) - ((stor5[_130] * stor4[_130]) + ((block.timestamp * stor4[_125] * stor6[_125]) - (launchTime * stor4[_125] * stor6[_125]) - (stor5[_123] * stor4[_125] * stor6[_125]) / 100) / 24 * 3600 * stor1[_141] / 10000)
                require ext_code.size(sub_cd38b90aAddress)
                call sub_cd38b90aAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((stor5[_130] * stor4[_130]) + ((block.timestamp * stor4[_125] * stor6[_125]) - (launchTime * stor4[_125] * stor6[_125]) - (stor5[_123] * stor4[_125] * stor6[_125]) / 100) / 24 * 3600) - ((stor5[_130] * stor4[_130]) + ((block.timestamp * stor4[_125] * stor6[_125]) - (launchTime * stor4[_125] * stor6[_125]) - (stor5[_123] * stor4[_125] * stor6[_125]) / 100) / 24 * 3600 * stor1[_141] / 10000)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _149 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_149] == bool(mem[_149])
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    stor217 = 1
}

function sub_cf37c49a(?) payable {
    require calldata.size - 4 >= 32
    if bool(sub_be75288d[arg1].field_0):
        if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                            s = 0
                            while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if 31 >= sub_be75288d[arg1].field_1 % 128:
                    mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                                if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                            mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                            if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                                mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    mem[128] = sub_be75288d[arg1].field_0
                    idx = 128
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 96 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                               sub_be75288d[arg1].field_256,
                                               sub_be75288d[arg1].field_512,
                                               sub_be75288d[arg1].field_768,
                                               sub_be75288d[arg1].field_1024,
                                               sub_be75288d[arg1].field_1280,
                                               sub_be75288d[arg1].field_1536,
                                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                               sub_be75288d[arg1].field_256,
                               sub_be75288d[arg1].field_512,
                               sub_be75288d[arg1].field_768,
                               sub_be75288d[arg1].field_1024,
                               sub_be75288d[arg1].field_1280,
                               sub_be75288d[arg1].field_1536,
                               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) > uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) <= uint255(sub_be75288d[arg1].field_0) * 0.5:
                                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                    return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
                                mem[(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        return Array(len=2 * Mask(256, -1, sub_be75288d[arg1].field_0), data=mem[128 len ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5)], sub_be75288d[arg1].field_1792 % 128, mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
               sub_be75288d[arg1].field_256,
               sub_be75288d[arg1].field_512,
               sub_be75288d[arg1].field_768,
               sub_be75288d[arg1].field_1024,
               sub_be75288d[arg1].field_1280,
               sub_be75288d[arg1].field_1536,
               ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 288
    if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
        revert with 0, 34
    if bool(sub_be75288d[arg1].field_0):
        if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                revert with 0, 34
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793 % 128:
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793 % 128:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        else:
            if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                    mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
    else:
        if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if not sub_be75288d[arg1].field_1 % 128:
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                        if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                       sub_be75288d[arg1].field_256,
                       sub_be75288d[arg1].field_512,
                       sub_be75288d[arg1].field_768,
                       sub_be75288d[arg1].field_1024,
                       sub_be75288d[arg1].field_1280,
                       sub_be75288d[arg1].field_1536,
                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                revert with 0, 34
            if bool(sub_be75288d[arg1].field_1792):
                if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if not sub_be75288d[arg1].field_1793 % 128:
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if 31 >= sub_be75288d[arg1].field_1793 % 128:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                    else:
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                        idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                        s = 0
                        while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                            mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                        mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                    if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                        mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
        else:
            if 31 >= sub_be75288d[arg1].field_1 % 128:
                mem[128] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                            mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                            if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                        mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                        if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                            mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
            else:
                mem[128] = sub_be75288d[arg1].field_0
                idx = 128
                s = 0
                while sub_be75288d[arg1].field_1 % 128 + 96 > idx:
                    mem[idx + 32] = sub_be75288d[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                    mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], uint255(sub_be75288d[arg1].field_1792) * 0.5, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                                           sub_be75288d[arg1].field_256,
                                           sub_be75288d[arg1].field_512,
                                           sub_be75288d[arg1].field_768,
                                           sub_be75288d[arg1].field_1024,
                                           sub_be75288d[arg1].field_1280,
                                           sub_be75288d[arg1].field_1536,
                                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = 0
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 448] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]
                    if ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) > uint255(sub_be75288d[arg1].field_1792) * 0.5:
                        mem[(uint255(sub_be75288d[arg1].field_1792) * 0.5) + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 480] = 0
                    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], 2 * Mask(256, -1, sub_be75288d[arg1].field_1792), mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5)]), 
                           sub_be75288d[arg1].field_256,
                           sub_be75288d[arg1].field_512,
                           sub_be75288d[arg1].field_768,
                           sub_be75288d[arg1].field_1024,
                           sub_be75288d[arg1].field_1280,
                           sub_be75288d[arg1].field_1536,
                           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                    revert with 0, 34
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    else:
                        if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    if not sub_be75288d[arg1].field_1793 % 128:
                        if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                    else:
                        if 31 >= sub_be75288d[arg1].field_1793 % 128:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                            if ceil32(sub_be75288d[arg1].field_1 % 128) > sub_be75288d[arg1].field_1 % 128:
                                mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                        else:
                            mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160] = sub_be75288d[arg1][7].field_0
                            idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 160
                            s = 0
                            while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 128 > idx:
                                mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if ceil32(sub_be75288d[arg1].field_1 % 128) <= sub_be75288d[arg1].field_1 % 128:
                                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                                return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1793 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
                                       sub_be75288d[arg1].field_256,
                                       sub_be75288d[arg1].field_512,
                                       sub_be75288d[arg1].field_768,
                                       sub_be75288d[arg1].field_1024,
                                       sub_be75288d[arg1].field_1280,
                                       sub_be75288d[arg1].field_1536,
                                       ceil32(sub_be75288d[arg1].field_1 % 128) + 288
                            mem[sub_be75288d[arg1].field_1 % 128 + ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = 0
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 448] = sub_be75288d[arg1].field_1793 % 128
                mem[(2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480 len ceil32(sub_be75288d[arg1].field_1793 % 128)] = mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]
                if ceil32(sub_be75288d[arg1].field_1793 % 128) > sub_be75288d[arg1].field_1793 % 128:
                    mem[sub_be75288d[arg1].field_1793 % 128 + (2 * ceil32(sub_be75288d[arg1].field_1 % 128)) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 480] = 0
    return Array(len=sub_be75288d[arg1].field_0 % 128, data=mem[128 len ceil32(sub_be75288d[arg1].field_1 % 128)], sub_be75288d[arg1].field_1792 % 128, mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 160 len ceil32(sub_be75288d[arg1].field_1793 % 128)]), 
           sub_be75288d[arg1].field_256,
           sub_be75288d[arg1].field_512,
           sub_be75288d[arg1].field_768,
           sub_be75288d[arg1].field_1024,
           sub_be75288d[arg1].field_1280,
           sub_be75288d[arg1].field_1536,
           ceil32(sub_be75288d[arg1].field_1 % 128) + 288
}

function sub_d871fea2(?) payable {
    require calldata.size - 4 >= 96
    require arg3 == address(arg3)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(sub_be75288d[arg1].field_0):
        if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        mem[352] = uint255(sub_be75288d[arg1].field_0) * 0.5
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18211 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18211] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20547 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20547] = arg1
                                        mem[_20547 + 32] = 1000
                                        mem[_20547 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20547 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18211 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35931 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35931] == Mask(32, 224, mem[_35931])
                                        if Mask(32, 224, mem[_35931]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39499 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39499] = arg1
                                        mem[_39499 + 32] = 1000
                                        mem[_39499 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39499 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21016 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21016] = arg1
                                        mem[_21016 + 32] = 1000
                                        mem[_21016 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21016 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18211 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35933 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35933] == Mask(32, 224, mem[_35933])
                                        if Mask(32, 224, mem[_35933]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39503 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39503] = arg1
                                        mem[_39503 + 32] = 1000
                                        mem[_39503 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39503 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18213 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18213] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20551 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20551] = arg1
                                            mem[_20551 + 32] = 1000
                                            mem[_20551 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20551 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18213 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35935 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35935] == Mask(32, 224, mem[_35935])
                                            if Mask(32, 224, mem[_35935]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39507 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39507] = arg1
                                            mem[_39507 + 32] = 1000
                                            mem[_39507 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39507 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21024 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21024] = arg1
                                            mem[_21024 + 32] = 1000
                                            mem[_21024 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21024 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18213 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35937 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35937] == Mask(32, 224, mem[_35937])
                                            if Mask(32, 224, mem[_35937]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39511 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39511] = arg1
                                            mem[_39511 + 32] = 1000
                                            mem[_39511 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39511 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35599 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35599] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42155 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42155] = arg1
                                            mem[_42155 + 32] = 1000
                                            mem[_42155 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42155 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35599 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50347 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50347] == Mask(32, 224, mem[_50347])
                                            if Mask(32, 224, mem[_50347]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53515 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53515] = arg1
                                            mem[_53515 + 32] = 1000
                                            mem[_53515 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53515 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42432 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42432] = arg1
                                            mem[_42432 + 32] = 1000
                                            mem[_42432 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42432 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35599 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50349 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50349] == Mask(32, 224, mem[_50349])
                                            if Mask(32, 224, mem[_50349]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53519 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53519] = arg1
                                            mem[_53519 + 32] = 1000
                                            mem[_53519 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53519 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18214 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18214] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20552 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20552] = arg1
                                        mem[_20552 + 32] = 1000
                                        mem[_20552 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20552 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18214 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35939 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35939] == Mask(32, 224, mem[_35939])
                                        if Mask(32, 224, mem[_35939]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39515 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39515] = arg1
                                        mem[_39515 + 32] = 1000
                                        mem[_39515 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39515 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21030 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21030] = arg1
                                        mem[_21030 + 32] = 1000
                                        mem[_21030 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21030 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18214 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35941 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35941] == Mask(32, 224, mem[_35941])
                                        if Mask(32, 224, mem[_35941]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39519 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39519] = arg1
                                        mem[_39519 + 32] = 1000
                                        mem[_39519 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39519 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18216 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18216] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20556 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20556] = arg1
                                            mem[_20556 + 32] = 1000
                                            mem[_20556 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20556 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18216 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35943 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35943] == Mask(32, 224, mem[_35943])
                                            if Mask(32, 224, mem[_35943]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39523 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39523] = arg1
                                            mem[_39523 + 32] = 1000
                                            mem[_39523 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39523 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21038 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21038] = arg1
                                            mem[_21038 + 32] = 1000
                                            mem[_21038 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21038 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18216 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35945 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35945] == Mask(32, 224, mem[_35945])
                                            if Mask(32, 224, mem[_35945]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39527 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39527] = arg1
                                            mem[_39527 + 32] = 1000
                                            mem[_39527 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39527 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35608 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35608] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42156 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42156] = arg1
                                            mem[_42156 + 32] = 1000
                                            mem[_42156 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42156 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35608 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50351 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50351] == Mask(32, 224, mem[_50351])
                                            if Mask(32, 224, mem[_50351]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53523 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53523] = arg1
                                            mem[_53523 + 32] = 1000
                                            mem[_53523 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53523 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42438 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42438] = arg1
                                            mem[_42438 + 32] = 1000
                                            mem[_42438 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42438 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35608 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50353 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50353] == Mask(32, 224, mem[_50353])
                                            if Mask(32, 224, mem[_50353]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53527 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53527] = arg1
                                            mem[_53527 + 32] = 1000
                                            mem[_53527 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53527 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18217 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18217] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20557 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20557] = arg1
                                        mem[_20557 + 32] = 1000
                                        mem[_20557 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20557 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18217 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35947 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35947] == Mask(32, 224, mem[_35947])
                                        if Mask(32, 224, mem[_35947]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39531 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39531] = arg1
                                        mem[_39531 + 32] = 1000
                                        mem[_39531 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39531 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21044 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21044] = arg1
                                        mem[_21044 + 32] = 1000
                                        mem[_21044 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21044 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18217 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35949 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35949] == Mask(32, 224, mem[_35949])
                                        if Mask(32, 224, mem[_35949]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39535 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39535] = arg1
                                        mem[_39535 + 32] = 1000
                                        mem[_39535 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39535 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18219 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18219] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20561 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20561] = arg1
                                            mem[_20561 + 32] = 1000
                                            mem[_20561 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20561 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18219 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35951 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35951] == Mask(32, 224, mem[_35951])
                                            if Mask(32, 224, mem[_35951]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39539 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39539] = arg1
                                            mem[_39539 + 32] = 1000
                                            mem[_39539 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39539 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21052 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21052] = arg1
                                            mem[_21052 + 32] = 1000
                                            mem[_21052 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21052 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18219 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35953 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35953] == Mask(32, 224, mem[_35953])
                                            if Mask(32, 224, mem[_35953]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39543 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39543] = arg1
                                            mem[_39543 + 32] = 1000
                                            mem[_39543 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39543 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35617 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35617] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42157 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42157] = arg1
                                            mem[_42157 + 32] = 1000
                                            mem[_42157 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42157 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35617 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50355 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50355] == Mask(32, 224, mem[_50355])
                                            if Mask(32, 224, mem[_50355]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53531 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53531] = arg1
                                            mem[_53531 + 32] = 1000
                                            mem[_53531 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53531 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42444 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42444] = arg1
                                            mem[_42444 + 32] = 1000
                                            mem[_42444 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42444 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35617 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50357 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50357] == Mask(32, 224, mem[_50357])
                                            if Mask(32, 224, mem[_50357]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53535 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53535] = arg1
                                            mem[_53535 + 32] = 1000
                                            mem[_53535 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53535 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18220 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18220] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20562 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20562] = arg1
                                        mem[_20562 + 32] = 1000
                                        mem[_20562 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20562 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18220 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35955 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35955] == Mask(32, 224, mem[_35955])
                                        if Mask(32, 224, mem[_35955]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39547 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39547] = arg1
                                        mem[_39547 + 32] = 1000
                                        mem[_39547 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39547 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21058 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21058] = arg1
                                        mem[_21058 + 32] = 1000
                                        mem[_21058 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21058 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18220 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35957 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35957] == Mask(32, 224, mem[_35957])
                                        if Mask(32, 224, mem[_35957]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39551 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39551] = arg1
                                        mem[_39551 + 32] = 1000
                                        mem[_39551 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39551 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18222 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18222] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20566 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20566] = arg1
                                            mem[_20566 + 32] = 1000
                                            mem[_20566 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20566 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18222 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35959 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35959] == Mask(32, 224, mem[_35959])
                                            if Mask(32, 224, mem[_35959]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39555 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39555] = arg1
                                            mem[_39555 + 32] = 1000
                                            mem[_39555 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39555 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21066 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21066] = arg1
                                            mem[_21066 + 32] = 1000
                                            mem[_21066 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21066 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18222 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35961 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35961] == Mask(32, 224, mem[_35961])
                                            if Mask(32, 224, mem[_35961]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39559 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39559] = arg1
                                            mem[_39559 + 32] = 1000
                                            mem[_39559 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39559 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35626 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35626] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42158 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42158] = arg1
                                            mem[_42158 + 32] = 1000
                                            mem[_42158 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42158 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35626 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50359 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50359] == Mask(32, 224, mem[_50359])
                                            if Mask(32, 224, mem[_50359]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53539 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53539] = arg1
                                            mem[_53539 + 32] = 1000
                                            mem[_53539 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53539 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42450 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42450] = arg1
                                            mem[_42450 + 32] = 1000
                                            mem[_42450 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42450 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35626 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50361 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50361] == Mask(32, 224, mem[_50361])
                                            if Mask(32, 224, mem[_50361]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53543 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53543] = arg1
                                            mem[_53543 + 32] = 1000
                                            mem[_53543 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53543 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18223 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18223] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20576 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20576] = arg1
                                            mem[_20576 + 32] = 1000
                                            mem[_20576 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20576 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18223 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35967 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35967] == Mask(32, 224, mem[_35967])
                                            if Mask(32, 224, mem[_35967]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39567 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39567] = arg1
                                            mem[_39567 + 32] = 1000
                                            mem[_39567 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39567 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21078 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21078] = arg1
                                            mem[_21078 + 32] = 1000
                                            mem[_21078 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21078 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18223 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35969 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35969] == Mask(32, 224, mem[_35969])
                                            if Mask(32, 224, mem[_35969]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39571 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39571] = arg1
                                            mem[_39571 + 32] = 1000
                                            mem[_39571 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39571 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18225 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18225] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20580 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20580] = arg1
                                                mem[_20580 + 32] = 1000
                                                mem[_20580 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20580 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18225 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35971 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35971] == Mask(32, 224, mem[_35971])
                                                if Mask(32, 224, mem[_35971]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39575 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39575] = arg1
                                                mem[_39575 + 32] = 1000
                                                mem[_39575 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39575 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21086 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21086] = arg1
                                                mem[_21086 + 32] = 1000
                                                mem[_21086 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21086 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18225 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35973 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35973] == Mask(32, 224, mem[_35973])
                                                if Mask(32, 224, mem[_35973]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39579 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39579] = arg1
                                                mem[_39579 + 32] = 1000
                                                mem[_39579 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39579 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35647 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35647] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42179 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42179] = arg1
                                                mem[_42179 + 32] = 1000
                                                mem[_42179 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42179 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35647 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50395 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50395] == Mask(32, 224, mem[_50395])
                                                if Mask(32, 224, mem[_50395]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53611 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53611] = arg1
                                                mem[_53611 + 32] = 1000
                                                mem[_53611 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53611 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42512 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42512] = arg1
                                                mem[_42512 + 32] = 1000
                                                mem[_42512 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42512 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35647 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50397 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50397] == Mask(32, 224, mem[_50397])
                                                if Mask(32, 224, mem[_50397]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53615 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53615] = arg1
                                                mem[_53615 + 32] = 1000
                                                mem[_53615 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53615 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18226 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18226] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20581 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20581] = arg1
                                            mem[_20581 + 32] = 1000
                                            mem[_20581 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20581 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18226 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35975 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35975] == Mask(32, 224, mem[_35975])
                                            if Mask(32, 224, mem[_35975]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39583 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39583] = arg1
                                            mem[_39583 + 32] = 1000
                                            mem[_39583 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39583 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21092 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21092] = arg1
                                            mem[_21092 + 32] = 1000
                                            mem[_21092 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21092 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18226 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35977 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35977] == Mask(32, 224, mem[_35977])
                                            if Mask(32, 224, mem[_35977]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39587 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39587] = arg1
                                            mem[_39587 + 32] = 1000
                                            mem[_39587 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39587 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18228 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18228] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20585 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20585] = arg1
                                                mem[_20585 + 32] = 1000
                                                mem[_20585 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20585 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18228 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35979 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35979] == Mask(32, 224, mem[_35979])
                                                if Mask(32, 224, mem[_35979]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39591 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39591] = arg1
                                                mem[_39591 + 32] = 1000
                                                mem[_39591 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39591 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21100 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21100] = arg1
                                                mem[_21100 + 32] = 1000
                                                mem[_21100 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21100 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18228 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35981 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35981] == Mask(32, 224, mem[_35981])
                                                if Mask(32, 224, mem[_35981]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39595 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39595] = arg1
                                                mem[_39595 + 32] = 1000
                                                mem[_39595 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39595 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35656 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35656] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42180 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42180] = arg1
                                                mem[_42180 + 32] = 1000
                                                mem[_42180 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42180 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35656 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50399 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50399] == Mask(32, 224, mem[_50399])
                                                if Mask(32, 224, mem[_50399]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53619 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53619] = arg1
                                                mem[_53619 + 32] = 1000
                                                mem[_53619 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53619 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42518 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42518] = arg1
                                                mem[_42518 + 32] = 1000
                                                mem[_42518 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42518 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35656 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50401 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50401] == Mask(32, 224, mem[_50401])
                                                if Mask(32, 224, mem[_50401]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53623 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53623] = arg1
                                                mem[_53623 + 32] = 1000
                                                mem[_53623 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53623 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18229 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18229] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20586 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20586] = arg1
                                            mem[_20586 + 32] = 1000
                                            mem[_20586 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20586 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18229 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35983 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35983] == Mask(32, 224, mem[_35983])
                                            if Mask(32, 224, mem[_35983]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39599 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39599] = arg1
                                            mem[_39599 + 32] = 1000
                                            mem[_39599 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39599 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21106 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21106] = arg1
                                            mem[_21106 + 32] = 1000
                                            mem[_21106 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21106 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18229 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35985 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35985] == Mask(32, 224, mem[_35985])
                                            if Mask(32, 224, mem[_35985]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39603 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39603] = arg1
                                            mem[_39603 + 32] = 1000
                                            mem[_39603 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39603 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18231 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18231] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20590 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20590] = arg1
                                                mem[_20590 + 32] = 1000
                                                mem[_20590 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20590 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18231 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35987 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35987] == Mask(32, 224, mem[_35987])
                                                if Mask(32, 224, mem[_35987]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39607 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39607] = arg1
                                                mem[_39607 + 32] = 1000
                                                mem[_39607 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39607 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21114 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21114] = arg1
                                                mem[_21114 + 32] = 1000
                                                mem[_21114 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21114 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18231 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35989 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35989] == Mask(32, 224, mem[_35989])
                                                if Mask(32, 224, mem[_35989]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39611 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39611] = arg1
                                                mem[_39611 + 32] = 1000
                                                mem[_39611 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39611 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35665 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35665] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42181 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42181] = arg1
                                                mem[_42181 + 32] = 1000
                                                mem[_42181 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42181 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35665 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50403 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50403] == Mask(32, 224, mem[_50403])
                                                if Mask(32, 224, mem[_50403]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53627 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53627] = arg1
                                                mem[_53627 + 32] = 1000
                                                mem[_53627 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53627 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42524 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42524] = arg1
                                                mem[_42524 + 32] = 1000
                                                mem[_42524 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42524 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35665 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50405 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50405] == Mask(32, 224, mem[_50405])
                                                if Mask(32, 224, mem[_50405]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53631 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53631] = arg1
                                                mem[_53631 + 32] = 1000
                                                mem[_53631 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53631 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18232 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18232] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20591 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20591] = arg1
                                            mem[_20591 + 32] = 1000
                                            mem[_20591 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20591 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18232 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35991 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35991] == Mask(32, 224, mem[_35991])
                                            if Mask(32, 224, mem[_35991]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39615 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39615] = arg1
                                            mem[_39615 + 32] = 1000
                                            mem[_39615 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39615 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21120 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21120] = arg1
                                            mem[_21120 + 32] = 1000
                                            mem[_21120 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21120 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18232 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _35993 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_35993] == Mask(32, 224, mem[_35993])
                                            if Mask(32, 224, mem[_35993]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39619 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39619] = arg1
                                            mem[_39619 + 32] = 1000
                                            mem[_39619 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39619 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18234 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18234] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20595 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20595] = arg1
                                                mem[_20595 + 32] = 1000
                                                mem[_20595 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20595 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18234 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35995 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35995] == Mask(32, 224, mem[_35995])
                                                if Mask(32, 224, mem[_35995]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39623 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39623] = arg1
                                                mem[_39623 + 32] = 1000
                                                mem[_39623 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39623 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21128 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21128] = arg1
                                                mem[_21128 + 32] = 1000
                                                mem[_21128 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21128 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18234 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _35997 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_35997] == Mask(32, 224, mem[_35997])
                                                if Mask(32, 224, mem[_35997]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39627 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39627] = arg1
                                                mem[_39627 + 32] = 1000
                                                mem[_39627 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39627 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35674 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35674] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42182 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42182] = arg1
                                                mem[_42182 + 32] = 1000
                                                mem[_42182 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42182 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35674 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50407 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50407] == Mask(32, 224, mem[_50407])
                                                if Mask(32, 224, mem[_50407]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53635 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53635] = arg1
                                                mem[_53635 + 32] = 1000
                                                mem[_53635 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53635 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42530 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42530] = arg1
                                                mem[_42530 + 32] = 1000
                                                mem[_42530 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42530 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35674 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50409 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50409] == Mask(32, 224, mem[_50409])
                                                if Mask(32, 224, mem[_50409]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53639 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53639] = arg1
                                                mem[_53639 + 32] = 1000
                                                mem[_53639 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53639 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35631 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35631] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42159 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42159] = arg1
                                            mem[_42159 + 32] = 1000
                                            mem[_42159 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42159 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35631 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50363 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50363] == Mask(32, 224, mem[_50363])
                                            if Mask(32, 224, mem[_50363]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53547 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53547] = arg1
                                            mem[_53547 + 32] = 1000
                                            mem[_53547 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53547 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42456 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42456] = arg1
                                            mem[_42456 + 32] = 1000
                                            mem[_42456 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42456 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35631 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50365 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50365] == Mask(32, 224, mem[_50365])
                                            if Mask(32, 224, mem[_50365]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53551 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53551] = arg1
                                            mem[_53551 + 32] = 1000
                                            mem[_53551 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53551 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35633 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35633] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42163 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42163] = arg1
                                                mem[_42163 + 32] = 1000
                                                mem[_42163 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42163 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35633 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50367 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50367] == Mask(32, 224, mem[_50367])
                                                if Mask(32, 224, mem[_50367]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53555 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53555] = arg1
                                                mem[_53555 + 32] = 1000
                                                mem[_53555 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53555 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42464 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42464] = arg1
                                                mem[_42464 + 32] = 1000
                                                mem[_42464 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42464 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35633 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50369 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50369] == Mask(32, 224, mem[_50369])
                                                if Mask(32, 224, mem[_50369]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53559 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53559] = arg1
                                                mem[_53559 + 32] = 1000
                                                mem[_53559 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53559 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50095 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50095] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55499 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55499] = arg1
                                                mem[_55499 + 32] = 1000
                                                mem[_55499 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55499 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50095 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57115 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57115] == Mask(32, 224, mem[_57115])
                                                if Mask(32, 224, mem[_57115]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57883 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57883] = arg1
                                                mem[_57883 + 32] = 1000
                                                mem[_57883 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57883 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55552 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55552] = arg1
                                                mem[_55552 + 32] = 1000
                                                mem[_55552 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55552 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50095 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57117 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57117] == Mask(32, 224, mem[_57117])
                                                if Mask(32, 224, mem[_57117]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57887 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57887] = arg1
                                                mem[_57887 + 32] = 1000
                                                mem[_57887 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57887 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35634 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35634] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42164 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42164] = arg1
                                            mem[_42164 + 32] = 1000
                                            mem[_42164 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42164 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35634 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50371 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50371] == Mask(32, 224, mem[_50371])
                                            if Mask(32, 224, mem[_50371]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53563 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53563] = arg1
                                            mem[_53563 + 32] = 1000
                                            mem[_53563 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53563 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42470 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42470] = arg1
                                            mem[_42470 + 32] = 1000
                                            mem[_42470 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42470 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35634 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50373 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50373] == Mask(32, 224, mem[_50373])
                                            if Mask(32, 224, mem[_50373]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53567 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53567] = arg1
                                            mem[_53567 + 32] = 1000
                                            mem[_53567 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53567 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35636 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35636] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42168 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42168] = arg1
                                                mem[_42168 + 32] = 1000
                                                mem[_42168 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42168 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35636 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50375 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50375] == Mask(32, 224, mem[_50375])
                                                if Mask(32, 224, mem[_50375]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53571 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53571] = arg1
                                                mem[_53571 + 32] = 1000
                                                mem[_53571 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53571 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42478 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42478] = arg1
                                                mem[_42478 + 32] = 1000
                                                mem[_42478 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42478 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35636 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50377 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50377] == Mask(32, 224, mem[_50377])
                                                if Mask(32, 224, mem[_50377]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53575 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53575] = arg1
                                                mem[_53575 + 32] = 1000
                                                mem[_53575 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53575 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50104 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50104] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55500 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55500] = arg1
                                                mem[_55500 + 32] = 1000
                                                mem[_55500 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55500 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50104 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57119 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57119] == Mask(32, 224, mem[_57119])
                                                if Mask(32, 224, mem[_57119]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57891 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57891] = arg1
                                                mem[_57891 + 32] = 1000
                                                mem[_57891 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57891 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55558 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55558] = arg1
                                                mem[_55558 + 32] = 1000
                                                mem[_55558 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55558 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50104 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57121 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57121] == Mask(32, 224, mem[_57121])
                                                if Mask(32, 224, mem[_57121]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57895 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57895] = arg1
                                                mem[_57895 + 32] = 1000
                                                mem[_57895 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57895 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35637 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35637] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42169 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42169] = arg1
                                            mem[_42169 + 32] = 1000
                                            mem[_42169 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42169 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35637 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50379 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50379] == Mask(32, 224, mem[_50379])
                                            if Mask(32, 224, mem[_50379]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53579 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53579] = arg1
                                            mem[_53579 + 32] = 1000
                                            mem[_53579 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53579 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42484 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42484] = arg1
                                            mem[_42484 + 32] = 1000
                                            mem[_42484 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42484 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35637 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50381 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50381] == Mask(32, 224, mem[_50381])
                                            if Mask(32, 224, mem[_50381]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53583 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53583] = arg1
                                            mem[_53583 + 32] = 1000
                                            mem[_53583 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53583 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35639 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35639] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42173 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42173] = arg1
                                                mem[_42173 + 32] = 1000
                                                mem[_42173 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42173 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35639 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50383 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50383] == Mask(32, 224, mem[_50383])
                                                if Mask(32, 224, mem[_50383]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53587 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53587] = arg1
                                                mem[_53587 + 32] = 1000
                                                mem[_53587 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53587 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42492 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42492] = arg1
                                                mem[_42492 + 32] = 1000
                                                mem[_42492 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42492 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35639 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50385 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50385] == Mask(32, 224, mem[_50385])
                                                if Mask(32, 224, mem[_50385]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53591 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53591] = arg1
                                                mem[_53591 + 32] = 1000
                                                mem[_53591 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53591 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50113 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50113] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55501 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55501] = arg1
                                                mem[_55501 + 32] = 1000
                                                mem[_55501 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55501 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50113 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57123 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57123] == Mask(32, 224, mem[_57123])
                                                if Mask(32, 224, mem[_57123]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57899 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57899] = arg1
                                                mem[_57899 + 32] = 1000
                                                mem[_57899 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57899 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55564 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55564] = arg1
                                                mem[_55564 + 32] = 1000
                                                mem[_55564 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55564 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50113 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57125 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57125] == Mask(32, 224, mem[_57125])
                                                if Mask(32, 224, mem[_57125]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57903 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57903] = arg1
                                                mem[_57903 + 32] = 1000
                                                mem[_57903 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57903 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35640 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35640] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42174 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42174] = arg1
                                            mem[_42174 + 32] = 1000
                                            mem[_42174 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42174 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35640 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50387 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50387] == Mask(32, 224, mem[_50387])
                                            if Mask(32, 224, mem[_50387]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53595 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53595] = arg1
                                            mem[_53595 + 32] = 1000
                                            mem[_53595 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53595 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42498 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42498] = arg1
                                            mem[_42498 + 32] = 1000
                                            mem[_42498 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42498 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35640 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50389 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50389] == Mask(32, 224, mem[_50389])
                                            if Mask(32, 224, mem[_50389]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53599 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53599] = arg1
                                            mem[_53599 + 32] = 1000
                                            mem[_53599 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53599 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35642 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35642] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42178 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42178] = arg1
                                                mem[_42178 + 32] = 1000
                                                mem[_42178 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42178 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35642 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50391 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50391] == Mask(32, 224, mem[_50391])
                                                if Mask(32, 224, mem[_50391]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53603 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53603] = arg1
                                                mem[_53603 + 32] = 1000
                                                mem[_53603 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53603 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42506 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42506] = arg1
                                                mem[_42506 + 32] = 1000
                                                mem[_42506 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42506 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35642 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50393 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50393] == Mask(32, 224, mem[_50393])
                                                if Mask(32, 224, mem[_50393]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53607 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53607] = arg1
                                                mem[_53607 + 32] = 1000
                                                mem[_53607 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53607 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50122 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50122] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55502 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55502] = arg1
                                                mem[_55502 + 32] = 1000
                                                mem[_55502 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55502 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50122 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57127 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57127] == Mask(32, 224, mem[_57127])
                                                if Mask(32, 224, mem[_57127]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57907 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57907] = arg1
                                                mem[_57907 + 32] = 1000
                                                mem[_57907 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57907 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55570 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55570] = arg1
                                                mem[_55570 + 32] = 1000
                                                mem[_55570 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55570 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50122 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57129 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57129] == Mask(32, 224, mem[_57129])
                                                if Mask(32, 224, mem[_57129]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57911 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57911] = arg1
                                                mem[_57911 + 32] = 1000
                                                mem[_57911 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57911 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18235 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18235] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20596 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20596] = arg1
                                        mem[_20596 + 32] = 1000
                                        mem[_20596 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20596 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18235 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _35999 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_35999] == Mask(32, 224, mem[_35999])
                                        if Mask(32, 224, mem[_35999]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39631 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39631] = arg1
                                        mem[_39631 + 32] = 1000
                                        mem[_39631 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39631 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21134 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21134] = arg1
                                        mem[_21134 + 32] = 1000
                                        mem[_21134 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21134 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18235 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36001 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36001] == Mask(32, 224, mem[_36001])
                                        if Mask(32, 224, mem[_36001]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39635 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39635] = arg1
                                        mem[_39635 + 32] = 1000
                                        mem[_39635 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39635 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18237 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18237] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20600 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20600] = arg1
                                            mem[_20600 + 32] = 1000
                                            mem[_20600 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20600 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18237 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36003 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36003] == Mask(32, 224, mem[_36003])
                                            if Mask(32, 224, mem[_36003]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39639 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39639] = arg1
                                            mem[_39639 + 32] = 1000
                                            mem[_39639 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39639 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21142 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21142] = arg1
                                            mem[_21142 + 32] = 1000
                                            mem[_21142 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21142 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18237 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36005 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36005] == Mask(32, 224, mem[_36005])
                                            if Mask(32, 224, mem[_36005]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39643 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39643] = arg1
                                            mem[_39643 + 32] = 1000
                                            mem[_39643 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39643 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35683 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35683] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42183 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42183] = arg1
                                            mem[_42183 + 32] = 1000
                                            mem[_42183 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42183 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35683 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50411 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50411] == Mask(32, 224, mem[_50411])
                                            if Mask(32, 224, mem[_50411]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53643 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53643] = arg1
                                            mem[_53643 + 32] = 1000
                                            mem[_53643 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53643 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42536 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42536] = arg1
                                            mem[_42536 + 32] = 1000
                                            mem[_42536 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42536 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35683 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50413 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50413] == Mask(32, 224, mem[_50413])
                                            if Mask(32, 224, mem[_50413]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53647 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53647] = arg1
                                            mem[_53647 + 32] = 1000
                                            mem[_53647 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53647 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18238 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18238] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20601 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20601] = arg1
                                        mem[_20601 + 32] = 1000
                                        mem[_20601 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20601 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18238 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36007 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36007] == Mask(32, 224, mem[_36007])
                                        if Mask(32, 224, mem[_36007]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39647 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39647] = arg1
                                        mem[_39647 + 32] = 1000
                                        mem[_39647 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39647 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21148 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21148] = arg1
                                        mem[_21148 + 32] = 1000
                                        mem[_21148 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21148 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18238 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36009 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36009] == Mask(32, 224, mem[_36009])
                                        if Mask(32, 224, mem[_36009]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39651 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39651] = arg1
                                        mem[_39651 + 32] = 1000
                                        mem[_39651 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39651 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18240 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18240] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20605 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20605] = arg1
                                            mem[_20605 + 32] = 1000
                                            mem[_20605 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20605 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18240 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36011 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36011] == Mask(32, 224, mem[_36011])
                                            if Mask(32, 224, mem[_36011]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39655 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39655] = arg1
                                            mem[_39655 + 32] = 1000
                                            mem[_39655 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39655 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21156 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21156] = arg1
                                            mem[_21156 + 32] = 1000
                                            mem[_21156 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21156 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18240 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36013 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36013] == Mask(32, 224, mem[_36013])
                                            if Mask(32, 224, mem[_36013]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39659 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39659] = arg1
                                            mem[_39659 + 32] = 1000
                                            mem[_39659 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39659 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35692 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35692] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42184 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42184] = arg1
                                            mem[_42184 + 32] = 1000
                                            mem[_42184 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42184 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35692 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50415 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50415] == Mask(32, 224, mem[_50415])
                                            if Mask(32, 224, mem[_50415]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53651 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53651] = arg1
                                            mem[_53651 + 32] = 1000
                                            mem[_53651 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53651 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42542 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42542] = arg1
                                            mem[_42542 + 32] = 1000
                                            mem[_42542 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42542 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35692 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50417 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50417] == Mask(32, 224, mem[_50417])
                                            if Mask(32, 224, mem[_50417]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53655 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53655] = arg1
                                            mem[_53655 + 32] = 1000
                                            mem[_53655 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53655 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18241 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18241] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20606 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20606] = arg1
                                        mem[_20606 + 32] = 1000
                                        mem[_20606 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20606 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18241 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36015 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36015] == Mask(32, 224, mem[_36015])
                                        if Mask(32, 224, mem[_36015]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39663 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39663] = arg1
                                        mem[_39663 + 32] = 1000
                                        mem[_39663 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39663 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21162 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21162] = arg1
                                        mem[_21162 + 32] = 1000
                                        mem[_21162 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21162 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18241 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36017 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36017] == Mask(32, 224, mem[_36017])
                                        if Mask(32, 224, mem[_36017]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39667 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39667] = arg1
                                        mem[_39667 + 32] = 1000
                                        mem[_39667 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39667 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18243 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18243] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20610 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20610] = arg1
                                            mem[_20610 + 32] = 1000
                                            mem[_20610 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20610 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18243 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36019 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36019] == Mask(32, 224, mem[_36019])
                                            if Mask(32, 224, mem[_36019]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39671 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39671] = arg1
                                            mem[_39671 + 32] = 1000
                                            mem[_39671 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39671 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21170 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21170] = arg1
                                            mem[_21170 + 32] = 1000
                                            mem[_21170 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21170 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18243 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36021 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36021] == Mask(32, 224, mem[_36021])
                                            if Mask(32, 224, mem[_36021]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39675 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39675] = arg1
                                            mem[_39675 + 32] = 1000
                                            mem[_39675 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39675 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35701 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35701] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42185 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42185] = arg1
                                            mem[_42185 + 32] = 1000
                                            mem[_42185 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42185 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35701 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50419 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50419] == Mask(32, 224, mem[_50419])
                                            if Mask(32, 224, mem[_50419]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53659 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53659] = arg1
                                            mem[_53659 + 32] = 1000
                                            mem[_53659 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53659 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42548 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42548] = arg1
                                            mem[_42548 + 32] = 1000
                                            mem[_42548 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42548 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35701 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50421 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50421] == Mask(32, 224, mem[_50421])
                                            if Mask(32, 224, mem[_50421]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53663 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53663] = arg1
                                            mem[_53663 + 32] = 1000
                                            mem[_53663 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53663 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18244 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18244] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20611 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20611] = arg1
                                        mem[_20611 + 32] = 1000
                                        mem[_20611 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20611 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18244 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36023 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36023] == Mask(32, 224, mem[_36023])
                                        if Mask(32, 224, mem[_36023]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39679 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39679] = arg1
                                        mem[_39679 + 32] = 1000
                                        mem[_39679 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39679 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21176 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21176] = arg1
                                        mem[_21176 + 32] = 1000
                                        mem[_21176 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21176 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18244 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36025 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36025] == Mask(32, 224, mem[_36025])
                                        if Mask(32, 224, mem[_36025]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39683 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39683] = arg1
                                        mem[_39683 + 32] = 1000
                                        mem[_39683 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39683 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18246 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18246] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20615 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20615] = arg1
                                            mem[_20615 + 32] = 1000
                                            mem[_20615 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20615 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18246 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36027 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36027] == Mask(32, 224, mem[_36027])
                                            if Mask(32, 224, mem[_36027]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39687 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39687] = arg1
                                            mem[_39687 + 32] = 1000
                                            mem[_39687 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39687 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21184 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21184] = arg1
                                            mem[_21184 + 32] = 1000
                                            mem[_21184 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21184 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18246 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36029 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36029] == Mask(32, 224, mem[_36029])
                                            if Mask(32, 224, mem[_36029]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39691 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39691] = arg1
                                            mem[_39691 + 32] = 1000
                                            mem[_39691 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39691 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                s = 0
                                while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35710 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35710] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42186 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42186] = arg1
                                            mem[_42186 + 32] = 1000
                                            mem[_42186 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42186 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35710 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50423 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50423] == Mask(32, 224, mem[_50423])
                                            if Mask(32, 224, mem[_50423]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53667 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53667] = arg1
                                            mem[_53667 + 32] = 1000
                                            mem[_53667 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53667 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42554 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42554] = arg1
                                            mem[_42554 + 32] = 1000
                                            mem[_42554 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42554 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35710 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50425 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50425] == Mask(32, 224, mem[_50425])
                                            if Mask(32, 224, mem[_50425]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53671 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53671] = arg1
                                            mem[_53671 + 32] = 1000
                                            mem[_53671 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53671 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1 % 128:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18247 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18247] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20625 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20625] = arg1
                                            mem[_20625 + 32] = 1000
                                            mem[_20625 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20625 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18247 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36035 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36035] == Mask(32, 224, mem[_36035])
                                            if Mask(32, 224, mem[_36035]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39699 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39699] = arg1
                                            mem[_39699 + 32] = 1000
                                            mem[_39699 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39699 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21196 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21196] = arg1
                                            mem[_21196 + 32] = 1000
                                            mem[_21196 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21196 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18247 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36037 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36037] == Mask(32, 224, mem[_36037])
                                            if Mask(32, 224, mem[_36037]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39703 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39703] = arg1
                                            mem[_39703 + 32] = 1000
                                            mem[_39703 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39703 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18249 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18249] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20629 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20629] = arg1
                                                mem[_20629 + 32] = 1000
                                                mem[_20629 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20629 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18249 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36039 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36039] == Mask(32, 224, mem[_36039])
                                                if Mask(32, 224, mem[_36039]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39707 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39707] = arg1
                                                mem[_39707 + 32] = 1000
                                                mem[_39707 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39707 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21204 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21204] = arg1
                                                mem[_21204 + 32] = 1000
                                                mem[_21204 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21204 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18249 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36041 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36041] == Mask(32, 224, mem[_36041])
                                                if Mask(32, 224, mem[_36041]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39711 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39711] = arg1
                                                mem[_39711 + 32] = 1000
                                                mem[_39711 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39711 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35731 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35731] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42207 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42207] = arg1
                                                mem[_42207 + 32] = 1000
                                                mem[_42207 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42207 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35731 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50459 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50459] == Mask(32, 224, mem[_50459])
                                                if Mask(32, 224, mem[_50459]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53739 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53739] = arg1
                                                mem[_53739 + 32] = 1000
                                                mem[_53739 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53739 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42616 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42616] = arg1
                                                mem[_42616 + 32] = 1000
                                                mem[_42616 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42616 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35731 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50461 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50461] == Mask(32, 224, mem[_50461])
                                                if Mask(32, 224, mem[_50461]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53743 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53743] = arg1
                                                mem[_53743 + 32] = 1000
                                                mem[_53743 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53743 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18250 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18250] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20630 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20630] = arg1
                                            mem[_20630 + 32] = 1000
                                            mem[_20630 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20630 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18250 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36043 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36043] == Mask(32, 224, mem[_36043])
                                            if Mask(32, 224, mem[_36043]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39715 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39715] = arg1
                                            mem[_39715 + 32] = 1000
                                            mem[_39715 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39715 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21210 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21210] = arg1
                                            mem[_21210 + 32] = 1000
                                            mem[_21210 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21210 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18250 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36045 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36045] == Mask(32, 224, mem[_36045])
                                            if Mask(32, 224, mem[_36045]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39719 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39719] = arg1
                                            mem[_39719 + 32] = 1000
                                            mem[_39719 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39719 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18252 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18252] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20634 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20634] = arg1
                                                mem[_20634 + 32] = 1000
                                                mem[_20634 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20634 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18252 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36047 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36047] == Mask(32, 224, mem[_36047])
                                                if Mask(32, 224, mem[_36047]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39723 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39723] = arg1
                                                mem[_39723 + 32] = 1000
                                                mem[_39723 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39723 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21218 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21218] = arg1
                                                mem[_21218 + 32] = 1000
                                                mem[_21218 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21218 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18252 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36049 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36049] == Mask(32, 224, mem[_36049])
                                                if Mask(32, 224, mem[_36049]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39727 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39727] = arg1
                                                mem[_39727 + 32] = 1000
                                                mem[_39727 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39727 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35740 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35740] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42208 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42208] = arg1
                                                mem[_42208 + 32] = 1000
                                                mem[_42208 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42208 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35740 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50463 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50463] == Mask(32, 224, mem[_50463])
                                                if Mask(32, 224, mem[_50463]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53747 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53747] = arg1
                                                mem[_53747 + 32] = 1000
                                                mem[_53747 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53747 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42622 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42622] = arg1
                                                mem[_42622 + 32] = 1000
                                                mem[_42622 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42622 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35740 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50465 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50465] == Mask(32, 224, mem[_50465])
                                                if Mask(32, 224, mem[_50465]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53751 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53751] = arg1
                                                mem[_53751 + 32] = 1000
                                                mem[_53751 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53751 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18253 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18253] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20635 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20635] = arg1
                                            mem[_20635 + 32] = 1000
                                            mem[_20635 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20635 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18253 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36051 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36051] == Mask(32, 224, mem[_36051])
                                            if Mask(32, 224, mem[_36051]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39731 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39731] = arg1
                                            mem[_39731 + 32] = 1000
                                            mem[_39731 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39731 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21224 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21224] = arg1
                                            mem[_21224 + 32] = 1000
                                            mem[_21224 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21224 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18253 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36053 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36053] == Mask(32, 224, mem[_36053])
                                            if Mask(32, 224, mem[_36053]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39735 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39735] = arg1
                                            mem[_39735 + 32] = 1000
                                            mem[_39735 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39735 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18255 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18255] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20639 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20639] = arg1
                                                mem[_20639 + 32] = 1000
                                                mem[_20639 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20639 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18255 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36055 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36055] == Mask(32, 224, mem[_36055])
                                                if Mask(32, 224, mem[_36055]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39739 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39739] = arg1
                                                mem[_39739 + 32] = 1000
                                                mem[_39739 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39739 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21232 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21232] = arg1
                                                mem[_21232 + 32] = 1000
                                                mem[_21232 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21232 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18255 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36057 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36057] == Mask(32, 224, mem[_36057])
                                                if Mask(32, 224, mem[_36057]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39743 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39743] = arg1
                                                mem[_39743 + 32] = 1000
                                                mem[_39743 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39743 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35749 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35749] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42209 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42209] = arg1
                                                mem[_42209 + 32] = 1000
                                                mem[_42209 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42209 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35749 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50467 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50467] == Mask(32, 224, mem[_50467])
                                                if Mask(32, 224, mem[_50467]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53755 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53755] = arg1
                                                mem[_53755 + 32] = 1000
                                                mem[_53755 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53755 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42628 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42628] = arg1
                                                mem[_42628 + 32] = 1000
                                                mem[_42628 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42628 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35749 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50469 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50469] == Mask(32, 224, mem[_50469])
                                                if Mask(32, 224, mem[_50469]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53759 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53759] = arg1
                                                mem[_53759 + 32] = 1000
                                                mem[_53759 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53759 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18256 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18256] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20640 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20640] = arg1
                                            mem[_20640 + 32] = 1000
                                            mem[_20640 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20640 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18256 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36059 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36059] == Mask(32, 224, mem[_36059])
                                            if Mask(32, 224, mem[_36059]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39747 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39747] = arg1
                                            mem[_39747 + 32] = 1000
                                            mem[_39747 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39747 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21238 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21238] = arg1
                                            mem[_21238 + 32] = 1000
                                            mem[_21238 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21238 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18256 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36061 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36061] == Mask(32, 224, mem[_36061])
                                            if Mask(32, 224, mem[_36061]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39751 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39751] = arg1
                                            mem[_39751 + 32] = 1000
                                            mem[_39751 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39751 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18258 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18258] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20644 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20644] = arg1
                                                mem[_20644 + 32] = 1000
                                                mem[_20644 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20644 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18258 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36063 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36063] == Mask(32, 224, mem[_36063])
                                                if Mask(32, 224, mem[_36063]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39755 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39755] = arg1
                                                mem[_39755 + 32] = 1000
                                                mem[_39755 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39755 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21246 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21246] = arg1
                                                mem[_21246 + 32] = 1000
                                                mem[_21246 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21246 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18258 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36065 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36065] == Mask(32, 224, mem[_36065])
                                                if Mask(32, 224, mem[_36065]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39759 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39759] = arg1
                                                mem[_39759 + 32] = 1000
                                                mem[_39759 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39759 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35758 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35758] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42210 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42210] = arg1
                                                mem[_42210 + 32] = 1000
                                                mem[_42210 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42210 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35758 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50471 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50471] == Mask(32, 224, mem[_50471])
                                                if Mask(32, 224, mem[_50471]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53763 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53763] = arg1
                                                mem[_53763 + 32] = 1000
                                                mem[_53763 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53763 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42634 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42634] = arg1
                                                mem[_42634 + 32] = 1000
                                                mem[_42634 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42634 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35758 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50473 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50473] == Mask(32, 224, mem[_50473])
                                                if Mask(32, 224, mem[_50473]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53767 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53767] = arg1
                                                mem[_53767 + 32] = 1000
                                                mem[_53767 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53767 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35715 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35715] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42187 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42187] = arg1
                                            mem[_42187 + 32] = 1000
                                            mem[_42187 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42187 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35715 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50427 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50427] == Mask(32, 224, mem[_50427])
                                            if Mask(32, 224, mem[_50427]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53675 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53675] = arg1
                                            mem[_53675 + 32] = 1000
                                            mem[_53675 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53675 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42560 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42560] = arg1
                                            mem[_42560 + 32] = 1000
                                            mem[_42560 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42560 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35715 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50429 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50429] == Mask(32, 224, mem[_50429])
                                            if Mask(32, 224, mem[_50429]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53679 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53679] = arg1
                                            mem[_53679 + 32] = 1000
                                            mem[_53679 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53679 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35717 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35717] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42191 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42191] = arg1
                                                mem[_42191 + 32] = 1000
                                                mem[_42191 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42191 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35717 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50431 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50431] == Mask(32, 224, mem[_50431])
                                                if Mask(32, 224, mem[_50431]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53683 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53683] = arg1
                                                mem[_53683 + 32] = 1000
                                                mem[_53683 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53683 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42568 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42568] = arg1
                                                mem[_42568 + 32] = 1000
                                                mem[_42568 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42568 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35717 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50433 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50433] == Mask(32, 224, mem[_50433])
                                                if Mask(32, 224, mem[_50433]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53687 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53687] = arg1
                                                mem[_53687 + 32] = 1000
                                                mem[_53687 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53687 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50163 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50163] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55503 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55503] = arg1
                                                mem[_55503 + 32] = 1000
                                                mem[_55503 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55503 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50163 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57131 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57131] == Mask(32, 224, mem[_57131])
                                                if Mask(32, 224, mem[_57131]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57915 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57915] = arg1
                                                mem[_57915 + 32] = 1000
                                                mem[_57915 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57915 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55576 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55576] = arg1
                                                mem[_55576 + 32] = 1000
                                                mem[_55576 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55576 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50163 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57133 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57133] == Mask(32, 224, mem[_57133])
                                                if Mask(32, 224, mem[_57133]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57919 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57919] = arg1
                                                mem[_57919 + 32] = 1000
                                                mem[_57919 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57919 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35718 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35718] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42192 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42192] = arg1
                                            mem[_42192 + 32] = 1000
                                            mem[_42192 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42192 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35718 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50435 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50435] == Mask(32, 224, mem[_50435])
                                            if Mask(32, 224, mem[_50435]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53691 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53691] = arg1
                                            mem[_53691 + 32] = 1000
                                            mem[_53691 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53691 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42574 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42574] = arg1
                                            mem[_42574 + 32] = 1000
                                            mem[_42574 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42574 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35718 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50437 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50437] == Mask(32, 224, mem[_50437])
                                            if Mask(32, 224, mem[_50437]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53695 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53695] = arg1
                                            mem[_53695 + 32] = 1000
                                            mem[_53695 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53695 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35720 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35720] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42196 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42196] = arg1
                                                mem[_42196 + 32] = 1000
                                                mem[_42196 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42196 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35720 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50439 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50439] == Mask(32, 224, mem[_50439])
                                                if Mask(32, 224, mem[_50439]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53699 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53699] = arg1
                                                mem[_53699 + 32] = 1000
                                                mem[_53699 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53699 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42582 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42582] = arg1
                                                mem[_42582 + 32] = 1000
                                                mem[_42582 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42582 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35720 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50441 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50441] == Mask(32, 224, mem[_50441])
                                                if Mask(32, 224, mem[_50441]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53703 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53703] = arg1
                                                mem[_53703 + 32] = 1000
                                                mem[_53703 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53703 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50172 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50172] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55504 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55504] = arg1
                                                mem[_55504 + 32] = 1000
                                                mem[_55504 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55504 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50172 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57135 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57135] == Mask(32, 224, mem[_57135])
                                                if Mask(32, 224, mem[_57135]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57923 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57923] = arg1
                                                mem[_57923 + 32] = 1000
                                                mem[_57923 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57923 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55582 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55582] = arg1
                                                mem[_55582 + 32] = 1000
                                                mem[_55582 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55582 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50172 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57137 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57137] == Mask(32, 224, mem[_57137])
                                                if Mask(32, 224, mem[_57137]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57927 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57927] = arg1
                                                mem[_57927 + 32] = 1000
                                                mem[_57927 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57927 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35721 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35721] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42197 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42197] = arg1
                                            mem[_42197 + 32] = 1000
                                            mem[_42197 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42197 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35721 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50443 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50443] == Mask(32, 224, mem[_50443])
                                            if Mask(32, 224, mem[_50443]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53707 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53707] = arg1
                                            mem[_53707 + 32] = 1000
                                            mem[_53707 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53707 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42588 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42588] = arg1
                                            mem[_42588 + 32] = 1000
                                            mem[_42588 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42588 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35721 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50445 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50445] == Mask(32, 224, mem[_50445])
                                            if Mask(32, 224, mem[_50445]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53711 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53711] = arg1
                                            mem[_53711 + 32] = 1000
                                            mem[_53711 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53711 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35723 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35723] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42201 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42201] = arg1
                                                mem[_42201 + 32] = 1000
                                                mem[_42201 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42201 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35723 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50447 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50447] == Mask(32, 224, mem[_50447])
                                                if Mask(32, 224, mem[_50447]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53715 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53715] = arg1
                                                mem[_53715 + 32] = 1000
                                                mem[_53715 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53715 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42596 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42596] = arg1
                                                mem[_42596 + 32] = 1000
                                                mem[_42596 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42596 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35723 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50449 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50449] == Mask(32, 224, mem[_50449])
                                                if Mask(32, 224, mem[_50449]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53719 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53719] = arg1
                                                mem[_53719 + 32] = 1000
                                                mem[_53719 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53719 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50181 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50181] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55505 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55505] = arg1
                                                mem[_55505 + 32] = 1000
                                                mem[_55505 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55505 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50181 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57139 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57139] == Mask(32, 224, mem[_57139])
                                                if Mask(32, 224, mem[_57139]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57931 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57931] = arg1
                                                mem[_57931 + 32] = 1000
                                                mem[_57931 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57931 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55588 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55588] = arg1
                                                mem[_55588 + 32] = 1000
                                                mem[_55588 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55588 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50181 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57141 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57141] == Mask(32, 224, mem[_57141])
                                                if Mask(32, 224, mem[_57141]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57935 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57935] = arg1
                                                mem[_57935 + 32] = 1000
                                                mem[_57935 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57935 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35724 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35724] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42202 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42202] = arg1
                                            mem[_42202 + 32] = 1000
                                            mem[_42202 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42202 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35724 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50451 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50451] == Mask(32, 224, mem[_50451])
                                            if Mask(32, 224, mem[_50451]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53723 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53723] = arg1
                                            mem[_53723 + 32] = 1000
                                            mem[_53723 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53723 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42602 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42602] = arg1
                                            mem[_42602 + 32] = 1000
                                            mem[_42602 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42602 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35724 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50453 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50453] == Mask(32, 224, mem[_50453])
                                            if Mask(32, 224, mem[_50453]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53727 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53727] = arg1
                                            mem[_53727 + 32] = 1000
                                            mem[_53727 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53727 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35726 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35726] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42206 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42206] = arg1
                                                mem[_42206 + 32] = 1000
                                                mem[_42206 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42206 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35726 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50455 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50455] == Mask(32, 224, mem[_50455])
                                                if Mask(32, 224, mem[_50455]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53731 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53731] = arg1
                                                mem[_53731 + 32] = 1000
                                                mem[_53731 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53731 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42610 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42610] = arg1
                                                mem[_42610 + 32] = 1000
                                                mem[_42610 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42610 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35726 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50457 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50457] == Mask(32, 224, mem[_50457])
                                                if Mask(32, 224, mem[_50457]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53735 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53735] = arg1
                                                mem[_53735 + 32] = 1000
                                                mem[_53735 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53735 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 416
                                    s = 0
                                    while ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(uint255(sub_be75288d[arg1].field_0) * 0.5) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50190 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50190] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55506 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55506] = arg1
                                                mem[_55506 + 32] = 1000
                                                mem[_55506 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55506 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50190 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57143 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57143] == Mask(32, 224, mem[_57143])
                                                if Mask(32, 224, mem[_57143]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57939 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57939] = arg1
                                                mem[_57939 + 32] = 1000
                                                mem[_57939 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57939 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55594 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55594] = arg1
                                                mem[_55594 + 32] = 1000
                                                mem[_55594 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55594 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50190 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57145 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57145] == Mask(32, 224, mem[_57145])
                                                if Mask(32, 224, mem[_57145]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57943 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57943] = arg1
                                                mem[_57943 + 32] = 1000
                                                mem[_57943 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57943 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
    else:
        if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
            revert with 0, 34
        mem[352] = sub_be75288d[arg1].field_1 % 128
        if bool(sub_be75288d[arg1].field_0):
            if bool(sub_be75288d[arg1].field_0) == uint255(sub_be75288d[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, sub_be75288d[arg1].field_0):
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18259 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18259] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20645 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20645] = arg1
                                        mem[_20645 + 32] = 1000
                                        mem[_20645 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20645 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18259 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36067 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36067] == Mask(32, 224, mem[_36067])
                                        if Mask(32, 224, mem[_36067]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39763 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39763] = arg1
                                        mem[_39763 + 32] = 1000
                                        mem[_39763 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39763 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21252 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21252] = arg1
                                        mem[_21252 + 32] = 1000
                                        mem[_21252 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21252 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18259 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36069 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36069] == Mask(32, 224, mem[_36069])
                                        if Mask(32, 224, mem[_36069]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39767 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39767] = arg1
                                        mem[_39767 + 32] = 1000
                                        mem[_39767 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39767 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18261 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18261] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20649 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20649] = arg1
                                            mem[_20649 + 32] = 1000
                                            mem[_20649 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20649 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18261 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36071 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36071] == Mask(32, 224, mem[_36071])
                                            if Mask(32, 224, mem[_36071]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39771 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39771] = arg1
                                            mem[_39771 + 32] = 1000
                                            mem[_39771 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39771 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21260 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21260] = arg1
                                            mem[_21260 + 32] = 1000
                                            mem[_21260 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21260 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18261 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36073 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36073] == Mask(32, 224, mem[_36073])
                                            if Mask(32, 224, mem[_36073]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39775 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39775] = arg1
                                            mem[_39775 + 32] = 1000
                                            mem[_39775 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39775 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35767 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35767] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42211 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42211] = arg1
                                            mem[_42211 + 32] = 1000
                                            mem[_42211 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42211 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35767 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50475 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50475] == Mask(32, 224, mem[_50475])
                                            if Mask(32, 224, mem[_50475]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53771 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53771] = arg1
                                            mem[_53771 + 32] = 1000
                                            mem[_53771 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53771 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42640 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42640] = arg1
                                            mem[_42640 + 32] = 1000
                                            mem[_42640 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42640 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35767 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50477 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50477] == Mask(32, 224, mem[_50477])
                                            if Mask(32, 224, mem[_50477]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53775 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53775] = arg1
                                            mem[_53775 + 32] = 1000
                                            mem[_53775 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53775 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18262 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18262] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20650 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20650] = arg1
                                        mem[_20650 + 32] = 1000
                                        mem[_20650 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20650 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18262 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36075 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36075] == Mask(32, 224, mem[_36075])
                                        if Mask(32, 224, mem[_36075]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39779 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39779] = arg1
                                        mem[_39779 + 32] = 1000
                                        mem[_39779 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39779 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21266 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21266] = arg1
                                        mem[_21266 + 32] = 1000
                                        mem[_21266 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21266 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18262 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36077 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36077] == Mask(32, 224, mem[_36077])
                                        if Mask(32, 224, mem[_36077]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39783 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39783] = arg1
                                        mem[_39783 + 32] = 1000
                                        mem[_39783 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39783 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18264 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18264] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20654 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20654] = arg1
                                            mem[_20654 + 32] = 1000
                                            mem[_20654 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20654 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18264 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36079 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36079] == Mask(32, 224, mem[_36079])
                                            if Mask(32, 224, mem[_36079]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39787 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39787] = arg1
                                            mem[_39787 + 32] = 1000
                                            mem[_39787 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39787 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21274 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21274] = arg1
                                            mem[_21274 + 32] = 1000
                                            mem[_21274 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21274 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18264 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36081 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36081] == Mask(32, 224, mem[_36081])
                                            if Mask(32, 224, mem[_36081]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39791 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39791] = arg1
                                            mem[_39791 + 32] = 1000
                                            mem[_39791 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39791 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35776 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35776] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42212 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42212] = arg1
                                            mem[_42212 + 32] = 1000
                                            mem[_42212 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42212 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35776 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50479 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50479] == Mask(32, 224, mem[_50479])
                                            if Mask(32, 224, mem[_50479]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53779 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53779] = arg1
                                            mem[_53779 + 32] = 1000
                                            mem[_53779 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53779 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42646 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42646] = arg1
                                            mem[_42646 + 32] = 1000
                                            mem[_42646 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42646 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35776 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50481 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50481] == Mask(32, 224, mem[_50481])
                                            if Mask(32, 224, mem[_50481]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53783 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53783] = arg1
                                            mem[_53783 + 32] = 1000
                                            mem[_53783 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53783 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18265 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18265] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20655 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20655] = arg1
                                        mem[_20655 + 32] = 1000
                                        mem[_20655 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20655 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18265 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36083 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36083] == Mask(32, 224, mem[_36083])
                                        if Mask(32, 224, mem[_36083]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39795 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39795] = arg1
                                        mem[_39795 + 32] = 1000
                                        mem[_39795 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39795 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21280 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21280] = arg1
                                        mem[_21280 + 32] = 1000
                                        mem[_21280 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21280 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18265 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36085 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36085] == Mask(32, 224, mem[_36085])
                                        if Mask(32, 224, mem[_36085]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39799 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39799] = arg1
                                        mem[_39799 + 32] = 1000
                                        mem[_39799 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39799 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18267 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18267] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20659 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20659] = arg1
                                            mem[_20659 + 32] = 1000
                                            mem[_20659 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20659 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18267 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36087 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36087] == Mask(32, 224, mem[_36087])
                                            if Mask(32, 224, mem[_36087]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39803 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39803] = arg1
                                            mem[_39803 + 32] = 1000
                                            mem[_39803 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39803 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21288 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21288] = arg1
                                            mem[_21288 + 32] = 1000
                                            mem[_21288 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21288 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18267 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36089 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36089] == Mask(32, 224, mem[_36089])
                                            if Mask(32, 224, mem[_36089]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39807 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39807] = arg1
                                            mem[_39807 + 32] = 1000
                                            mem[_39807 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39807 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35785 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35785] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42213 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42213] = arg1
                                            mem[_42213 + 32] = 1000
                                            mem[_42213 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42213 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35785 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50483 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50483] == Mask(32, 224, mem[_50483])
                                            if Mask(32, 224, mem[_50483]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53787 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53787] = arg1
                                            mem[_53787 + 32] = 1000
                                            mem[_53787 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53787 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42652 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42652] = arg1
                                            mem[_42652 + 32] = 1000
                                            mem[_42652 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42652 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35785 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50485 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50485] == Mask(32, 224, mem[_50485])
                                            if Mask(32, 224, mem[_50485]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53791 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53791] = arg1
                                            mem[_53791 + 32] = 1000
                                            mem[_53791 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53791 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18268 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18268] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20660 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20660] = arg1
                                        mem[_20660 + 32] = 1000
                                        mem[_20660 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20660 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18268 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36091 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36091] == Mask(32, 224, mem[_36091])
                                        if Mask(32, 224, mem[_36091]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39811 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39811] = arg1
                                        mem[_39811 + 32] = 1000
                                        mem[_39811 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39811 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21294 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21294] = arg1
                                        mem[_21294 + 32] = 1000
                                        mem[_21294 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21294 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18268 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36093 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36093] == Mask(32, 224, mem[_36093])
                                        if Mask(32, 224, mem[_36093]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39815 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39815] = arg1
                                        mem[_39815 + 32] = 1000
                                        mem[_39815 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39815 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18270 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18270] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20664 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20664] = arg1
                                            mem[_20664 + 32] = 1000
                                            mem[_20664 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20664 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18270 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36095 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36095] == Mask(32, 224, mem[_36095])
                                            if Mask(32, 224, mem[_36095]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39819 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39819] = arg1
                                            mem[_39819 + 32] = 1000
                                            mem[_39819 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39819 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21302 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21302] = arg1
                                            mem[_21302 + 32] = 1000
                                            mem[_21302 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21302 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18270 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36097 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36097] == Mask(32, 224, mem[_36097])
                                            if Mask(32, 224, mem[_36097]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39823 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39823] = arg1
                                            mem[_39823 + 32] = 1000
                                            mem[_39823 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39823 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35794 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35794] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42214 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42214] = arg1
                                            mem[_42214 + 32] = 1000
                                            mem[_42214 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42214 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35794 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50487 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50487] == Mask(32, 224, mem[_50487])
                                            if Mask(32, 224, mem[_50487]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53795 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53795] = arg1
                                            mem[_53795 + 32] = 1000
                                            mem[_53795 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53795 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42658 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42658] = arg1
                                            mem[_42658 + 32] = 1000
                                            mem[_42658 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42658 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35794 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50489 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50489] == Mask(32, 224, mem[_50489])
                                            if Mask(32, 224, mem[_50489]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53799 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53799] = arg1
                                            mem[_53799 + 32] = 1000
                                            mem[_53799 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53799 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= uint255(sub_be75288d[arg1].field_0) * 0.5:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18271 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18271] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20674 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20674] = arg1
                                            mem[_20674 + 32] = 1000
                                            mem[_20674 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20674 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18271 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36103 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36103] == Mask(32, 224, mem[_36103])
                                            if Mask(32, 224, mem[_36103]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39831 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39831] = arg1
                                            mem[_39831 + 32] = 1000
                                            mem[_39831 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39831 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21314 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21314] = arg1
                                            mem[_21314 + 32] = 1000
                                            mem[_21314 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21314 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18271 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36105 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36105] == Mask(32, 224, mem[_36105])
                                            if Mask(32, 224, mem[_36105]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39835 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39835] = arg1
                                            mem[_39835 + 32] = 1000
                                            mem[_39835 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39835 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18273 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18273] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20678 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20678] = arg1
                                                mem[_20678 + 32] = 1000
                                                mem[_20678 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20678 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18273 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36107 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36107] == Mask(32, 224, mem[_36107])
                                                if Mask(32, 224, mem[_36107]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39839 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39839] = arg1
                                                mem[_39839 + 32] = 1000
                                                mem[_39839 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39839 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21322 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21322] = arg1
                                                mem[_21322 + 32] = 1000
                                                mem[_21322 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21322 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18273 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36109 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36109] == Mask(32, 224, mem[_36109])
                                                if Mask(32, 224, mem[_36109]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39843 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39843] = arg1
                                                mem[_39843 + 32] = 1000
                                                mem[_39843 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39843 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35815 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35815] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42235 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42235] = arg1
                                                mem[_42235 + 32] = 1000
                                                mem[_42235 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42235 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35815 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50523 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50523] == Mask(32, 224, mem[_50523])
                                                if Mask(32, 224, mem[_50523]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53867 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53867] = arg1
                                                mem[_53867 + 32] = 1000
                                                mem[_53867 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53867 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42720 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42720] = arg1
                                                mem[_42720 + 32] = 1000
                                                mem[_42720 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42720 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35815 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50525 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50525] == Mask(32, 224, mem[_50525])
                                                if Mask(32, 224, mem[_50525]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53871 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53871] = arg1
                                                mem[_53871 + 32] = 1000
                                                mem[_53871 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53871 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18274 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18274] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20679 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20679] = arg1
                                            mem[_20679 + 32] = 1000
                                            mem[_20679 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20679 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18274 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36111 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36111] == Mask(32, 224, mem[_36111])
                                            if Mask(32, 224, mem[_36111]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39847 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39847] = arg1
                                            mem[_39847 + 32] = 1000
                                            mem[_39847 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39847 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21328 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21328] = arg1
                                            mem[_21328 + 32] = 1000
                                            mem[_21328 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21328 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18274 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36113 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36113] == Mask(32, 224, mem[_36113])
                                            if Mask(32, 224, mem[_36113]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39851 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39851] = arg1
                                            mem[_39851 + 32] = 1000
                                            mem[_39851 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39851 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18276 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18276] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20683 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20683] = arg1
                                                mem[_20683 + 32] = 1000
                                                mem[_20683 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20683 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18276 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36115 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36115] == Mask(32, 224, mem[_36115])
                                                if Mask(32, 224, mem[_36115]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39855 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39855] = arg1
                                                mem[_39855 + 32] = 1000
                                                mem[_39855 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39855 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21336 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21336] = arg1
                                                mem[_21336 + 32] = 1000
                                                mem[_21336 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21336 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18276 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36117 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36117] == Mask(32, 224, mem[_36117])
                                                if Mask(32, 224, mem[_36117]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39859 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39859] = arg1
                                                mem[_39859 + 32] = 1000
                                                mem[_39859 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39859 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35824 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35824] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42236 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42236] = arg1
                                                mem[_42236 + 32] = 1000
                                                mem[_42236 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42236 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35824 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50527 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50527] == Mask(32, 224, mem[_50527])
                                                if Mask(32, 224, mem[_50527]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53875 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53875] = arg1
                                                mem[_53875 + 32] = 1000
                                                mem[_53875 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53875 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42726 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42726] = arg1
                                                mem[_42726 + 32] = 1000
                                                mem[_42726 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42726 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35824 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50529 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50529] == Mask(32, 224, mem[_50529])
                                                if Mask(32, 224, mem[_50529]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53879 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53879] = arg1
                                                mem[_53879 + 32] = 1000
                                                mem[_53879 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53879 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18277 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18277] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20684 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20684] = arg1
                                            mem[_20684 + 32] = 1000
                                            mem[_20684 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20684 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18277 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36119 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36119] == Mask(32, 224, mem[_36119])
                                            if Mask(32, 224, mem[_36119]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39863 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39863] = arg1
                                            mem[_39863 + 32] = 1000
                                            mem[_39863 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39863 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21342 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21342] = arg1
                                            mem[_21342 + 32] = 1000
                                            mem[_21342 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21342 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18277 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36121 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36121] == Mask(32, 224, mem[_36121])
                                            if Mask(32, 224, mem[_36121]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39867 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39867] = arg1
                                            mem[_39867 + 32] = 1000
                                            mem[_39867 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39867 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18279 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18279] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20688 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20688] = arg1
                                                mem[_20688 + 32] = 1000
                                                mem[_20688 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20688 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18279 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36123 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36123] == Mask(32, 224, mem[_36123])
                                                if Mask(32, 224, mem[_36123]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39871 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39871] = arg1
                                                mem[_39871 + 32] = 1000
                                                mem[_39871 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39871 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21350 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21350] = arg1
                                                mem[_21350 + 32] = 1000
                                                mem[_21350 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21350 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18279 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36125 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36125] == Mask(32, 224, mem[_36125])
                                                if Mask(32, 224, mem[_36125]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39875 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39875] = arg1
                                                mem[_39875 + 32] = 1000
                                                mem[_39875 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39875 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35833 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35833] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42237 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42237] = arg1
                                                mem[_42237 + 32] = 1000
                                                mem[_42237 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42237 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35833 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50531 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50531] == Mask(32, 224, mem[_50531])
                                                if Mask(32, 224, mem[_50531]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53883 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53883] = arg1
                                                mem[_53883 + 32] = 1000
                                                mem[_53883 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53883 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42732 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42732] = arg1
                                                mem[_42732 + 32] = 1000
                                                mem[_42732 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42732 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35833 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50533 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50533] == Mask(32, 224, mem[_50533])
                                                if Mask(32, 224, mem[_50533]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53887 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53887] = arg1
                                                mem[_53887 + 32] = 1000
                                                mem[_53887 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53887 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18280 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18280] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20689 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20689] = arg1
                                            mem[_20689 + 32] = 1000
                                            mem[_20689 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20689 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18280 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36127 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36127] == Mask(32, 224, mem[_36127])
                                            if Mask(32, 224, mem[_36127]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39879 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39879] = arg1
                                            mem[_39879 + 32] = 1000
                                            mem[_39879 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39879 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21356 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21356] = arg1
                                            mem[_21356 + 32] = 1000
                                            mem[_21356 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21356 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18280 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36129 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36129] == Mask(32, 224, mem[_36129])
                                            if Mask(32, 224, mem[_36129]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39883 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39883] = arg1
                                            mem[_39883 + 32] = 1000
                                            mem[_39883 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39883 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18282 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18282] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20693 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20693] = arg1
                                                mem[_20693 + 32] = 1000
                                                mem[_20693 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20693 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18282 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36131 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36131] == Mask(32, 224, mem[_36131])
                                                if Mask(32, 224, mem[_36131]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39887 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39887] = arg1
                                                mem[_39887 + 32] = 1000
                                                mem[_39887 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39887 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21364 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21364] = arg1
                                                mem[_21364 + 32] = 1000
                                                mem[_21364 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21364 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18282 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36133 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36133] == Mask(32, 224, mem[_36133])
                                                if Mask(32, 224, mem[_36133]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39891 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39891] = arg1
                                                mem[_39891 + 32] = 1000
                                                mem[_39891 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39891 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35842 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35842] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42238 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42238] = arg1
                                                mem[_42238 + 32] = 1000
                                                mem[_42238 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42238 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35842 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50535 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50535] == Mask(32, 224, mem[_50535])
                                                if Mask(32, 224, mem[_50535]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53891 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53891] = arg1
                                                mem[_53891 + 32] = 1000
                                                mem[_53891 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53891 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42738 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42738] = arg1
                                                mem[_42738 + 32] = 1000
                                                mem[_42738 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42738 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35842 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50537 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50537] == Mask(32, 224, mem[_50537])
                                                if Mask(32, 224, mem[_50537]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53895 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53895] = arg1
                                                mem[_53895 + 32] = 1000
                                                mem[_53895 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53895 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while (uint255(sub_be75288d[arg1].field_0) * 0.5) + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35799 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35799] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42215 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42215] = arg1
                                            mem[_42215 + 32] = 1000
                                            mem[_42215 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42215 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35799 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50491 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50491] == Mask(32, 224, mem[_50491])
                                            if Mask(32, 224, mem[_50491]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53803 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53803] = arg1
                                            mem[_53803 + 32] = 1000
                                            mem[_53803 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53803 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42664 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42664] = arg1
                                            mem[_42664 + 32] = 1000
                                            mem[_42664 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42664 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35799 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50493 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50493] == Mask(32, 224, mem[_50493])
                                            if Mask(32, 224, mem[_50493]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53807 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53807] = arg1
                                            mem[_53807 + 32] = 1000
                                            mem[_53807 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53807 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35801 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35801] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42219 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42219] = arg1
                                                mem[_42219 + 32] = 1000
                                                mem[_42219 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42219 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35801 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50495 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50495] == Mask(32, 224, mem[_50495])
                                                if Mask(32, 224, mem[_50495]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53811 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53811] = arg1
                                                mem[_53811 + 32] = 1000
                                                mem[_53811 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53811 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42672 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42672] = arg1
                                                mem[_42672 + 32] = 1000
                                                mem[_42672 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42672 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35801 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50497 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50497] == Mask(32, 224, mem[_50497])
                                                if Mask(32, 224, mem[_50497]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53815 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53815] = arg1
                                                mem[_53815 + 32] = 1000
                                                mem[_53815 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53815 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50231 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50231] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55507 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55507] = arg1
                                                mem[_55507 + 32] = 1000
                                                mem[_55507 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55507 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50231 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57147 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57147] == Mask(32, 224, mem[_57147])
                                                if Mask(32, 224, mem[_57147]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57947 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57947] = arg1
                                                mem[_57947 + 32] = 1000
                                                mem[_57947 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57947 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55600 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55600] = arg1
                                                mem[_55600 + 32] = 1000
                                                mem[_55600 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55600 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50231 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57149 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57149] == Mask(32, 224, mem[_57149])
                                                if Mask(32, 224, mem[_57149]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57951 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57951] = arg1
                                                mem[_57951 + 32] = 1000
                                                mem[_57951 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57951 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35802 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35802] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42220 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42220] = arg1
                                            mem[_42220 + 32] = 1000
                                            mem[_42220 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42220 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35802 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50499 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50499] == Mask(32, 224, mem[_50499])
                                            if Mask(32, 224, mem[_50499]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53819 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53819] = arg1
                                            mem[_53819 + 32] = 1000
                                            mem[_53819 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53819 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42678 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42678] = arg1
                                            mem[_42678 + 32] = 1000
                                            mem[_42678 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42678 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35802 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50501 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50501] == Mask(32, 224, mem[_50501])
                                            if Mask(32, 224, mem[_50501]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53823 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53823] = arg1
                                            mem[_53823 + 32] = 1000
                                            mem[_53823 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53823 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35804 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35804] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42224 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42224] = arg1
                                                mem[_42224 + 32] = 1000
                                                mem[_42224 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42224 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35804 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50503 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50503] == Mask(32, 224, mem[_50503])
                                                if Mask(32, 224, mem[_50503]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53827 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53827] = arg1
                                                mem[_53827 + 32] = 1000
                                                mem[_53827 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53827 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42686 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42686] = arg1
                                                mem[_42686 + 32] = 1000
                                                mem[_42686 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42686 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35804 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50505 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50505] == Mask(32, 224, mem[_50505])
                                                if Mask(32, 224, mem[_50505]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53831 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53831] = arg1
                                                mem[_53831 + 32] = 1000
                                                mem[_53831 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53831 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50240 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50240] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55508 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55508] = arg1
                                                mem[_55508 + 32] = 1000
                                                mem[_55508 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55508 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50240 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57151 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57151] == Mask(32, 224, mem[_57151])
                                                if Mask(32, 224, mem[_57151]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57955 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57955] = arg1
                                                mem[_57955 + 32] = 1000
                                                mem[_57955 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57955 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55606 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55606] = arg1
                                                mem[_55606 + 32] = 1000
                                                mem[_55606 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55606 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50240 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57153 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57153] == Mask(32, 224, mem[_57153])
                                                if Mask(32, 224, mem[_57153]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57959 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57959] = arg1
                                                mem[_57959 + 32] = 1000
                                                mem[_57959 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57959 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35805 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35805] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42225 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42225] = arg1
                                            mem[_42225 + 32] = 1000
                                            mem[_42225 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42225 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35805 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50507 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50507] == Mask(32, 224, mem[_50507])
                                            if Mask(32, 224, mem[_50507]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53835 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53835] = arg1
                                            mem[_53835 + 32] = 1000
                                            mem[_53835 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53835 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42692 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42692] = arg1
                                            mem[_42692 + 32] = 1000
                                            mem[_42692 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42692 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35805 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50509 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50509] == Mask(32, 224, mem[_50509])
                                            if Mask(32, 224, mem[_50509]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53839 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53839] = arg1
                                            mem[_53839 + 32] = 1000
                                            mem[_53839 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53839 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35807 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35807] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42229 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42229] = arg1
                                                mem[_42229 + 32] = 1000
                                                mem[_42229 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42229 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35807 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50511 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50511] == Mask(32, 224, mem[_50511])
                                                if Mask(32, 224, mem[_50511]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53843 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53843] = arg1
                                                mem[_53843 + 32] = 1000
                                                mem[_53843 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53843 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42700 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42700] = arg1
                                                mem[_42700 + 32] = 1000
                                                mem[_42700 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42700 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35807 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50513 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50513] == Mask(32, 224, mem[_50513])
                                                if Mask(32, 224, mem[_50513]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53847 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53847] = arg1
                                                mem[_53847 + 32] = 1000
                                                mem[_53847 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53847 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50249 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50249] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55509 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55509] = arg1
                                                mem[_55509 + 32] = 1000
                                                mem[_55509 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55509 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50249 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57155 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57155] == Mask(32, 224, mem[_57155])
                                                if Mask(32, 224, mem[_57155]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57963 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57963] = arg1
                                                mem[_57963 + 32] = 1000
                                                mem[_57963 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57963 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55612 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55612] = arg1
                                                mem[_55612 + 32] = 1000
                                                mem[_55612 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55612 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50249 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57157 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57157] == Mask(32, 224, mem[_57157])
                                                if Mask(32, 224, mem[_57157]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57967 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57967] = arg1
                                                mem[_57967 + 32] = 1000
                                                mem[_57967 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57967 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35808 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35808] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42230 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42230] = arg1
                                            mem[_42230 + 32] = 1000
                                            mem[_42230 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42230 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35808 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50515 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50515] == Mask(32, 224, mem[_50515])
                                            if Mask(32, 224, mem[_50515]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53851 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53851] = arg1
                                            mem[_53851 + 32] = 1000
                                            mem[_53851 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53851 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42706 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42706] = arg1
                                            mem[_42706 + 32] = 1000
                                            mem[_42706 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42706 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35808 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50517 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50517] == Mask(32, 224, mem[_50517])
                                            if Mask(32, 224, mem[_50517]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53855 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53855] = arg1
                                            mem[_53855 + 32] = 1000
                                            mem[_53855 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53855 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35810 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35810] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42234 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42234] = arg1
                                                mem[_42234 + 32] = 1000
                                                mem[_42234 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42234 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35810 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50519 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50519] == Mask(32, 224, mem[_50519])
                                                if Mask(32, 224, mem[_50519]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53859 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53859] = arg1
                                                mem[_53859 + 32] = 1000
                                                mem[_53859 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53859 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42714 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42714] = arg1
                                                mem[_42714 + 32] = 1000
                                                mem[_42714 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42714 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35810 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50521 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50521] == Mask(32, 224, mem[_50521])
                                                if Mask(32, 224, mem[_50521]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53863 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53863] = arg1
                                                mem[_53863 + 32] = 1000
                                                mem[_53863 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53863 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50258 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50258] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55510 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55510] = arg1
                                                mem[_55510 + 32] = 1000
                                                mem[_55510 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55510 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50258 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57159 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57159] == Mask(32, 224, mem[_57159])
                                                if Mask(32, 224, mem[_57159]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57971 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57971] = arg1
                                                mem[_57971 + 32] = 1000
                                                mem[_57971 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57971 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55618 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55618] = arg1
                                                mem[_55618 + 32] = 1000
                                                mem[_55618 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55618 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50258 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57161 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57161] == Mask(32, 224, mem[_57161])
                                                if Mask(32, 224, mem[_57161]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57975 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57975] = arg1
                                                mem[_57975 + 32] = 1000
                                                mem[_57975 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57975 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
        else:
            if bool(sub_be75288d[arg1].field_0) == sub_be75288d[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if not sub_be75288d[arg1].field_1 % 128:
                mem[96] = 352
                mem[128] = sub_be75288d[arg1].field_256
                mem[160] = sub_be75288d[arg1].field_512
                mem[192] = sub_be75288d[arg1].field_768
                mem[224] = sub_be75288d[arg1].field_1024
                mem[256] = sub_be75288d[arg1].field_1280
                mem[288] = sub_be75288d[arg1].field_1536
                if bool(sub_be75288d[arg1].field_1792):
                    if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18283 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18283] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20694 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20694] = arg1
                                        mem[_20694 + 32] = 1000
                                        mem[_20694 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20694 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18283 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36135 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36135] == Mask(32, 224, mem[_36135])
                                        if Mask(32, 224, mem[_36135]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39895 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39895] = arg1
                                        mem[_39895 + 32] = 1000
                                        mem[_39895 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39895 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21370 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21370] = arg1
                                        mem[_21370 + 32] = 1000
                                        mem[_21370 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21370 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18283 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36137 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36137] == Mask(32, 224, mem[_36137])
                                        if Mask(32, 224, mem[_36137]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39899 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39899] = arg1
                                        mem[_39899 + 32] = 1000
                                        mem[_39899 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39899 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18285 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18285] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20698 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20698] = arg1
                                            mem[_20698 + 32] = 1000
                                            mem[_20698 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20698 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18285 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36139 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36139] == Mask(32, 224, mem[_36139])
                                            if Mask(32, 224, mem[_36139]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39903 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39903] = arg1
                                            mem[_39903 + 32] = 1000
                                            mem[_39903 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39903 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21378 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21378] = arg1
                                            mem[_21378 + 32] = 1000
                                            mem[_21378 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21378 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18285 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36141 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36141] == Mask(32, 224, mem[_36141])
                                            if Mask(32, 224, mem[_36141]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39907 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39907] = arg1
                                            mem[_39907 + 32] = 1000
                                            mem[_39907 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39907 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35851 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35851] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42239 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42239] = arg1
                                            mem[_42239 + 32] = 1000
                                            mem[_42239 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42239 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35851 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50539 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50539] == Mask(32, 224, mem[_50539])
                                            if Mask(32, 224, mem[_50539]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53899 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53899] = arg1
                                            mem[_53899 + 32] = 1000
                                            mem[_53899 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53899 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42744 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42744] = arg1
                                            mem[_42744 + 32] = 1000
                                            mem[_42744 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42744 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35851 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50541 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50541] == Mask(32, 224, mem[_50541])
                                            if Mask(32, 224, mem[_50541]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53903 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53903] = arg1
                                            mem[_53903 + 32] = 1000
                                            mem[_53903 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53903 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18286 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18286] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20699 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20699] = arg1
                                        mem[_20699 + 32] = 1000
                                        mem[_20699 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20699 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18286 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36143 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36143] == Mask(32, 224, mem[_36143])
                                        if Mask(32, 224, mem[_36143]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39911 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39911] = arg1
                                        mem[_39911 + 32] = 1000
                                        mem[_39911 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39911 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21384 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21384] = arg1
                                        mem[_21384 + 32] = 1000
                                        mem[_21384 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21384 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18286 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36145 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36145] == Mask(32, 224, mem[_36145])
                                        if Mask(32, 224, mem[_36145]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39915 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39915] = arg1
                                        mem[_39915 + 32] = 1000
                                        mem[_39915 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39915 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18288 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18288] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20703 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20703] = arg1
                                            mem[_20703 + 32] = 1000
                                            mem[_20703 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20703 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18288 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36147 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36147] == Mask(32, 224, mem[_36147])
                                            if Mask(32, 224, mem[_36147]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39919 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39919] = arg1
                                            mem[_39919 + 32] = 1000
                                            mem[_39919 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39919 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21392 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21392] = arg1
                                            mem[_21392 + 32] = 1000
                                            mem[_21392 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21392 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18288 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36149 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36149] == Mask(32, 224, mem[_36149])
                                            if Mask(32, 224, mem[_36149]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39923 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39923] = arg1
                                            mem[_39923 + 32] = 1000
                                            mem[_39923 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39923 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35860 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35860] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42240 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42240] = arg1
                                            mem[_42240 + 32] = 1000
                                            mem[_42240 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42240 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35860 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50543 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50543] == Mask(32, 224, mem[_50543])
                                            if Mask(32, 224, mem[_50543]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53907 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53907] = arg1
                                            mem[_53907 + 32] = 1000
                                            mem[_53907 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53907 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42750 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42750] = arg1
                                            mem[_42750 + 32] = 1000
                                            mem[_42750 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42750 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35860 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50545 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50545] == Mask(32, 224, mem[_50545])
                                            if Mask(32, 224, mem[_50545]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53911 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53911] = arg1
                                            mem[_53911 + 32] = 1000
                                            mem[_53911 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53911 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                else:
                    if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                        revert with 0, 34
                    mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18289 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18289] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20704 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20704] = arg1
                                        mem[_20704 + 32] = 1000
                                        mem[_20704 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20704 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18289 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36151 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36151] == Mask(32, 224, mem[_36151])
                                        if Mask(32, 224, mem[_36151]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39927 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39927] = arg1
                                        mem[_39927 + 32] = 1000
                                        mem[_39927 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39927 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21398 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21398] = arg1
                                        mem[_21398 + 32] = 1000
                                        mem[_21398 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21398 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18289 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36153 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36153] == Mask(32, 224, mem[_36153])
                                        if Mask(32, 224, mem[_36153]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39931 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39931] = arg1
                                        mem[_39931 + 32] = 1000
                                        mem[_39931 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39931 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18291 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18291] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20708 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20708] = arg1
                                            mem[_20708 + 32] = 1000
                                            mem[_20708 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20708 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18291 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36155 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36155] == Mask(32, 224, mem[_36155])
                                            if Mask(32, 224, mem[_36155]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39935 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39935] = arg1
                                            mem[_39935 + 32] = 1000
                                            mem[_39935 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39935 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21406 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21406] = arg1
                                            mem[_21406 + 32] = 1000
                                            mem[_21406 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21406 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18291 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36157 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36157] == Mask(32, 224, mem[_36157])
                                            if Mask(32, 224, mem[_36157]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39939 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39939] = arg1
                                            mem[_39939 + 32] = 1000
                                            mem[_39939 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39939 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35869 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35869] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42241 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42241] = arg1
                                            mem[_42241 + 32] = 1000
                                            mem[_42241 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42241 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35869 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50547 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50547] == Mask(32, 224, mem[_50547])
                                            if Mask(32, 224, mem[_50547]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53915 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53915] = arg1
                                            mem[_53915 + 32] = 1000
                                            mem[_53915 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53915 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42756 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42756] = arg1
                                            mem[_42756 + 32] = 1000
                                            mem[_42756 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42756 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35869 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50549 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50549] == Mask(32, 224, mem[_50549])
                                            if Mask(32, 224, mem[_50549]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53919 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53919] = arg1
                                            mem[_53919 + 32] = 1000
                                            mem[_53919 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53919 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        if not sub_be75288d[arg1].field_1793 % 128:
                            mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                            if arg1 >= 4:
                                revert with 0, 'Invalid tier'
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                revert with 0, 'Too many nodes of this tier'
                            if arg2 <= 0:
                                revert with 0, 'Must create at least one'
                            mem[0] = arg1
                            mem[32] = sha3(address(arg3), 202)
                            if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                revert with 0, 17
                            sub_2b1331a8[address(arg3)][arg1] += arg2
                            idx = 0
                            while idx < arg2:
                                if numMinted > -2:
                                    revert with 0, 17
                                numMinted++
                                _18292 = mem[64]
                                mem[64] = mem[64] + 32
                                mem[_18292] = 0
                                if not address(arg3):
                                    revert with 0, 'ERC721: mint to the zero address'
                                if ownerOf[stor203]:
                                    revert with 0, 'ERC721: token already minted'
                                if address(arg3):
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _20709 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_20709] = arg1
                                        mem[_20709 + 32] = 1000
                                        mem[_20709 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_20709 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18292 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36159 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36159] == Mask(32, 224, mem[_36159])
                                        if Mask(32, 224, mem[_36159]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39943 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39943] = arg1
                                        mem[_39943 + 32] = 1000
                                        mem[_39943 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39943 + 96] = block.timestamp + (720 * 24 * 3600)
                                else:
                                    if sub_11a040ac > -2:
                                        revert with 0, 17
                                    sub_11a040ac++
                                    if balanceOf[address(arg3)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg3)]++
                                    mem[0] = numMinted
                                    mem[32] = 103
                                    ownerOf[stor203] = address(arg3)
                                    emit Transfer(0, address(arg3), numMinted);
                                    mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 0
                                    mem[mem[64] + 36] = address(arg3)
                                    require ext_code.size(sub_18551108Address)
                                    call sub_18551108Address.0x95ff495a with:
                                         gas gas_remaining wei
                                        args 0, address(arg3)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not ext_code.size(address(arg3)):
                                        _21412 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_21412] = arg1
                                        mem[_21412 + 32] = 1000
                                        mem[_21412 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_21412 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = 0
                                        mem[mem[64] + 68] = numMinted
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = 0
                                        s = 0
                                        while s < 0:
                                            mem[s + mem[64] + 164] = mem[s + _18292 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(address(arg3))
                                        call address(arg3).0x150b7a02 with:
                                             gas gas_remaining wei
                                            args msg.sender, 0, numMinted, 128, 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _36161 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_36161] == Mask(32, 224, mem[_36161])
                                        if Mask(32, 224, mem[_36161]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        _39947 = mem[64]
                                        mem[64] = mem[64] + 128
                                        mem[_39947] = arg1
                                        mem[_39947 + 32] = 1000
                                        mem[_39947 + 64] = block.timestamp
                                        if 720 * 24 * 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[_39947 + 96] = block.timestamp + (720 * 24 * 3600)
                                mem[0] = numMinted
                                mem[32] = 201
                                sub_79ba2fa2[stor203].field_0 = arg1
                                sub_79ba2fa2[stor203].field_256 = 1000
                                sub_79ba2fa2[stor203].field_512 = block.timestamp
                                sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18294 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18294] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20713 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20713] = arg1
                                            mem[_20713 + 32] = 1000
                                            mem[_20713 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20713 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18294 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36163 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36163] == Mask(32, 224, mem[_36163])
                                            if Mask(32, 224, mem[_36163]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39951 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39951] = arg1
                                            mem[_39951 + 32] = 1000
                                            mem[_39951 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39951 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21420 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21420] = arg1
                                            mem[_21420 + 32] = 1000
                                            mem[_21420 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21420 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18294 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36165 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36165] == Mask(32, 224, mem[_36165])
                                            if Mask(32, 224, mem[_36165]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39955 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39955] = arg1
                                            mem[_39955 + 32] = 1000
                                            mem[_39955 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39955 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                s = 0
                                while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                    mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35878 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35878] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42242 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42242] = arg1
                                            mem[_42242 + 32] = 1000
                                            mem[_42242 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42242 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35878 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50551 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50551] == Mask(32, 224, mem[_50551])
                                            if Mask(32, 224, mem[_50551]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53923 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53923] = arg1
                                            mem[_53923 + 32] = 1000
                                            mem[_53923 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53923 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42762 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42762] = arg1
                                            mem[_42762 + 32] = 1000
                                            mem[_42762 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42762 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35878 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50553 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50553] == Mask(32, 224, mem[_50553])
                                            if Mask(32, 224, mem[_50553]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53927 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53927] = arg1
                                            mem[_53927 + 32] = 1000
                                            mem[_53927 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53927 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
            else:
                if 31 >= sub_be75288d[arg1].field_1 % 128:
                    mem[384] = 256 * Mask(248, 0, sub_be75288d[arg1].field_8)
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18295 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18295] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20723 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20723] = arg1
                                            mem[_20723 + 32] = 1000
                                            mem[_20723 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20723 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18295 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36171 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36171] == Mask(32, 224, mem[_36171])
                                            if Mask(32, 224, mem[_36171]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39963 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39963] = arg1
                                            mem[_39963 + 32] = 1000
                                            mem[_39963 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39963 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21432 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21432] = arg1
                                            mem[_21432 + 32] = 1000
                                            mem[_21432 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21432 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18295 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36173 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36173] == Mask(32, 224, mem[_36173])
                                            if Mask(32, 224, mem[_36173]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39967 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39967] = arg1
                                            mem[_39967 + 32] = 1000
                                            mem[_39967 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39967 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18297 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18297] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20727 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20727] = arg1
                                                mem[_20727 + 32] = 1000
                                                mem[_20727 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20727 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18297 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36175 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36175] == Mask(32, 224, mem[_36175])
                                                if Mask(32, 224, mem[_36175]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39971 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39971] = arg1
                                                mem[_39971 + 32] = 1000
                                                mem[_39971 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39971 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21440 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21440] = arg1
                                                mem[_21440 + 32] = 1000
                                                mem[_21440 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21440 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18297 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36177 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36177] == Mask(32, 224, mem[_36177])
                                                if Mask(32, 224, mem[_36177]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39975 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39975] = arg1
                                                mem[_39975 + 32] = 1000
                                                mem[_39975 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39975 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35899 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35899] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42263 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42263] = arg1
                                                mem[_42263 + 32] = 1000
                                                mem[_42263 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42263 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35899 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50587 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50587] == Mask(32, 224, mem[_50587])
                                                if Mask(32, 224, mem[_50587]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53995 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53995] = arg1
                                                mem[_53995 + 32] = 1000
                                                mem[_53995 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53995 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42824 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42824] = arg1
                                                mem[_42824 + 32] = 1000
                                                mem[_42824 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42824 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35899 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50589 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50589] == Mask(32, 224, mem[_50589])
                                                if Mask(32, 224, mem[_50589]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53999 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53999] = arg1
                                                mem[_53999 + 32] = 1000
                                                mem[_53999 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53999 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18298 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18298] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20728 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20728] = arg1
                                            mem[_20728 + 32] = 1000
                                            mem[_20728 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20728 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18298 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36179 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36179] == Mask(32, 224, mem[_36179])
                                            if Mask(32, 224, mem[_36179]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39979 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39979] = arg1
                                            mem[_39979 + 32] = 1000
                                            mem[_39979 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39979 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21446 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21446] = arg1
                                            mem[_21446 + 32] = 1000
                                            mem[_21446 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21446 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18298 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36181 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36181] == Mask(32, 224, mem[_36181])
                                            if Mask(32, 224, mem[_36181]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39983 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39983] = arg1
                                            mem[_39983 + 32] = 1000
                                            mem[_39983 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39983 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18300 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18300] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20732 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20732] = arg1
                                                mem[_20732 + 32] = 1000
                                                mem[_20732 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20732 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18300 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36183 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36183] == Mask(32, 224, mem[_36183])
                                                if Mask(32, 224, mem[_36183]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39987 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39987] = arg1
                                                mem[_39987 + 32] = 1000
                                                mem[_39987 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39987 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21454 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21454] = arg1
                                                mem[_21454 + 32] = 1000
                                                mem[_21454 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21454 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18300 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36185 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36185] == Mask(32, 224, mem[_36185])
                                                if Mask(32, 224, mem[_36185]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _39991 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_39991] = arg1
                                                mem[_39991 + 32] = 1000
                                                mem[_39991 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_39991 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35908 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35908] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42264 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42264] = arg1
                                                mem[_42264 + 32] = 1000
                                                mem[_42264 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42264 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35908 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50591 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50591] == Mask(32, 224, mem[_50591])
                                                if Mask(32, 224, mem[_50591]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _54003 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_54003] = arg1
                                                mem[_54003 + 32] = 1000
                                                mem[_54003 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_54003 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42830 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42830] = arg1
                                                mem[_42830 + 32] = 1000
                                                mem[_42830 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42830 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35908 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50593 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50593] == Mask(32, 224, mem[_50593])
                                                if Mask(32, 224, mem[_50593]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _54007 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_54007] = arg1
                                                mem[_54007 + 32] = 1000
                                                mem[_54007 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_54007 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18301 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18301] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20733 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20733] = arg1
                                            mem[_20733 + 32] = 1000
                                            mem[_20733 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20733 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18301 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36187 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36187] == Mask(32, 224, mem[_36187])
                                            if Mask(32, 224, mem[_36187]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39995 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39995] = arg1
                                            mem[_39995 + 32] = 1000
                                            mem[_39995 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39995 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21460 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21460] = arg1
                                            mem[_21460 + 32] = 1000
                                            mem[_21460 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21460 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18301 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36189 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36189] == Mask(32, 224, mem[_36189])
                                            if Mask(32, 224, mem[_36189]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _39999 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_39999] = arg1
                                            mem[_39999 + 32] = 1000
                                            mem[_39999 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_39999 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18303 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18303] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20737 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20737] = arg1
                                                mem[_20737 + 32] = 1000
                                                mem[_20737 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20737 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18303 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36191 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36191] == Mask(32, 224, mem[_36191])
                                                if Mask(32, 224, mem[_36191]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _40003 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_40003] = arg1
                                                mem[_40003 + 32] = 1000
                                                mem[_40003 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_40003 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21468 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21468] = arg1
                                                mem[_21468 + 32] = 1000
                                                mem[_21468 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21468 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18303 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36193 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36193] == Mask(32, 224, mem[_36193])
                                                if Mask(32, 224, mem[_36193]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _40007 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_40007] = arg1
                                                mem[_40007 + 32] = 1000
                                                mem[_40007 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_40007 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35917 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35917] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42265 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42265] = arg1
                                                mem[_42265 + 32] = 1000
                                                mem[_42265 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42265 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35917 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50595 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50595] == Mask(32, 224, mem[_50595])
                                                if Mask(32, 224, mem[_50595]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _54011 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_54011] = arg1
                                                mem[_54011 + 32] = 1000
                                                mem[_54011 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_54011 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42836 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42836] = arg1
                                                mem[_42836 + 32] = 1000
                                                mem[_42836 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42836 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35917 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50597 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50597] == Mask(32, 224, mem[_50597])
                                                if Mask(32, 224, mem[_50597]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _54015 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_54015] = arg1
                                                mem[_54015 + 32] = 1000
                                                mem[_54015 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_54015 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _18304 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_18304] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _20738 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_20738] = arg1
                                            mem[_20738 + 32] = 1000
                                            mem[_20738 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_20738 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18304 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36195 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36195] == Mask(32, 224, mem[_36195])
                                            if Mask(32, 224, mem[_36195]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _40011 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_40011] = arg1
                                            mem[_40011 + 32] = 1000
                                            mem[_40011 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_40011 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _21474 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_21474] = arg1
                                            mem[_21474 + 32] = 1000
                                            mem[_21474 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_21474 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _18304 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _36197 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_36197] == Mask(32, 224, mem[_36197])
                                            if Mask(32, 224, mem[_36197]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _40015 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_40015] = arg1
                                            mem[_40015 + 32] = 1000
                                            mem[_40015 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_40015 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _18306 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_18306] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _20742 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_20742] = arg1
                                                mem[_20742 + 32] = 1000
                                                mem[_20742 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_20742 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18306 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36199 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36199] == Mask(32, 224, mem[_36199])
                                                if Mask(32, 224, mem[_36199]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _40019 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_40019] = arg1
                                                mem[_40019 + 32] = 1000
                                                mem[_40019 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_40019 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _21482 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_21482] = arg1
                                                mem[_21482 + 32] = 1000
                                                mem[_21482 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_21482 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _18306 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _36201 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_36201] == Mask(32, 224, mem[_36201])
                                                if Mask(32, 224, mem[_36201]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _40023 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_40023] = arg1
                                                mem[_40023 + 32] = 1000
                                                mem[_40023 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_40023 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35926 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35926] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42266 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42266] = arg1
                                                mem[_42266 + 32] = 1000
                                                mem[_42266 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42266 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35926 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50599 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50599] == Mask(32, 224, mem[_50599])
                                                if Mask(32, 224, mem[_50599]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _54019 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_54019] = arg1
                                                mem[_54019 + 32] = 1000
                                                mem[_54019 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_54019 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42842 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42842] = arg1
                                                mem[_42842 + 32] = 1000
                                                mem[_42842 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42842 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35926 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50601 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50601] == Mask(32, 224, mem[_50601])
                                                if Mask(32, 224, mem[_50601]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _54023 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_54023] = arg1
                                                mem[_54023 + 32] = 1000
                                                mem[_54023 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_54023 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                else:
                    mem[384] = sub_be75288d[arg1].field_0
                    idx = 384
                    s = 0
                    while sub_be75288d[arg1].field_1 % 128 + 352 > idx:
                        mem[idx + 32] = sub_be75288d[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    mem[96] = 352
                    mem[128] = sub_be75288d[arg1].field_256
                    mem[160] = sub_be75288d[arg1].field_512
                    mem[192] = sub_be75288d[arg1].field_768
                    mem[224] = sub_be75288d[arg1].field_1024
                    mem[256] = sub_be75288d[arg1].field_1280
                    mem[288] = sub_be75288d[arg1].field_1536
                    if bool(sub_be75288d[arg1].field_1792):
                        if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(uint255(sub_be75288d[arg1].field_1792) * 0.5) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = uint255(sub_be75288d[arg1].field_1792) * 0.5
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35883 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35883] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42243 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42243] = arg1
                                            mem[_42243 + 32] = 1000
                                            mem[_42243 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42243 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35883 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50555 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50555] == Mask(32, 224, mem[_50555])
                                            if Mask(32, 224, mem[_50555]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53931 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53931] = arg1
                                            mem[_53931 + 32] = 1000
                                            mem[_53931 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53931 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42768 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42768] = arg1
                                            mem[_42768 + 32] = 1000
                                            mem[_42768 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42768 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35883 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50557 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50557] == Mask(32, 224, mem[_50557])
                                            if Mask(32, 224, mem[_50557]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53935 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53935] = arg1
                                            mem[_53935 + 32] = 1000
                                            mem[_53935 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53935 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35885 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35885] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42247 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42247] = arg1
                                                mem[_42247 + 32] = 1000
                                                mem[_42247 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42247 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35885 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50559 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50559] == Mask(32, 224, mem[_50559])
                                                if Mask(32, 224, mem[_50559]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53939 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53939] = arg1
                                                mem[_53939 + 32] = 1000
                                                mem[_53939 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53939 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42776 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42776] = arg1
                                                mem[_42776 + 32] = 1000
                                                mem[_42776 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42776 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35885 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50561 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50561] == Mask(32, 224, mem[_50561])
                                                if Mask(32, 224, mem[_50561]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53943 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53943] = arg1
                                                mem[_53943 + 32] = 1000
                                                mem[_53943 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53943 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50299 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50299] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55511 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55511] = arg1
                                                mem[_55511 + 32] = 1000
                                                mem[_55511 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55511 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50299 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57163 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57163] == Mask(32, 224, mem[_57163])
                                                if Mask(32, 224, mem[_57163]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57979 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57979] = arg1
                                                mem[_57979 + 32] = 1000
                                                mem[_57979 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57979 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55624 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55624] = arg1
                                                mem[_55624 + 32] = 1000
                                                mem[_55624 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55624 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50299 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57165 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57165] == Mask(32, 224, mem[_57165])
                                                if Mask(32, 224, mem[_57165]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57983 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57983] = arg1
                                                mem[_57983 + 32] = 1000
                                                mem[_57983 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57983 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35886 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35886] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42248 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42248] = arg1
                                            mem[_42248 + 32] = 1000
                                            mem[_42248 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42248 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35886 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50563 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50563] == Mask(32, 224, mem[_50563])
                                            if Mask(32, 224, mem[_50563]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53947 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53947] = arg1
                                            mem[_53947 + 32] = 1000
                                            mem[_53947 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53947 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42782 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42782] = arg1
                                            mem[_42782 + 32] = 1000
                                            mem[_42782 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42782 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35886 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50565 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50565] == Mask(32, 224, mem[_50565])
                                            if Mask(32, 224, mem[_50565]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53951 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53951] = arg1
                                            mem[_53951 + 32] = 1000
                                            mem[_53951 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53951 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35888 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35888] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42252 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42252] = arg1
                                                mem[_42252 + 32] = 1000
                                                mem[_42252 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42252 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35888 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50567 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50567] == Mask(32, 224, mem[_50567])
                                                if Mask(32, 224, mem[_50567]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53955 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53955] = arg1
                                                mem[_53955 + 32] = 1000
                                                mem[_53955 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53955 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42790 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42790] = arg1
                                                mem[_42790 + 32] = 1000
                                                mem[_42790 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42790 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35888 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50569 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50569] == Mask(32, 224, mem[_50569])
                                                if Mask(32, 224, mem[_50569]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53959 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53959] = arg1
                                                mem[_53959 + 32] = 1000
                                                mem[_53959 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53959 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50308 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50308] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55512 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55512] = arg1
                                                mem[_55512 + 32] = 1000
                                                mem[_55512 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55512 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50308 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57167 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57167] == Mask(32, 224, mem[_57167])
                                                if Mask(32, 224, mem[_57167]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57987 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57987] = arg1
                                                mem[_57987 + 32] = 1000
                                                mem[_57987 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57987 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55630 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55630] = arg1
                                                mem[_55630 + 32] = 1000
                                                mem[_55630 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55630 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50308 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57169 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57169] == Mask(32, 224, mem[_57169])
                                                if Mask(32, 224, mem[_57169]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57991 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57991] = arg1
                                                mem[_57991 + 32] = 1000
                                                mem[_57991 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57991 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                    else:
                        if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                            revert with 0, 34
                        mem[64] = ceil32(sub_be75288d[arg1].field_1 % 128) + ceil32(sub_be75288d[arg1].field_1793 % 128) + 416
                        mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 384] = sub_be75288d[arg1].field_1793 % 128
                        if bool(sub_be75288d[arg1].field_1792):
                            if bool(sub_be75288d[arg1].field_1792) == uint255(sub_be75288d[arg1].field_1792) * 0.5 < 32:
                                revert with 0, 34
                            if not Mask(256, -1, sub_be75288d[arg1].field_1792):
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35889 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35889] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42253 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42253] = arg1
                                            mem[_42253 + 32] = 1000
                                            mem[_42253 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42253 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35889 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50571 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50571] == Mask(32, 224, mem[_50571])
                                            if Mask(32, 224, mem[_50571]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53963 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53963] = arg1
                                            mem[_53963 + 32] = 1000
                                            mem[_53963 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53963 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42796 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42796] = arg1
                                            mem[_42796 + 32] = 1000
                                            mem[_42796 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42796 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35889 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50573 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50573] == Mask(32, 224, mem[_50573])
                                            if Mask(32, 224, mem[_50573]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53967 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53967] = arg1
                                            mem[_53967 + 32] = 1000
                                            mem[_53967 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53967 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= uint255(sub_be75288d[arg1].field_1792) * 0.5:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35891 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35891] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42257 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42257] = arg1
                                                mem[_42257 + 32] = 1000
                                                mem[_42257 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42257 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35891 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50575 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50575] == Mask(32, 224, mem[_50575])
                                                if Mask(32, 224, mem[_50575]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53971 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53971] = arg1
                                                mem[_53971 + 32] = 1000
                                                mem[_53971 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53971 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42804 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42804] = arg1
                                                mem[_42804 + 32] = 1000
                                                mem[_42804 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42804 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35891 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50577 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50577] == Mask(32, 224, mem[_50577])
                                                if Mask(32, 224, mem[_50577]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53975 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53975] = arg1
                                                mem[_53975 + 32] = 1000
                                                mem[_53975 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53975 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + (uint255(sub_be75288d[arg1].field_1792) * 0.5) + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50317 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50317] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55513 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55513] = arg1
                                                mem[_55513 + 32] = 1000
                                                mem[_55513 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55513 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50317 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57171 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57171] == Mask(32, 224, mem[_57171])
                                                if Mask(32, 224, mem[_57171]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57995 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57995] = arg1
                                                mem[_57995 + 32] = 1000
                                                mem[_57995 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57995 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55636 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55636] = arg1
                                                mem[_55636 + 32] = 1000
                                                mem[_55636 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55636 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50317 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57173 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57173] == Mask(32, 224, mem[_57173])
                                                if Mask(32, 224, mem[_57173]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _57999 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_57999] = arg1
                                                mem[_57999 + 32] = 1000
                                                mem[_57999 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_57999 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if bool(sub_be75288d[arg1].field_1792) == sub_be75288d[arg1].field_1793 % 128 < 32:
                                revert with 0, 34
                            if not sub_be75288d[arg1].field_1793 % 128:
                                mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                if arg1 >= 4:
                                    revert with 0, 'Invalid tier'
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                    revert with 0, 'Too many nodes of this tier'
                                if arg2 <= 0:
                                    revert with 0, 'Must create at least one'
                                mem[0] = arg1
                                mem[32] = sha3(address(arg3), 202)
                                if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                    revert with 0, 17
                                sub_2b1331a8[address(arg3)][arg1] += arg2
                                idx = 0
                                while idx < arg2:
                                    if numMinted > -2:
                                        revert with 0, 17
                                    numMinted++
                                    _35892 = mem[64]
                                    mem[64] = mem[64] + 32
                                    mem[_35892] = 0
                                    if not address(arg3):
                                        revert with 0, 'ERC721: mint to the zero address'
                                    if ownerOf[stor203]:
                                        revert with 0, 'ERC721: token already minted'
                                    if address(arg3):
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42258 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42258] = arg1
                                            mem[_42258 + 32] = 1000
                                            mem[_42258 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42258 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35892 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50579 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50579] == Mask(32, 224, mem[_50579])
                                            if Mask(32, 224, mem[_50579]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53979 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53979] = arg1
                                            mem[_53979 + 32] = 1000
                                            mem[_53979 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53979 + 96] = block.timestamp + (720 * 24 * 3600)
                                    else:
                                        if sub_11a040ac > -2:
                                            revert with 0, 17
                                        sub_11a040ac++
                                        if balanceOf[address(arg3)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg3)]++
                                        mem[0] = numMinted
                                        mem[32] = 103
                                        ownerOf[stor203] = address(arg3)
                                        emit Transfer(0, address(arg3), numMinted);
                                        mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 0
                                        mem[mem[64] + 36] = address(arg3)
                                        require ext_code.size(sub_18551108Address)
                                        call sub_18551108Address.0x95ff495a with:
                                             gas gas_remaining wei
                                            args 0, address(arg3)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not ext_code.size(address(arg3)):
                                            _42810 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_42810] = arg1
                                            mem[_42810 + 32] = 1000
                                            mem[_42810 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_42810 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = 0
                                            mem[mem[64] + 68] = numMinted
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = 0
                                            s = 0
                                            while s < 0:
                                                mem[s + mem[64] + 164] = mem[s + _35892 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(address(arg3))
                                            call address(arg3).0x150b7a02 with:
                                                 gas gas_remaining wei
                                                args msg.sender, 0, numMinted, 128, 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _50581 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_50581] == Mask(32, 224, mem[_50581])
                                            if Mask(32, 224, mem[_50581]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            _53983 = mem[64]
                                            mem[64] = mem[64] + 128
                                            mem[_53983] = arg1
                                            mem[_53983 + 32] = 1000
                                            mem[_53983 + 64] = block.timestamp
                                            if 720 * 24 * 3600 > !block.timestamp:
                                                revert with 0, 17
                                            mem[_53983 + 96] = block.timestamp + (720 * 24 * 3600)
                                    mem[0] = numMinted
                                    mem[32] = 201
                                    sub_79ba2fa2[stor203].field_0 = arg1
                                    sub_79ba2fa2[stor203].field_256 = 1000
                                    sub_79ba2fa2[stor203].field_512 = block.timestamp
                                    sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                if 31 >= sub_be75288d[arg1].field_1793 % 128:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = 256 * Mask(248, 0, sub_be75288d[arg1].field_1800)
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _35894 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_35894] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42262 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42262] = arg1
                                                mem[_42262 + 32] = 1000
                                                mem[_42262 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42262 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35894 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50583 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50583] == Mask(32, 224, mem[_50583])
                                                if Mask(32, 224, mem[_50583]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53987 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53987] = arg1
                                                mem[_53987 + 32] = 1000
                                                mem[_53987 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53987 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _42818 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_42818] = arg1
                                                mem[_42818 + 32] = 1000
                                                mem[_42818 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_42818 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _35894 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _50585 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_50585] == Mask(32, 224, mem[_50585])
                                                if Mask(32, 224, mem[_50585]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _53991 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_53991] = arg1
                                                mem[_53991 + 32] = 1000
                                                mem[_53991 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_53991 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    mem[ceil32(sub_be75288d[arg1].field_1 % 128) + 416] = sub_be75288d[arg1][7].field_0
                                    idx = ceil32(sub_be75288d[arg1].field_1 % 128) + 416
                                    s = 0
                                    while ceil32(sub_be75288d[arg1].field_1 % 128) + sub_be75288d[arg1].field_1793 % 128 + 384 > idx:
                                        mem[idx + 32] = sub_be75288d[arg1][s + 7].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    mem[320] = ceil32(sub_be75288d[arg1].field_1 % 128) + 384
                                    if arg1 >= 4:
                                        revert with 0, 'Invalid tier'
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    if sub_2b1331a8[address(arg3)][arg1] + arg2 > sub_be75288d[arg1].field_256:
                                        revert with 0, 'Too many nodes of this tier'
                                    if arg2 <= 0:
                                        revert with 0, 'Must create at least one'
                                    mem[0] = arg1
                                    mem[32] = sha3(address(arg3), 202)
                                    if sub_2b1331a8[address(arg3)][arg1] > !arg2:
                                        revert with 0, 17
                                    sub_2b1331a8[address(arg3)][arg1] += arg2
                                    idx = 0
                                    while idx < arg2:
                                        if numMinted > -2:
                                            revert with 0, 17
                                        numMinted++
                                        _50326 = mem[64]
                                        mem[64] = mem[64] + 32
                                        mem[_50326] = 0
                                        if not address(arg3):
                                            revert with 0, 'ERC721: mint to the zero address'
                                        if ownerOf[stor203]:
                                            revert with 0, 'ERC721: token already minted'
                                        if address(arg3):
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55514 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55514] = arg1
                                                mem[_55514 + 32] = 1000
                                                mem[_55514 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55514 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50326 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57175 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57175] == Mask(32, 224, mem[_57175])
                                                if Mask(32, 224, mem[_57175]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _58003 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_58003] = arg1
                                                mem[_58003 + 32] = 1000
                                                mem[_58003 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_58003 + 96] = block.timestamp + (720 * 24 * 3600)
                                        else:
                                            if sub_11a040ac > -2:
                                                revert with 0, 17
                                            sub_11a040ac++
                                            if balanceOf[address(arg3)] > -2:
                                                revert with 0, 17
                                            balanceOf[address(arg3)]++
                                            mem[0] = numMinted
                                            mem[32] = 103
                                            ownerOf[stor203] = address(arg3)
                                            emit Transfer(0, address(arg3), numMinted);
                                            mem[mem[64]] = 0x95ff495a00000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 0
                                            mem[mem[64] + 36] = address(arg3)
                                            require ext_code.size(sub_18551108Address)
                                            call sub_18551108Address.0x95ff495a with:
                                                 gas gas_remaining wei
                                                args 0, address(arg3)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if not ext_code.size(address(arg3)):
                                                _55642 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_55642] = arg1
                                                mem[_55642 + 32] = 1000
                                                mem[_55642 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_55642 + 96] = block.timestamp + (720 * 24 * 3600)
                                            else:
                                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = msg.sender
                                                mem[mem[64] + 36] = 0
                                                mem[mem[64] + 68] = numMinted
                                                mem[mem[64] + 100] = 128
                                                mem[mem[64] + 132] = 0
                                                s = 0
                                                while s < 0:
                                                    mem[s + mem[64] + 164] = mem[s + _50326 + 32]
                                                    s = s + 32
                                                    continue 
                                                require ext_code.size(address(arg3))
                                                call address(arg3).0x150b7a02 with:
                                                     gas gas_remaining wei
                                                    args msg.sender, 0, numMinted, 128, 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _57177 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_57177] == Mask(32, 224, mem[_57177])
                                                if Mask(32, 224, mem[_57177]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                _58007 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_58007] = arg1
                                                mem[_58007 + 32] = 1000
                                                mem[_58007 + 64] = block.timestamp
                                                if 720 * 24 * 3600 > !block.timestamp:
                                                    revert with 0, 17
                                                mem[_58007 + 96] = block.timestamp + (720 * 24 * 3600)
                                        mem[0] = numMinted
                                        mem[32] = 201
                                        sub_79ba2fa2[stor203].field_0 = arg1
                                        sub_79ba2fa2[stor203].field_256 = 1000
                                        sub_79ba2fa2[stor203].field_512 = block.timestamp
                                        sub_79ba2fa2[stor203].field_768 = block.timestamp + (720 * 24 * 3600)
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1, uint256 arg2)
#  - emergencyWithdraw(uint256 arg1)
#
const version = 3


uint8 stor0;
uint8 stor0; offset 8
uint16 stor0;
array of uint256 stor1;
array of uint256 stor2;
address owner;
uint128 stor52; offset 160
address ownerCandidate;
mapping of uint256 stor99;
uint256 stor101;
uint8 stor151;
address sub_6af66772Address;
address sub_82c780a1Address;
address sub_01126816Address;
uint256 sub_9702d3e2;
uint256 sub_05ed1de4;
uint256 sub_f87bbc56;
uint256 sub_33e045fc;
uint256 startTimestamp;
array of struct poolInfo;
array of struct stor210;
mapping of uint256 stor211;
mapping of struct userInfo;
mapping of uint256 sub_8b4d83a3;
uint256 sub_91ea1d68;
uint256 sub_7b62a738;
array of address stor47661935505114017385622961611032274432992609817870001481508015138701782973667;
array of uint256 stor47661935505114017385622961611032274432992609817870001481508015138701782973668;
array of uint256 stor47661935505114017385622961611032274432992609817870001481508015138701782973669;
array of uint256 stor47661935505114017385622961611032274432992609817870001481508015138701782973670;
array of address stor47661935505114017385622961611032274432992609817870001481508015138701782973671;
array of uint256 stor47661935505114017385622961611032274432992609817870001481508015138701782973672;
array of uint256 stor47661935505114017385622961611032274432992609817870001481508015138701782973673;
array of uint256 stor47661935505114017385622961611032274432992609817870001481508015138701782973674;

function sub_01126816(?) payable {
    return sub_01126816Address
}

function sub_05ed1de4(?) payable {
    return sub_05ed1de4
}

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return address(poolInfo[arg1].field_0), 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           address(poolInfo[arg1].field_1024),
           poolInfo[arg1].field_1280,
           poolInfo[arg1].field_1536,
           poolInfo[arg1].field_1792
}

function sub_33e045fc(?) payable {
    return sub_33e045fc
}

function paused() payable {
    return bool(stor151)
}

function ownerCandidate() payable {
    return ownerCandidate
}

function sub_6af66772(?) payable {
    return sub_6af66772Address
}

function sub_7b62a738(?) payable {
    return sub_7b62a738
}

function sub_82c780a1(?) payable {
    return sub_82c780a1Address
}

function sub_8b4d83a3(?) payable {
    require calldata.size - 4 >= 64
    require arg2 == address(arg2)
    return sub_8b4d83a3[arg1][arg2]
}

function owner() payable {
    return owner
}

function sub_91ea1d68(?) payable {
    return sub_91ea1d68
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256, userInfo[arg1][arg2].field_512
}

function sub_9702d3e2(?) payable {
    return sub_9702d3e2
}

function startTimestamp() payable {
    return startTimestamp
}

function sub_f87bbc56(?) payable {
    return sub_f87bbc56
}

function _fallback() payable {
    revert
}

function acceptOwnership() payable {
    if ownerCandidate != msg.sender:
        revert with 0, 'Unauthorized'
    owner = msg.sender
    emit OwnershipTransferred(owner, msg.sender);
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function pause() payable {
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if stor151:
        revert with 0, 'Pausable: paused'
    stor151 = 1
    emit Paused(msg.sender);
}

function sub_53c5eb44(?) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    require arg1 >= poolInfo.length
    sub_7b62a738 = arg1
}

function unpause() payable {
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if not stor151:
        revert with 0, 'Pausable: not paused'
    stor151 = 0
    emit Unpaused(msg.sender);
}

function sub_7b261591(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    sub_01126816Address = address(arg1)
}

function proposeOwner(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if not arg1:
        revert with 0, 'ZeroAddress'
    ownerCandidate = arg1
    stor52 = 0
}

function sub_2b685580(?) payable {
    require calldata.size - 4 >= 32
    if arg1 >= poolInfo.length:
        revert with 0, 50
    require ext_code.size(address(poolInfo[arg1].field_0))
    staticcall address(poolInfo[arg1].field_0).0x705727b5 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        return 833333333333333333
    require ext_code.size(address(poolInfo[arg1].field_0))
    staticcall address(poolInfo[arg1].field_0).0x961be391 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
        revert with 0, 17
    if not ext_call.return_data[0]:
        revert with 0, 18
    if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
        return 1
    if 1000000000000000000 * 10^18 > !(10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2):
        revert with 0, 17
    if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
        revert with 0, 18
    if 2 * 10^17 > !((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]):
        revert with 0, 17
    if 1000000000000000000 * 10^18 > !(((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2):
        revert with 0, 17
    if not ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17:
        revert with 0, 18
    return ((((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17)
}

function sub_7dd38dcc(?) payable {
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    mem[100] = this.address
    require ext_code.size(sub_6af66772Address)
    staticcall sub_6af66772Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[ceil32(return_data.size) + 132] = msg.sender
    mem[ceil32(return_data.size) + 164] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
    mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
    mem[ceil32(return_data.size) + 196] = 32
    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
    if not ext_code.size(sub_6af66772Address):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0
    mem[ceil32(return_data.size) + 328] = 0
    call sub_6af66772Address with:
       funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
            if not uint32(this.address), mem[132 len 28]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
            if not mem[ceil32(return_data.size) + 292]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function rewarderBonusTokenInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= poolInfo.length:
        revert with 0, 50
    mem[0] = 209
    if not address(poolInfo[arg1].field_1024):
        return 0, 64, 0
    require ext_code.size(address(poolInfo[arg1].field_1024))
    staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(poolInfo[arg1].field_1024))
    staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(2 * ceil32(return_data.size)) + 96] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _18 = mem[(2 * ceil32(return_data.size)) + 96]
    require mem[(2 * ceil32(return_data.size)) + 96] <= test266151307()
    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 96] + 127 < (2 * ceil32(return_data.size)) + return_data.size + 96
    _19 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 96] + 96]
    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 96] + 96] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 96] + 96])) + 1 < 0 or (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 96] + 96])) + 97 > test266151307():
        revert with 0, 65
    mem[64] = (4 * ceil32(return_data.size)) + ceil32(ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 96] + 96])) + 97
    mem[(4 * ceil32(return_data.size)) + 96] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 96] + 96]
    require _18 + _19 + 32 <= return_data.size
    mem[(4 * ceil32(return_data.size)) + 128 len ceil32(_19)] = mem[(2 * ceil32(return_data.size)) + _18 + 128 len ceil32(_19)]
    if ceil32(_19) > _19:
        mem[_19 + (4 * ceil32(return_data.size)) + 128] = 0
    mem[mem[64]] = address(ext_call.return_data[0])
    mem[mem[64] + 32] = 64
    mem[mem[64] + 64] = _19
    mem[mem[64] + 96 len ceil32(_19)] = mem[(4 * ceil32(return_data.size)) + 128 len ceil32(_19)]
    if ceil32(_19) > _19:
        mem[_19 + mem[64] + 96] = 0
    return address(ext_call.return_data[0]), Array(len=_19, data=mem[mem[64] + 96 len ceil32(_19)])
}

function initialize(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5) payable {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    if not uint8(stor0.field_8):
        if uint8(stor0.field_0):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
        if not uint8(stor0.field_8):
            uint16(stor0.field_0) = 257
    if not arg1:
        revert with 0, 'ptp address cannot be zero'
    if not arg2:
        revert with 0, 'vePtp address cannot be zero'
    if not arg3:
        revert with 0, 'ptp per sec cannot be zero'
    if arg4 > 1000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'dialuting repartition must be in range 0, 1000'
    if uint8(stor0.field_8):
        owner = msg.sender
        emit OwnershipTransferred(owner, msg.sender);
        stor101 = 1
        stor151 = 0
    else:
        if uint8(stor0.field_0):
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
        if uint8(stor0.field_8):
            owner = msg.sender
            emit OwnershipTransferred(owner, msg.sender);
            stor101 = 1
            stor151 = 0
        else:
            uint16(stor0.field_0) = 257
            if uint8(stor0.field_0):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
            if uint8(stor0.field_8):
                owner = msg.sender
                emit OwnershipTransferred(owner, msg.sender);
                stor101 = 1
                stor151 = 0
            else:
                uint16(stor0.field_0) = 257
                uint8(stor0.field_8) = 0
                if uint8(stor0.field_0):
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
                if uint8(stor0.field_8):
                    owner = msg.sender
                    emit OwnershipTransferred(owner, msg.sender);
                    stor101 = 1
                    stor151 = 0
                else:
                    uint16(stor0.field_0) = 257
                    owner = msg.sender
                    emit OwnershipTransferred(owner, msg.sender);
                    uint8(stor0.field_8) = 0
                    uint8(stor0.field_8) = 0
                    if uint8(stor0.field_0):
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
                    if uint8(stor0.field_8):
                        stor101 = 1
                        stor151 = 0
                    else:
                        uint16(stor0.field_0) = 257
                        stor101 = 1
                        uint8(stor0.field_8) = 0
                        if uint8(stor0.field_0):
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Initializable: contract is already initialized'
                        if uint8(stor0.field_8):
                            stor151 = 0
                        else:
                            uint16(stor0.field_0) = 257
                            stor151 = 0
                            uint8(stor0.field_8) = 0
    sub_6af66772Address = arg1
    sub_82c780a1Address = arg2
    sub_9702d3e2 = arg3
    sub_05ed1de4 = arg4
    if 1000 < arg4:
        revert with 0, 17
    sub_f87bbc56 = -arg4 + 1000
    startTimestamp = arg5
    sub_7b62a738 = 50
    if not uint8(stor0.field_8):
        uint8(stor0.field_8) = 0
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if block.timestamp > poolInfo[arg1].field_512:
        require ext_code.size(address(poolInfo[arg1].field_0))
        staticcall address(poolInfo[arg1].field_0).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[arg1].field_512 = block.timestamp
        else:
            if block.timestamp < poolInfo[arg1].field_512:
                revert with 0, 17
            if block.timestamp - poolInfo[arg1].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[arg1].field_512:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2) and poolInfo[arg1].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2):
                revert with 0, 17
            if not sub_91ea1d68:
                revert with 0, 18
            if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                revert with 0, 17
            if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
                revert with 0, 17
            if not 1000 * ext_call.return_data[0]:
                revert with 0, 18
            if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]):
                revert with 0, 17
            poolInfo[arg1].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]
            if not poolInfo[arg1].field_1280:
                poolInfo[arg1].field_1536 = 0
            else:
                if poolInfo[arg1].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[arg1].field_1280:
                    revert with 0, 18
                if poolInfo[arg1].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280):
                    revert with 0, 17
                poolInfo[arg1].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280
            require ext_code.size(address(poolInfo[arg1].field_0))
            staticcall address(poolInfo[arg1].field_0).0x705727b5 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                if poolInfo[arg1].field_256 and 833333333333333333 > -1 / poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(833333333333333333 * poolInfo[arg1].field_256):
                    revert with 0, 17
                if sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) < poolInfo[arg1].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) - poolInfo[arg1].field_1792
                poolInfo[arg1].field_1792 = 833333333333333333 * poolInfo[arg1].field_256
            else:
                require ext_code.size(address(poolInfo[arg1].field_0))
                staticcall address(poolInfo[arg1].field_0).0x961be391 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
                    if poolInfo[arg1].field_256 and 1 > -1 / poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[arg1].field_256 < poolInfo[arg1].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[arg1].field_256 - poolInfo[arg1].field_1792
                    poolInfo[arg1].field_1792 = poolInfo[arg1].field_256
                else:
                    if 1000000000000000000 * 10^18 > !(10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2):
                        revert with 0, 17
                    if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[arg1].field_256 and (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 > -1 / poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17) < poolInfo[arg1].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17) - poolInfo[arg1].field_1792
                    poolInfo[arg1].field_1792 = poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17
            poolInfo[arg1].field_512 = block.timestamp
            emit UpdatePool(block.timestamp, ext_call.return_data[0], poolInfo[arg1].field_768, arg1);
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 209
        if block.timestamp > poolInfo[idx].field_512:
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(poolInfo[idx].field_0))
            staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _37 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _38 = mem[_37]
            if not mem[_37]:
                poolInfo[idx].field_512 = block.timestamp
            else:
                if block.timestamp < poolInfo[idx].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_37] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_37]:
                    revert with 0, 18
                if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_37]):
                    revert with 0, 17
                poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_37]
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_1536 = 0
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _41 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _42 = mem[_41]
                    if not mem[_41]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _45 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_45] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _42:
                            revert with 0, 18
                        if not 10^18 * mem[_45] / _42:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_45] / _42 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_45] / _42:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_45] / _42 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_45] / _42) + 2 * 10^17
                else:
                    if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * poolInfo[idx].field_1280:
                        revert with 0, 18
                    if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                        revert with 0, 17
                    poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _49 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _50 = mem[_49]
                    if not mem[_49]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _53 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_53] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _50:
                            revert with 0, 18
                        if not 10^18 * mem[_53] / _50:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_53] / _50 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_53] / _50:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17
                poolInfo[idx].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _38
                mem[mem[64] + 64] = poolInfo[idx].field_768
                emit UpdatePool(block.timestamp, _38, poolInfo[idx].field_768, idx);
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function updateEmissionRate(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 209
        if block.timestamp > poolInfo[idx].field_512:
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(poolInfo[idx].field_0))
            staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _45 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _46 = mem[_45]
            if not mem[_45]:
                poolInfo[idx].field_512 = block.timestamp
            else:
                if block.timestamp < poolInfo[idx].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_45] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_45]:
                    revert with 0, 18
                if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_45]):
                    revert with 0, 17
                poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_45]
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_1536 = 0
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _49 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _50 = mem[_49]
                    if not mem[_49]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _53 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_53] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _50:
                            revert with 0, 18
                        if not 10^18 * mem[_53] / _50:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_53] / _50 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_53] / _50:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17
                else:
                    if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * poolInfo[idx].field_1280:
                        revert with 0, 18
                    if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                        revert with 0, 17
                    poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _57 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _58 = mem[_57]
                    if not mem[_57]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _61 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_61] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _58:
                            revert with 0, 18
                        if not 10^18 * mem[_61] / _58:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_61] / _58 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_61] / _58:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17
                poolInfo[idx].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _46
                mem[mem[64] + 64] = poolInfo[idx].field_768
                emit UpdatePool(block.timestamp, _46, poolInfo[idx].field_768, idx);
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    sub_9702d3e2 = arg1
    emit UpdateEmissionRate(arg1, msg.sender);
}

function sub_90d9c1c3(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    require address(arg1)
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 209
        if block.timestamp > poolInfo[idx].field_512:
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(poolInfo[idx].field_0))
            staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _45 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _46 = mem[_45]
            if not mem[_45]:
                poolInfo[idx].field_512 = block.timestamp
            else:
                if block.timestamp < poolInfo[idx].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_45] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_45]:
                    revert with 0, 18
                if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_45]):
                    revert with 0, 17
                poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_45]
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_1536 = 0
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _49 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _50 = mem[_49]
                    if not mem[_49]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _53 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_53] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _50:
                            revert with 0, 18
                        if not 10^18 * mem[_53] / _50:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_53] / _50 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_53] / _50:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17
                else:
                    if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * poolInfo[idx].field_1280:
                        revert with 0, 18
                    if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                        revert with 0, 17
                    poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _57 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _58 = mem[_57]
                    if not mem[_57]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _61 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_61] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _58:
                            revert with 0, 18
                        if not 10^18 * mem[_61] / _58:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_61] / _58 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_61] / _58:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17
                poolInfo[idx].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _46
                mem[mem[64] + 64] = poolInfo[idx].field_768
                emit UpdatePool(block.timestamp, _46, poolInfo[idx].field_768, idx);
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    sub_82c780a1Address = address(arg1)
    emit 0xcdc066eb: sub_82c780a1Address, address(arg1), msg.sender
}

function sub_e0a4ed43(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    require arg1 <= 1000
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 209
        if block.timestamp > poolInfo[idx].field_512:
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(poolInfo[idx].field_0))
            staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _43 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _45 = mem[_43]
            if not mem[_43]:
                poolInfo[idx].field_512 = block.timestamp
            else:
                if block.timestamp < poolInfo[idx].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_43] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_43]:
                    revert with 0, 18
                if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_43]):
                    revert with 0, 17
                poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_43]
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_1536 = 0
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _49 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _50 = mem[_49]
                    if not mem[_49]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _53 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_53] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _50:
                            revert with 0, 18
                        if not 10^18 * mem[_53] / _50:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_53] / _50 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_53] / _50:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_53] / _50 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_53] / _50) + 2 * 10^17
                else:
                    if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * poolInfo[idx].field_1280:
                        revert with 0, 18
                    if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                        revert with 0, 17
                    poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                    require ext_code.size(address(poolInfo[idx].field_0))
                    staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _57 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _58 = mem[_57]
                    if not mem[_57]:
                        if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                        poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                    else:
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _61 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_61] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                            revert with 0, 17
                        if not _58:
                            revert with 0, 18
                        if not 10^18 * mem[_61] / _58:
                            if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256
                        else:
                            if 1000000000000000000 * 10^18 > !(10^18 * mem[_61] / _58 / 2):
                                revert with 0, 17
                            if not 10^18 * mem[_61] / _58:
                                revert with 0, 18
                            if 2 * 10^17 > !((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58):
                                revert with 0, 17
                            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2):
                                revert with 0, 17
                            if not ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17:
                                revert with 0, 18
                            if poolInfo[idx].field_256 and (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17):
                                revert with 0, 17
                            if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_61] / _58 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_61] / _58) + 2 * 10^17
                poolInfo[idx].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _45
                mem[mem[64] + 64] = poolInfo[idx].field_768
                emit UpdatePool(block.timestamp, _45, poolInfo[idx].field_768, idx);
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    sub_05ed1de4 = arg1
    if 1000 < arg1:
        revert with 0, 17
    sub_f87bbc56 = -arg1 + 1000
    emit 0xb24c3afb: arg1, -arg1 + 1000, msg.sender
}

function sub_4f00a93e(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if sub_82c780a1Address != msg.sender:
        revert with 0, 'notVePtp: wut?'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = address(arg1)
        mem[32] = sha3(idx, 212)
        if userInfo[idx][address(arg1)].field_0:
            if idx >= poolInfo.length:
                revert with 0, 50
            mem[0] = 209
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[idx].field_0))
                staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _61 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _62 = mem[_61]
                if not mem[_61]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if block.timestamp < poolInfo[idx].field_512:
                        revert with 0, 17
                    if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                        revert with 0, 17
                    if not sub_91ea1d68:
                        revert with 0, 18
                    if mem[_61] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * mem[_61]:
                        revert with 0, 18
                    if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_61]):
                        revert with 0, 17
                    poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_61]
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_1536 = 0
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _69 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _70 = mem[_69]
                        if not mem[_69]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _73 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_73] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _70:
                                revert with 0, 18
                            if not 10^18 * mem[_73] / _70:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_73] / _70 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_73] / _70:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_73] / _70 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_73] / _70) + 2 * 10^17
                    else:
                        if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                            revert with 0, 17
                        if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                            revert with 0, 17
                        if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                            revert with 0, 17
                        if not 1000 * poolInfo[idx].field_1280:
                            revert with 0, 18
                        if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                            revert with 0, 17
                        poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _77 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _78 = mem[_77]
                        if not mem[_77]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _81 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_81] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _78:
                                revert with 0, 18
                            if not 10^18 * mem[_81] / _78:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_81] / _78 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_81] / _78:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_81] / _78 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_81] / _78) + 2 * 10^17
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _62
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(block.timestamp, _62, poolInfo[idx].field_768, idx);
            if userInfo[idx][address(arg1)].field_512 and poolInfo[idx].field_1536 > -1 / userInfo[idx][address(arg1)].field_512:
                revert with 0, 17
            if userInfo[idx][address(arg1)].field_0 and poolInfo[idx].field_768 > -1 / userInfo[idx][address(arg1)].field_0:
                revert with 0, 17
            if userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768 > !(userInfo[idx][address(arg1)].field_512 * poolInfo[idx].field_1536):
                revert with 0, 17
            if (userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768) + (userInfo[idx][address(arg1)].field_512 * poolInfo[idx].field_1536) / 10^12 < userInfo[idx][address(arg1)].field_256:
                revert with 0, 17
            mem[0] = address(arg1)
            mem[32] = sha3(idx, 213)
            if sub_8b4d83a3[idx][address(arg1)] > !(((userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768) + (userInfo[idx][address(arg1)].field_512 * poolInfo[idx].field_1536) / 10^12) - userInfo[idx][address(arg1)].field_256):
                revert with 0, 17
            sub_8b4d83a3[idx][address(arg1)] = sub_8b4d83a3[idx][address(arg1)] + ((userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768) + (userInfo[idx][address(arg1)].field_512 * poolInfo[idx].field_1536) / 10^12) - userInfo[idx][address(arg1)].field_256
            if arg2 and userInfo[idx][address(arg1)].field_0 > -1 / arg2:
                revert with 0, 17
            if arg2 * userInfo[idx][address(arg1)].field_0 <= 3:
                if not arg2 * userInfo[idx][address(arg1)].field_0:
                    userInfo[idx][address(arg1)].field_512 = 0
                    if False and poolInfo[idx].field_1536 > 0:
                        revert with 0, 17
                    if userInfo[idx][address(arg1)].field_0 and poolInfo[idx].field_768 > -1 / userInfo[idx][address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768 > -1:
                        revert with 0, 17
                    userInfo[idx][address(arg1)].field_256 = userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768 / 10^12
                    if poolInfo[idx].field_1280 > -1:
                        revert with 0, 17
                    if poolInfo[idx].field_1280 < userInfo[idx][address(arg1)].field_512:
                        revert with 0, 17
                    poolInfo[idx].field_1280 -= userInfo[idx][address(arg1)].field_512
                else:
                    userInfo[idx][address(arg1)].field_512 = 1
                    if poolInfo[idx].field_1536 > -1:
                        revert with 0, 17
                    if userInfo[idx][address(arg1)].field_0 and poolInfo[idx].field_768 > -1 / userInfo[idx][address(arg1)].field_0:
                        revert with 0, 17
                    if userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768 > !poolInfo[idx].field_1536:
                        revert with 0, 17
                    userInfo[idx][address(arg1)].field_256 = (userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768) + poolInfo[idx].field_1536 / 10^12
                    if poolInfo[idx].field_1280 > -2:
                        revert with 0, 17
                    if poolInfo[idx].field_1280 + 1 < userInfo[idx][address(arg1)].field_512:
                        revert with 0, 17
                    poolInfo[idx].field_1280 = poolInfo[idx].field_1280 + -userInfo[idx][address(arg1)].field_512 + 1
            else:
                if 1 > !(arg2 * userInfo[idx][address(arg1)].field_0 / 2):
                    revert with 0, 17
                s = (arg2 * userInfo[idx][address(arg1)].field_0 / 2) + 1
                t = arg2 * userInfo[idx][address(arg1)].field_0
                while s < t:
                    if not s:
                        revert with 0, 18
                    if arg2 * userInfo[idx][address(arg1)].field_0 / s > !s:
                        revert with 0, 17
                    s = (arg2 * userInfo[idx][address(arg1)].field_0 / s) + s / 2
                    t = s
                    continue 
                userInfo[idx][address(arg1)].field_512 = t
                if t and poolInfo[idx].field_1536 > -1 / t:
                    revert with 0, 17
                if userInfo[idx][address(arg1)].field_0 and poolInfo[idx].field_768 > -1 / userInfo[idx][address(arg1)].field_0:
                    revert with 0, 17
                if userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768 > !(t * poolInfo[idx].field_1536):
                    revert with 0, 17
                userInfo[idx][address(arg1)].field_256 = (userInfo[idx][address(arg1)].field_0 * poolInfo[idx].field_768) + (t * poolInfo[idx].field_1536) / 10^12
                if poolInfo[idx].field_1280 > !t:
                    revert with 0, 17
                if poolInfo[idx].field_1280 + t < userInfo[idx][address(arg1)].field_512:
                    revert with 0, 17
                poolInfo[idx].field_1280 = poolInfo[idx].field_1280 + t - userInfo[idx][address(arg1)].field_512
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
}

function set(uint256 arg1, uint256 arg2, address arg3, bool arg4) payable {
    mem[64] = 96
    require calldata.size - 4 >= 128
    require arg3 == arg3
    require arg4 == arg4
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if ext_code.size(arg3):
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 209
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[idx].field_0))
                staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _135 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _137 = mem[_135]
                if not mem[_135]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if block.timestamp < poolInfo[idx].field_512:
                        revert with 0, 17
                    if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                        revert with 0, 17
                    if not sub_91ea1d68:
                        revert with 0, 18
                    if mem[_135] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * mem[_135]:
                        revert with 0, 18
                    if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_135]):
                        revert with 0, 17
                    poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_135]
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_1536 = 0
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _159 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _161 = mem[_159]
                        if not mem[_159]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _179 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_179] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _161:
                                revert with 0, 18
                            if not 10^18 * mem[_179] / _161:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_179] / _161 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_179] / _161:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_179] / _161 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_179] / _161) + 2 * 10^17
                    else:
                        if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                            revert with 0, 17
                        if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                            revert with 0, 17
                        if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                            revert with 0, 17
                        if not 1000 * poolInfo[idx].field_1280:
                            revert with 0, 18
                        if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                            revert with 0, 17
                        poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _187 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _189 = mem[_187]
                        if not mem[_187]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _195 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_195] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _189:
                                revert with 0, 18
                            if not 10^18 * mem[_195] / _189:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_195] / _189 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_195] / _189:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_195] / _189 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_195] / _189) + 2 * 10^17
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _137
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(block.timestamp, _137, poolInfo[idx].field_768, idx);
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if arg1 >= poolInfo.length:
            revert with 0, 50
        mem[0] = 209
        if sub_33e045fc < poolInfo[arg1].field_256:
            revert with 0, 17
        if sub_33e045fc - poolInfo[arg1].field_256 > !arg2:
            revert with 0, 17
        sub_33e045fc = sub_33e045fc - poolInfo[arg1].field_256 + arg2
        poolInfo[arg1].field_256 = arg2
        require ext_code.size(address(poolInfo[arg1].field_0))
        staticcall address(poolInfo[arg1].field_0).0x705727b5 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _143 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _145 = mem[_143]
        if not mem[_143]:
            if poolInfo[arg1].field_256 and 833333333333333333 > -1 / poolInfo[arg1].field_256:
                revert with 0, 17
            if sub_91ea1d68 > !(833333333333333333 * poolInfo[arg1].field_256):
                revert with 0, 17
            if sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) < poolInfo[arg1].field_1792:
                revert with 0, 17
            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) - poolInfo[arg1].field_1792
            poolInfo[arg1].field_1792 = 833333333333333333 * poolInfo[arg1].field_256
        else:
            require ext_code.size(address(poolInfo[arg1].field_0))
            staticcall address(poolInfo[arg1].field_0).0x961be391 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _151 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_151] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                revert with 0, 17
            if not _145:
                revert with 0, 18
            if not 10^18 * mem[_151] / _145:
                if poolInfo[arg1].field_256 and 1 > -1 / poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 + poolInfo[arg1].field_256 < poolInfo[arg1].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + poolInfo[arg1].field_256 - poolInfo[arg1].field_1792
                poolInfo[arg1].field_1792 = poolInfo[arg1].field_256
            else:
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_151] / _145 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_151] / _145:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[arg1].field_256 and (((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17 > -1 / poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[arg1].field_256 * (((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17) < poolInfo[arg1].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17) - poolInfo[arg1].field_1792
                poolInfo[arg1].field_1792 = poolInfo[arg1].field_256 * (((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_151] / _145 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_151] / _145) + 2 * 10^17
    else:
        if arg3:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'set: rewarder must be contract or zero'
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 209
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[idx].field_0))
                staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _136 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _138 = mem[_136]
                if not mem[_136]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if block.timestamp < poolInfo[idx].field_512:
                        revert with 0, 17
                    if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                        revert with 0, 17
                    if not sub_91ea1d68:
                        revert with 0, 18
                    if mem[_136] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * mem[_136]:
                        revert with 0, 18
                    if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_136]):
                        revert with 0, 17
                    poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_136]
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_1536 = 0
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _160 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _162 = mem[_160]
                        if not mem[_160]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _180 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_180] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _162:
                                revert with 0, 18
                            if not 10^18 * mem[_180] / _162:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_180] / _162 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_180] / _162:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_180] / _162 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_180] / _162) + 2 * 10^17
                    else:
                        if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                            revert with 0, 17
                        if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                            revert with 0, 17
                        if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                            revert with 0, 17
                        if not 1000 * poolInfo[idx].field_1280:
                            revert with 0, 18
                        if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                            revert with 0, 17
                        poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _188 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _190 = mem[_188]
                        if not mem[_188]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _196 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_196] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _190:
                                revert with 0, 18
                            if not 10^18 * mem[_196] / _190:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_196] / _190 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_196] / _190:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_196] / _190 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_196] / _190) + 2 * 10^17
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _138
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(block.timestamp, _138, poolInfo[idx].field_768, idx);
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if arg1 >= poolInfo.length:
            revert with 0, 50
        mem[0] = 209
        if sub_33e045fc < poolInfo[arg1].field_256:
            revert with 0, 17
        if sub_33e045fc - poolInfo[arg1].field_256 > !arg2:
            revert with 0, 17
        sub_33e045fc = sub_33e045fc - poolInfo[arg1].field_256 + arg2
        poolInfo[arg1].field_256 = arg2
        require ext_code.size(address(poolInfo[arg1].field_0))
        staticcall address(poolInfo[arg1].field_0).0x705727b5 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _144 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _146 = mem[_144]
        if not mem[_144]:
            if poolInfo[arg1].field_256 and 833333333333333333 > -1 / poolInfo[arg1].field_256:
                revert with 0, 17
            if sub_91ea1d68 > !(833333333333333333 * poolInfo[arg1].field_256):
                revert with 0, 17
            if sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) < poolInfo[arg1].field_1792:
                revert with 0, 17
            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) - poolInfo[arg1].field_1792
            poolInfo[arg1].field_1792 = 833333333333333333 * poolInfo[arg1].field_256
        else:
            require ext_code.size(address(poolInfo[arg1].field_0))
            staticcall address(poolInfo[arg1].field_0).0x961be391 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _152 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_152] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                revert with 0, 17
            if not _146:
                revert with 0, 18
            if not 10^18 * mem[_152] / _146:
                if poolInfo[arg1].field_256 and 1 > -1 / poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 + poolInfo[arg1].field_256 < poolInfo[arg1].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + poolInfo[arg1].field_256 - poolInfo[arg1].field_1792
                poolInfo[arg1].field_1792 = poolInfo[arg1].field_256
            else:
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_152] / _146 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_152] / _146:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[arg1].field_256 and (((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17 > -1 / poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[arg1].field_256 * (((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17) < poolInfo[arg1].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17) - poolInfo[arg1].field_1792
                poolInfo[arg1].field_1792 = poolInfo[arg1].field_256 * (((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_152] / _146 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_152] / _146) + 2 * 10^17
    if not arg4:
        emit 0xa54644aa: arg2, arg4, arg1, address(poolInfo[arg1].field_1024)
    else:
        address(poolInfo[arg1].field_1024) = arg3
        if arg4:
            emit 0xa54644aa: arg2, arg4, arg1, arg3
        else:
            emit 0xa54644aa: arg2, arg4, arg1, address(poolInfo[arg1].field_1024)
}

function pendingTokens(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 >= poolInfo.length:
        revert with 0, 50
    mem[100] = this.address
    require ext_code.size(address(poolInfo[arg1].field_0))
    staticcall address(poolInfo[arg1].field_0).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.timestamp <= poolInfo[arg1].field_512:
        mem[32] = sha3(arg1, 213)
        if userInfo[arg1][address(arg2)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg2)].field_512:
            revert with 0, 17
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536):
            revert with 0, 17
        if (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][address(arg2)]:
            revert with 0, 17
        if ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        if not address(poolInfo[arg1].field_1024):
            mem[ceil32(return_data.size) + 96] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ext_call.return_data[0] + ceil32(return_data.size) + 256] = 0
            return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        if arg1 >= poolInfo.length:
            revert with 0, 50
        mem[0] = 209
        if not address(poolInfo[arg1].field_1024):
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(address(poolInfo[arg1].field_1024))
            staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(2 * ceil32(return_data.size)) + 96] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ext_call.return_data[0] + (2 * ceil32(return_data.size)) + 256] = 0
            return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(4 * ceil32(return_data.size)) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _66 = mem[(4 * ceil32(return_data.size)) + 96]
        require mem[(4 * ceil32(return_data.size)) + 96] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 127 < (4 * ceil32(return_data.size)) + return_data.size + 96
        _68 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97 > test266151307():
            revert with 0, 65
        mem[64] = (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97
        mem[(6 * ceil32(return_data.size)) + 96] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
        require _66 + _68 + 32 <= return_data.size
        mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_68)] = mem[(4 * ceil32(return_data.size)) + _66 + 128 len ceil32(_68)]
        if ceil32(_68) <= _68:
            mem[mem[64] + 4] = arg2
            require ext_code.size(address(poolInfo[arg1].field_1024))
            staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _252 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _260 = mem[_252]
            mem[mem[64]] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _68
            mem[mem[64] + 160 len ceil32(_68)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_68)]
            if ceil32(_68) > _68:
                mem[_68 + mem[64] + 160] = 0
            mem[mem[64] + 96] = _260
            return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_68, data=mem[mem[64] + 160 len ceil32(_68)]),
                   _260
        mem[_68 + (6 * ceil32(return_data.size)) + 128] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _253 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _261 = mem[_253]
        mem[mem[64]] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _68
        mem[mem[64] + 160 len ceil32(_68)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_68)]
        if ceil32(_68) > _68:
            mem[_68 + mem[64] + 160] = 0
        mem[mem[64] + 96] = _261
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
               address(ext_call.return_data[0]),
               Array(len=_68, data=mem[mem[64] + 160 len ceil32(_68)]),
               _261
    if not ext_call.return_data[0]:
        mem[32] = sha3(arg1, 213)
        if userInfo[arg1][address(arg2)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg2)].field_512:
            revert with 0, 17
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536):
            revert with 0, 17
        if (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][address(arg2)]:
            revert with 0, 17
        if ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        if not address(poolInfo[arg1].field_1024):
            mem[ceil32(return_data.size) + 96] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ext_call.return_data[0] + ceil32(return_data.size) + 256] = 0
            return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        if arg1 >= poolInfo.length:
            revert with 0, 50
        mem[0] = 209
        if not address(poolInfo[arg1].field_1024):
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(address(poolInfo[arg1].field_1024))
            staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(2 * ceil32(return_data.size)) + 96] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ext_call.return_data[0] + (2 * ceil32(return_data.size)) + 256] = 0
            return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(4 * ceil32(return_data.size)) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _67 = mem[(4 * ceil32(return_data.size)) + 96]
        require mem[(4 * ceil32(return_data.size)) + 96] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 127 < (4 * ceil32(return_data.size)) + return_data.size + 96
        _69 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97 > test266151307():
            revert with 0, 65
        mem[64] = (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97
        mem[(6 * ceil32(return_data.size)) + 96] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
        require _67 + _69 + 32 <= return_data.size
        mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_69)] = mem[(4 * ceil32(return_data.size)) + _67 + 128 len ceil32(_69)]
        if ceil32(_69) <= _69:
            mem[mem[64] + 4] = arg2
            require ext_code.size(address(poolInfo[arg1].field_1024))
            staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _254 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _262 = mem[_254]
            mem[mem[64]] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _69
            mem[mem[64] + 160 len ceil32(_69)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_69)]
            if ceil32(_69) > _69:
                mem[_69 + mem[64] + 160] = 0
            mem[mem[64] + 96] = _262
            return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_69, data=mem[mem[64] + 160 len ceil32(_69)]),
                   _262
        mem[_69 + (6 * ceil32(return_data.size)) + 128] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _255 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _263 = mem[_255]
        mem[mem[64]] = ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _69
        mem[mem[64] + 160 len ceil32(_69)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_69)]
        if ceil32(_69) > _69:
            mem[_69 + mem[64] + 160] = 0
        mem[mem[64] + 96] = _263
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
               address(ext_call.return_data[0]),
               Array(len=_69, data=mem[mem[64] + 160 len ceil32(_69)]),
               _263
    if block.timestamp < poolInfo[arg1].field_512:
        revert with 0, 17
    if block.timestamp - poolInfo[arg1].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[arg1].field_512:
        revert with 0, 17
    if (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2) and poolInfo[arg1].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2):
        revert with 0, 17
    if not sub_91ea1d68:
        revert with 0, 18
    if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
        revert with 0, 17
    if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
        revert with 0, 17
    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
        revert with 0, 17
    if not 1000 * ext_call.return_data[0]:
        revert with 0, 18
    if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]):
        revert with 0, 17
    if 0 == poolInfo[arg1].field_1280:
        mem[32] = sha3(arg1, 213)
        if userInfo[arg1][address(arg2)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg2)].field_512:
            revert with 0, 17
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) > !(userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536):
            revert with 0, 17
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][address(arg2)]:
            revert with 0, 17
        if ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        if not address(poolInfo[arg1].field_1024):
            mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ext_call.return_data[0] + ceil32(return_data.size) + 256] = 0
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        if arg1 >= poolInfo.length:
            revert with 0, 50
        mem[0] = 209
        if not address(poolInfo[arg1].field_1024):
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(address(poolInfo[arg1].field_1024))
            staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ext_call.return_data[0] + (2 * ceil32(return_data.size)) + 256] = 0
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(4 * ceil32(return_data.size)) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _140 = mem[(4 * ceil32(return_data.size)) + 96]
        require mem[(4 * ceil32(return_data.size)) + 96] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 127 < (4 * ceil32(return_data.size)) + return_data.size + 96
        _151 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97 > test266151307():
            revert with 0, 65
        mem[64] = (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97
        mem[(6 * ceil32(return_data.size)) + 96] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
        require _140 + _151 + 32 <= return_data.size
        mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_151)] = mem[(4 * ceil32(return_data.size)) + _140 + 128 len ceil32(_151)]
        if ceil32(_151) <= _151:
            mem[mem[64] + 4] = arg2
            require ext_code.size(address(poolInfo[arg1].field_1024))
            staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _256 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _264 = mem[_256]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _151
            mem[mem[64] + 160 len ceil32(_151)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_151)]
            if ceil32(_151) > _151:
                mem[_151 + mem[64] + 160] = 0
            mem[mem[64] + 96] = _264
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_151, data=mem[mem[64] + 160 len ceil32(_151)]),
                   _264
        mem[_151 + (6 * ceil32(return_data.size)) + 128] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _257 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _265 = mem[_257]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _151
        mem[mem[64] + 160 len ceil32(_151)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_151)]
        if ceil32(_151) > _151:
            mem[_151 + mem[64] + 160] = 0
        mem[mem[64] + 96] = _265
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (userInfo[arg1][address(arg2)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
               address(ext_call.return_data[0]),
               Array(len=_151, data=mem[mem[64] + 160 len ceil32(_151)]),
               _265
    if poolInfo[arg1].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
        revert with 0, 17
    if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
        revert with 0, 17
    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
        revert with 0, 17
    if not 1000 * poolInfo[arg1].field_1280:
        revert with 0, 18
    if poolInfo[arg1].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280):
        revert with 0, 17
    mem[32] = sha3(arg1, 213)
    if userInfo[arg1][address(arg2)].field_512 and poolInfo[arg1].field_1536 + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280) > -1 / userInfo[arg1][address(arg2)].field_512:
        revert with 0, 17
    if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
        revert with 0, 17
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) > !((poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512)):
        revert with 0, 17
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12 > !sub_8b4d83a3[arg1][address(arg2)]:
        revert with 0, 17
    if ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] < userInfo[arg1][address(arg2)].field_256:
        revert with 0, 17
    if not address(poolInfo[arg1].field_1024):
        mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
        mem[ceil32(return_data.size) + 128] = 0
        mem[ceil32(return_data.size) + 160] = 128
        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
            mem[ext_call.return_data[0] + ceil32(return_data.size) + 256] = 0
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
               0,
               128,
               0,
               ext_call.return_data[0],
               mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
    if arg1 >= poolInfo.length:
        revert with 0, 50
    mem[0] = 209
    if not address(poolInfo[arg1].field_1024):
        mem[ceil32(return_data.size) + 100] = arg2
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                gas gas_remaining wei
               args arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
        mem[(2 * ceil32(return_data.size)) + 128] = 0
        mem[(2 * ceil32(return_data.size)) + 160] = 128
        mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
            mem[ext_call.return_data[0] + (2 * ceil32(return_data.size)) + 256] = 0
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
               0,
               128,
               ext_call.return_data[0],
               ext_call.return_data[0],
               mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
    require ext_code.size(address(poolInfo[arg1].field_1024))
    staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(poolInfo[arg1].field_1024))
    staticcall address(poolInfo[arg1].field_1024).rewardToken() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(4 * ceil32(return_data.size)) + 96] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(4 * ceil32(return_data.size)) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _172 = mem[(4 * ceil32(return_data.size)) + 96]
    require mem[(4 * ceil32(return_data.size)) + 96] <= test266151307()
    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 127 < (4 * ceil32(return_data.size)) + return_data.size + 96
    _175 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97 > test266151307():
        revert with 0, 65
    mem[64] = (6 * ceil32(return_data.size)) + ceil32(ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96])) + 97
    mem[(6 * ceil32(return_data.size)) + 96] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 96] + 96]
    require _172 + _175 + 32 <= return_data.size
    mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_175)] = mem[(4 * ceil32(return_data.size)) + _172 + 128 len ceil32(_175)]
    if ceil32(_175) <= _175:
        mem[mem[64] + 4] = arg2
        require ext_code.size(address(poolInfo[arg1].field_1024))
        staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _258 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _266 = mem[_258]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _175
        mem[mem[64] + 160 len ceil32(_175)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_175)]
        if ceil32(_175) > _175:
            mem[_175 + mem[64] + 160] = 0
        mem[mem[64] + 96] = _266
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
               address(ext_call.return_data[0]),
               Array(len=_175, data=mem[mem[64] + 160 len ceil32(_175)]),
               _266
    mem[_175 + (6 * ceil32(return_data.size)) + 128] = 0
    mem[mem[64] + 4] = arg2
    require ext_code.size(address(poolInfo[arg1].field_1024))
    staticcall address(poolInfo[arg1].field_1024).pendingTokens(address arg1) with:
            gas gas_remaining wei
           args address(arg2)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _259 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _267 = mem[_259]
    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256
    mem[mem[64] + 32] = address(ext_call.return_data[0])
    mem[mem[64] + 64] = 128
    mem[mem[64] + 128] = _175
    mem[mem[64] + 160 len ceil32(_175)] = mem[(6 * ceil32(return_data.size)) + 128 len ceil32(_175)]
    if ceil32(_175) > _175:
        mem[_175 + mem[64] + 160] = 0
    mem[mem[64] + 96] = _267
    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1536 * userInfo[arg1][address(arg2)].field_512) + (10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_512) / 10^12) + sub_8b4d83a3[arg1][address(arg2)] - userInfo[arg1][address(arg2)].field_256, 
           address(ext_call.return_data[0]),
           Array(len=_175, data=mem[mem[64] + 160 len ceil32(_175)]),
           _267
}

function add(uint256 arg1, address arg2, address arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require arg2 == arg2
    require arg3 == arg3
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if not ext_code.size(arg2):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'add: LP token must be a valid contract'
    if ext_code.size(arg3):
        mem[0] = arg2
        mem[32] = 211
        if stor211[address(arg2)]:
            revert with 0, 'add: LP already added'
        if poolInfo.length >= sub_7b62a738:
            revert with 0, 'add: exceed max pool'
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 209
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[idx].field_0))
                staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _323 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _329 = mem[_323]
                if not mem[_323]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if block.timestamp < poolInfo[idx].field_512:
                        revert with 0, 17
                    if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                        revert with 0, 17
                    if not sub_91ea1d68:
                        revert with 0, 18
                    if mem[_323] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * mem[_323]:
                        revert with 0, 18
                    if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_323]):
                        revert with 0, 17
                    poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_323]
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_1536 = 0
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _403 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _413 = mem[_403]
                        if not mem[_403]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _427 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_427] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _413:
                                revert with 0, 18
                            if not 10^18 * mem[_427] / _413:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_427] / _413 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_427] / _413:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_427] / _413 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_427] / _413) + 2 * 10^17
                    else:
                        if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                            revert with 0, 17
                        if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                            revert with 0, 17
                        if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                            revert with 0, 17
                        if not 1000 * poolInfo[idx].field_1280:
                            revert with 0, 18
                        if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                            revert with 0, 17
                        poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _473 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _485 = mem[_473]
                        if not mem[_473]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _491 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_491] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _485:
                                revert with 0, 18
                            if not 10^18 * mem[_491] / _485:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_491] / _485 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_491] / _485:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_491] / _485 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_491] / _485) + 2 * 10^17
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _329
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(block.timestamp, _329, poolInfo[idx].field_768, idx);
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        require ext_code.size(arg2)
        staticcall arg2.0x705727b5 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if block.timestamp > startTimestamp:
            _325 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _331 = mem[_325]
            if not mem[_325]:
                if arg1 and 833333333333333333 > -1 / arg1:
                    revert with 0, 17
                if sub_33e045fc > !arg1:
                    revert with 0, 17
                sub_33e045fc += arg1
                if sub_91ea1d68 > !(833333333333333333 * arg1):
                    revert with 0, 17
                sub_91ea1d68 += 833333333333333333 * arg1
                poolInfo.length++
                stor695F[stor209.length] = arg2
                stor695F[stor209.length] = arg1
                stor695F[stor209.length] = block.timestamp
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = arg3
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 833333333333333333 * arg1
            else:
                require ext_code.size(arg2)
                staticcall arg2.0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _343 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_343] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _331:
                    revert with 0, 18
                if not 10^18 * mem[_343] / _331:
                    if arg1 and 1 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !arg1:
                        revert with 0, 17
                    sub_91ea1d68 += arg1
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = block.timestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1
                else:
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_343] / _331 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_343] / _331:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17:
                        revert with 0, 18
                    if arg1 and (((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !(arg1 * (((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17):
                        revert with 0, 17
                    sub_91ea1d68 += arg1 * (((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = block.timestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1 * (((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_343] / _331 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_343] / _331) + 2 * 10^17
        else:
            _326 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _332 = mem[_326]
            if not mem[_326]:
                if arg1 and 833333333333333333 > -1 / arg1:
                    revert with 0, 17
                if sub_33e045fc > !arg1:
                    revert with 0, 17
                sub_33e045fc += arg1
                if sub_91ea1d68 > !(833333333333333333 * arg1):
                    revert with 0, 17
                sub_91ea1d68 += 833333333333333333 * arg1
                poolInfo.length++
                stor695F[stor209.length] = arg2
                stor695F[stor209.length] = arg1
                stor695F[stor209.length] = startTimestamp
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = arg3
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 833333333333333333 * arg1
            else:
                require ext_code.size(arg2)
                staticcall arg2.0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_344] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _332:
                    revert with 0, 18
                if not 10^18 * mem[_344] / _332:
                    if arg1 and 1 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !arg1:
                        revert with 0, 17
                    sub_91ea1d68 += arg1
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = startTimestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1
                else:
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_344] / _332 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_344] / _332:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17:
                        revert with 0, 18
                    if arg1 and (((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !(arg1 * (((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17):
                        revert with 0, 17
                    sub_91ea1d68 += arg1 * (((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = startTimestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1 * (((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_344] / _332 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_344] / _332) + 2 * 10^17
    else:
        if arg3:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'add: rewarder must be contract or zero'
        mem[0] = arg2
        mem[32] = 211
        if stor211[address(arg2)]:
            revert with 0, 'add: LP already added'
        if poolInfo.length >= sub_7b62a738:
            revert with 0, 'add: exceed max pool'
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 209
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[idx].field_0))
                staticcall address(poolInfo[idx].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _324 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _330 = mem[_324]
                if not mem[_324]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if block.timestamp < poolInfo[idx].field_512:
                        revert with 0, 17
                    if block.timestamp - poolInfo[idx].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[idx].field_512:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2) and poolInfo[idx].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[idx].field_512 * sub_9702d3e2):
                        revert with 0, 17
                    if not sub_91ea1d68:
                        revert with 0, 18
                    if mem[_324] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                        revert with 0, 17
                    if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                        revert with 0, 17
                    if not 1000 * mem[_324]:
                        revert with 0, 18
                    if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_324]):
                        revert with 0, 17
                    poolInfo[idx].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_324]
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_1536 = 0
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _404 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _422 = mem[_404]
                        if not mem[_404]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _428 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_428] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _422:
                                revert with 0, 18
                            if not 10^18 * mem[_428] / _422:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_428] / _422 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_428] / _422:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_428] / _422 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_428] / _422) + 2 * 10^17
                    else:
                        if poolInfo[idx].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                            revert with 0, 17
                        if (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                            revert with 0, 17
                        if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68:
                            revert with 0, 17
                        if not 1000 * poolInfo[idx].field_1280:
                            revert with 0, 18
                        if poolInfo[idx].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280):
                            revert with 0, 17
                        poolInfo[idx].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[idx].field_1792) - (poolInfo[idx].field_512 * sub_9702d3e2 * poolInfo[idx].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[idx].field_1280
                        require ext_code.size(address(poolInfo[idx].field_0))
                        staticcall address(poolInfo[idx].field_0).0x705727b5 with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _476 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _486 = mem[_476]
                        if not mem[_476]:
                            if poolInfo[idx].field_256 and 833333333333333333 > -1 / poolInfo[idx].field_256:
                                revert with 0, 17
                            if sub_91ea1d68 > !(833333333333333333 * poolInfo[idx].field_256):
                                revert with 0, 17
                            if sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) < poolInfo[idx].field_1792:
                                revert with 0, 17
                            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[idx].field_256) - poolInfo[idx].field_1792
                            poolInfo[idx].field_1792 = 833333333333333333 * poolInfo[idx].field_256
                        else:
                            require ext_code.size(address(poolInfo[idx].field_0))
                            staticcall address(poolInfo[idx].field_0).0x961be391 with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _492 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_492] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                                revert with 0, 17
                            if not _486:
                                revert with 0, 18
                            if not 10^18 * mem[_492] / _486:
                                if poolInfo[idx].field_256 and 1 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 + poolInfo[idx].field_256 < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + poolInfo[idx].field_256 - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256
                            else:
                                if 1000000000000000000 * 10^18 > !(10^18 * mem[_492] / _486 / 2):
                                    revert with 0, 17
                                if not 10^18 * mem[_492] / _486:
                                    revert with 0, 18
                                if 2 * 10^17 > !((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486):
                                    revert with 0, 17
                                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17 / 2):
                                    revert with 0, 17
                                if not ((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17:
                                    revert with 0, 18
                                if poolInfo[idx].field_256 and (((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17 > -1 / poolInfo[idx].field_256:
                                    revert with 0, 17
                                if sub_91ea1d68 > !(poolInfo[idx].field_256 * (((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17):
                                    revert with 0, 17
                                if sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17) < poolInfo[idx].field_1792:
                                    revert with 0, 17
                                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[idx].field_256 * (((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17) - poolInfo[idx].field_1792
                                poolInfo[idx].field_1792 = poolInfo[idx].field_256 * (((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_492] / _486 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_492] / _486) + 2 * 10^17
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _330
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(block.timestamp, _330, poolInfo[idx].field_768, idx);
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        require ext_code.size(arg2)
        staticcall arg2.0x705727b5 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if block.timestamp > startTimestamp:
            _327 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _333 = mem[_327]
            if not mem[_327]:
                if arg1 and 833333333333333333 > -1 / arg1:
                    revert with 0, 17
                if sub_33e045fc > !arg1:
                    revert with 0, 17
                sub_33e045fc += arg1
                if sub_91ea1d68 > !(833333333333333333 * arg1):
                    revert with 0, 17
                sub_91ea1d68 += 833333333333333333 * arg1
                poolInfo.length++
                stor695F[stor209.length] = arg2
                stor695F[stor209.length] = arg1
                stor695F[stor209.length] = block.timestamp
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = arg3
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 833333333333333333 * arg1
            else:
                require ext_code.size(arg2)
                staticcall arg2.0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _345 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_345] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _333:
                    revert with 0, 18
                if not 10^18 * mem[_345] / _333:
                    if arg1 and 1 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !arg1:
                        revert with 0, 17
                    sub_91ea1d68 += arg1
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = block.timestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1
                else:
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_345] / _333 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_345] / _333:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17:
                        revert with 0, 18
                    if arg1 and (((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !(arg1 * (((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17):
                        revert with 0, 17
                    sub_91ea1d68 += arg1 * (((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = block.timestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1 * (((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_345] / _333 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_345] / _333) + 2 * 10^17
        else:
            _328 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _334 = mem[_328]
            if not mem[_328]:
                if arg1 and 833333333333333333 > -1 / arg1:
                    revert with 0, 17
                if sub_33e045fc > !arg1:
                    revert with 0, 17
                sub_33e045fc += arg1
                if sub_91ea1d68 > !(833333333333333333 * arg1):
                    revert with 0, 17
                sub_91ea1d68 += 833333333333333333 * arg1
                poolInfo.length++
                stor695F[stor209.length] = arg2
                stor695F[stor209.length] = arg1
                stor695F[stor209.length] = startTimestamp
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = arg3
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 0
                stor695F[stor209.length] = 833333333333333333 * arg1
            else:
                require ext_code.size(arg2)
                staticcall arg2.0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _346 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_346] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _334:
                    revert with 0, 18
                if not 10^18 * mem[_346] / _334:
                    if arg1 and 1 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !arg1:
                        revert with 0, 17
                    sub_91ea1d68 += arg1
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = startTimestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1
                else:
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_346] / _334 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_346] / _334:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17:
                        revert with 0, 18
                    if arg1 and (((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17 > -1 / arg1:
                        revert with 0, 17
                    if sub_33e045fc > !arg1:
                        revert with 0, 17
                    sub_33e045fc += arg1
                    if sub_91ea1d68 > !(arg1 * (((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17):
                        revert with 0, 17
                    sub_91ea1d68 += arg1 * (((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17
                    poolInfo.length++
                    stor695F[stor209.length] = arg2
                    stor695F[stor209.length] = arg1
                    stor695F[stor209.length] = startTimestamp
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg3
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = 0
                    stor695F[stor209.length] = arg1 * (((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_346] / _334 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_346] / _334) + 2 * 10^17
    if not stor211[address(arg2)]:
        stor210.length++
        address(stor210[stor210.length].field_0) = arg2
        Mask(96, 0, stor210[stor210.length].field_160) = 0
        stor211[address(arg2)] = stor210.length
    if poolInfo.length < 1:
        revert with 0, 17
    emit 0x4b16bd24: arg1, poolInfo.length - 1, arg2, arg3
}

function depositFor(uint256 arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    require arg3 == arg3
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    if stor151:
        revert with 0, 'Pausable: paused'
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if block.timestamp <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg3)].field_0:
            if userInfo[arg1][address(arg3)].field_0 > !arg2:
                revert with 0, 17
            userInfo[arg1][address(arg3)].field_0 += arg2
            mem[100] = arg3
            require ext_code.size(sub_82c780a1Address)
            staticcall sub_82c780a1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args arg3
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                    userInfo[arg1][address(arg3)].field_512 = 0
                    if poolInfo[arg1].field_1280 > -1:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                else:
                    userInfo[arg1][address(arg3)].field_512 = 1
                    if poolInfo[arg1].field_1280 > -2:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
            else:
                if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                    revert with 0, 17
                s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                while s < t:
                    if not s:
                        revert with 0, 18
                    if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                        revert with 0, 17
                    s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                    t = s
                    continue 
                userInfo[arg1][address(arg3)].field_512 = t
                if poolInfo[arg1].field_1280 > !t:
                    revert with 0, 17
                if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                    revert with 0, 17
                poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
            if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                revert with 0, 17
            userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
            if arg1 >= poolInfo.length:
                revert with 0, 50
            if not address(poolInfo[arg1].field_1024):
                mem[ceil32(return_data.size) + 132] = msg.sender
                mem[ceil32(return_data.size) + 164] = this.address
                mem[ceil32(return_data.size) + 196] = arg2
                mem[ceil32(return_data.size) + 96] = 100
                mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[ceil32(return_data.size) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[ceil32(return_data.size) + 228] = 32
                mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[ceil32(return_data.size) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                        if not mem[ceil32(return_data.size) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[ceil32(return_data.size) + 100] = arg3
                mem[ceil32(return_data.size) + 132] = userInfo[arg1][address(arg3)].field_0
                require ext_code.size(address(poolInfo[arg1].field_1024))
                call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args address(arg3), userInfo[arg1][address(arg3)].field_0
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(2 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(2 * ceil32(return_data.size)) + 164] = this.address
                mem[(2 * ceil32(return_data.size)) + 196] = arg2
                mem[(2 * ceil32(return_data.size)) + 96] = 100
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(2 * ceil32(return_data.size)) + 228] = 32
                mem[(2 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(2 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(2 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(2 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 324] == bool(mem[(2 * ceil32(return_data.size)) + 324])
                        if not mem[(2 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                revert with 0, 17
            if (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][address(arg3)]:
                revert with 0, 17
            if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] < userInfo[arg1][address(arg3)].field_256:
                revert with 0, 17
            sub_8b4d83a3[arg1][address(arg3)] = 0
            mem[100] = this.address
            require ext_code.size(sub_6af66772Address)
            staticcall sub_6af66772Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= 0:
                revert with 0, 'No tokens to distribute'
            mem[ceil32(return_data.size) + 100] = arg3
            if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256 <= ext_call.return_data[0]:
                mem[ceil32(return_data.size) + 132] = ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args address(arg3), ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                emit Harvest((((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256), arg3, arg1);
            else:
                mem[ceil32(return_data.size) + 132] = ext_call.return_data[0]
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args address(arg3), ext_call.return_data[0]
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                emit Harvest(ext_call.return_data[0], arg3, arg1);
            if userInfo[arg1][address(arg3)].field_0 > !arg2:
                revert with 0, 17
            userInfo[arg1][address(arg3)].field_0 += arg2
            mem[(2 * ceil32(return_data.size)) + 100] = arg3
            require ext_code.size(sub_82c780a1Address)
            staticcall sub_82c780a1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args arg3
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                    userInfo[arg1][address(arg3)].field_512 = 0
                    if poolInfo[arg1].field_1280 > -1:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                else:
                    userInfo[arg1][address(arg3)].field_512 = 1
                    if poolInfo[arg1].field_1280 > -2:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
            else:
                if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                    revert with 0, 17
                s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                while s < t:
                    if not s:
                        revert with 0, 18
                    if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                        revert with 0, 17
                    s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                    t = s
                    continue 
                userInfo[arg1][address(arg3)].field_512 = t
                if poolInfo[arg1].field_1280 > !t:
                    revert with 0, 17
                if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                    revert with 0, 17
                poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
            if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                revert with 0, 17
            if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                revert with 0, 17
            userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
            if arg1 >= poolInfo.length:
                revert with 0, 50
            if not address(poolInfo[arg1].field_1024):
                mem[(4 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(4 * ceil32(return_data.size)) + 164] = this.address
                mem[(4 * ceil32(return_data.size)) + 196] = arg2
                mem[(4 * ceil32(return_data.size)) + 96] = 100
                mem[(4 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(4 * ceil32(return_data.size)) + 228] = 32
                mem[(4 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(4 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(4 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(4 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(4 * ceil32(return_data.size)) + 324] == bool(mem[(4 * ceil32(return_data.size)) + 324])
                        if not mem[(4 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[(4 * ceil32(return_data.size)) + 100] = arg3
                mem[(4 * ceil32(return_data.size)) + 132] = userInfo[arg1][address(arg3)].field_0
                require ext_code.size(address(poolInfo[arg1].field_1024))
                call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args address(arg3), userInfo[arg1][address(arg3)].field_0
                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(6 * ceil32(return_data.size)) + 164] = this.address
                mem[(6 * ceil32(return_data.size)) + 196] = arg2
                mem[(6 * ceil32(return_data.size)) + 96] = 100
                mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(6 * ceil32(return_data.size)) + 228] = 32
                mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(6 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                        if not mem[(6 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[100] = this.address
        require ext_code.size(address(poolInfo[arg1].field_0))
        staticcall address(poolInfo[arg1].field_0).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[arg1].field_512 = block.timestamp
            if not userInfo[arg1][address(arg3)].field_0:
                if userInfo[arg1][address(arg3)].field_0 > !arg2:
                    revert with 0, 17
                userInfo[arg1][address(arg3)].field_0 += arg2
                mem[ceil32(return_data.size) + 100] = arg3
                require ext_code.size(sub_82c780a1Address)
                staticcall sub_82c780a1Address.0x70a08231 with:
                        gas gas_remaining wei
                       args arg3
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                    if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                        userInfo[arg1][address(arg3)].field_512 = 0
                        if poolInfo[arg1].field_1280 > -1:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                    else:
                        userInfo[arg1][address(arg3)].field_512 = 1
                        if poolInfo[arg1].field_1280 > -2:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
                else:
                    if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                        revert with 0, 17
                    s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                    t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                    while s < t:
                        if not s:
                            revert with 0, 18
                        if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                            revert with 0, 17
                        s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                        t = s
                        continue 
                    userInfo[arg1][address(arg3)].field_512 = t
                    if poolInfo[arg1].field_1280 > !t:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
                if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
                if arg1 >= poolInfo.length:
                    revert with 0, 50
                if not address(poolInfo[arg1].field_1024):
                    mem[(2 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    mem[(2 * ceil32(return_data.size)) + 196] = arg2
                    mem[(2 * ceil32(return_data.size)) + 96] = 100
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(2 * ceil32(return_data.size)) + 228] = 32
                    mem[(2 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(2 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(2 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(2 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 324] == bool(mem[(2 * ceil32(return_data.size)) + 324])
                            if not mem[(2 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(2 * ceil32(return_data.size)) + 100] = arg3
                    mem[(2 * ceil32(return_data.size)) + 132] = userInfo[arg1][address(arg3)].field_0
                    require ext_code.size(address(poolInfo[arg1].field_1024))
                    call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args address(arg3), userInfo[arg1][address(arg3)].field_0
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(4 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(4 * ceil32(return_data.size)) + 164] = this.address
                    mem[(4 * ceil32(return_data.size)) + 196] = arg2
                    mem[(4 * ceil32(return_data.size)) + 96] = 100
                    mem[(4 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(4 * ceil32(return_data.size)) + 228] = 32
                    mem[(4 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(4 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(4 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(4 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(4 * ceil32(return_data.size)) + 324] == bool(mem[(4 * ceil32(return_data.size)) + 324])
                            if not mem[(4 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                if (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][address(arg3)]:
                    revert with 0, 17
                if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] < userInfo[arg1][address(arg3)].field_256:
                    revert with 0, 17
                sub_8b4d83a3[arg1][address(arg3)] = 0
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(sub_6af66772Address)
                staticcall sub_6af66772Address.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'No tokens to distribute'
                mem[(2 * ceil32(return_data.size)) + 100] = arg3
                if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256 <= ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + 132] = ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                    require ext_code.size(sub_6af66772Address)
                    call sub_6af66772Address.0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg3), ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    emit Harvest((((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256), arg3, arg1);
                else:
                    mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
                    require ext_code.size(sub_6af66772Address)
                    call sub_6af66772Address.0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg3), ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    emit Harvest(ext_call.return_data[0], arg3, arg1);
                if userInfo[arg1][address(arg3)].field_0 > !arg2:
                    revert with 0, 17
                userInfo[arg1][address(arg3)].field_0 += arg2
                mem[(4 * ceil32(return_data.size)) + 100] = arg3
                require ext_code.size(sub_82c780a1Address)
                staticcall sub_82c780a1Address.0x70a08231 with:
                        gas gas_remaining wei
                       args arg3
                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                    if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                        userInfo[arg1][address(arg3)].field_512 = 0
                        if poolInfo[arg1].field_1280 > -1:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                    else:
                        userInfo[arg1][address(arg3)].field_512 = 1
                        if poolInfo[arg1].field_1280 > -2:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
                else:
                    if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                        revert with 0, 17
                    s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                    t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                    while s < t:
                        if not s:
                            revert with 0, 18
                        if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                            revert with 0, 17
                        s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                        t = s
                        continue 
                    userInfo[arg1][address(arg3)].field_512 = t
                    if poolInfo[arg1].field_1280 > !t:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
                if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                    revert with 0, 17
                if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
                if arg1 >= poolInfo.length:
                    revert with 0, 50
                if not address(poolInfo[arg1].field_1024):
                    mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(6 * ceil32(return_data.size)) + 164] = this.address
                    mem[(6 * ceil32(return_data.size)) + 196] = arg2
                    mem[(6 * ceil32(return_data.size)) + 96] = 100
                    mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(6 * ceil32(return_data.size)) + 228] = 32
                    mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(6 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                            if not mem[(6 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(6 * ceil32(return_data.size)) + 100] = arg3
                    mem[(6 * ceil32(return_data.size)) + 132] = userInfo[arg1][address(arg3)].field_0
                    require ext_code.size(address(poolInfo[arg1].field_1024))
                    call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args address(arg3), userInfo[arg1][address(arg3)].field_0
                    mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(7 * ceil32(return_data.size)) + 164] = this.address
                    mem[(7 * ceil32(return_data.size)) + 196] = arg2
                    mem[(7 * ceil32(return_data.size)) + 96] = 100
                    mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(7 * ceil32(return_data.size)) + 228] = 32
                    mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(7 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                            if not mem[(7 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            if block.timestamp < poolInfo[arg1].field_512:
                revert with 0, 17
            if block.timestamp - poolInfo[arg1].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[arg1].field_512:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2) and poolInfo[arg1].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2):
                revert with 0, 17
            if not sub_91ea1d68:
                revert with 0, 18
            if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                revert with 0, 17
            if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
                revert with 0, 17
            if not 1000 * ext_call.return_data[0]:
                revert with 0, 18
            if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]):
                revert with 0, 17
            poolInfo[arg1].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]
            if not poolInfo[arg1].field_1280:
                poolInfo[arg1].field_1536 = 0
            else:
                if poolInfo[arg1].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[arg1].field_1280:
                    revert with 0, 18
                if poolInfo[arg1].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280):
                    revert with 0, 17
                poolInfo[arg1].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280
            require ext_code.size(address(poolInfo[arg1].field_0))
            staticcall address(poolInfo[arg1].field_0).0x705727b5 with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                if poolInfo[arg1].field_256 and 833333333333333333 > -1 / poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(833333333333333333 * poolInfo[arg1].field_256):
                    revert with 0, 17
                if sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) < poolInfo[arg1].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) - poolInfo[arg1].field_1792
                poolInfo[arg1].field_1792 = 833333333333333333 * poolInfo[arg1].field_256
                poolInfo[arg1].field_512 = block.timestamp
                mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 160] = poolInfo[arg1].field_768
                emit UpdatePool(block.timestamp, ext_call.return_data[0], poolInfo[arg1].field_768, arg1);
                if not userInfo[arg1][address(arg3)].field_0:
                    if userInfo[arg1][address(arg3)].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_0 += arg2
                    mem[(2 * ceil32(return_data.size)) + 100] = arg3
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args arg3
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][address(arg3)].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                        else:
                            userInfo[arg1][address(arg3)].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][address(arg3)].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
                    if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(4 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(4 * ceil32(return_data.size)) + 164] = this.address
                        mem[(4 * ceil32(return_data.size)) + 196] = arg2
                        mem[(4 * ceil32(return_data.size)) + 96] = 100
                        mem[(4 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(4 * ceil32(return_data.size)) + 228] = 32
                        mem[(4 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(4 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(4 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(4 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(4 * ceil32(return_data.size)) + 324] == bool(mem[(4 * ceil32(return_data.size)) + 324])
                                if not mem[(4 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(4 * ceil32(return_data.size)) + 100] = arg3
                        mem[(4 * ceil32(return_data.size)) + 132] = userInfo[arg1][address(arg3)].field_0
                        require ext_code.size(address(poolInfo[arg1].field_1024))
                        call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args address(arg3), userInfo[arg1][address(arg3)].field_0
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(6 * ceil32(return_data.size)) + 164] = this.address
                        mem[(6 * ceil32(return_data.size)) + 196] = arg2
                        mem[(6 * ceil32(return_data.size)) + 96] = 100
                        mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(6 * ceil32(return_data.size)) + 228] = 32
                        mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(6 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                                if not mem[(6 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    if (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][address(arg3)]:
                        revert with 0, 17
                    if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] < userInfo[arg1][address(arg3)].field_256:
                        revert with 0, 17
                    sub_8b4d83a3[arg1][address(arg3)] = 0
                    mem[(2 * ceil32(return_data.size)) + 100] = this.address
                    require ext_code.size(sub_6af66772Address)
                    staticcall sub_6af66772Address.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'No tokens to distribute'
                    mem[(4 * ceil32(return_data.size)) + 100] = arg3
                    if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256 <= ext_call.return_data[0]:
                        mem[(4 * ceil32(return_data.size)) + 132] = ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                        require ext_code.size(sub_6af66772Address)
                        call sub_6af66772Address.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg3), ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        emit Harvest((((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256), arg3, arg1);
                    else:
                        mem[(4 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
                        require ext_code.size(sub_6af66772Address)
                        call sub_6af66772Address.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg3), ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        emit Harvest(ext_call.return_data[0], arg3, arg1);
                    if userInfo[arg1][address(arg3)].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_0 += arg2
                    mem[(6 * ceil32(return_data.size)) + 100] = arg3
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args arg3
                    mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][address(arg3)].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                        else:
                            userInfo[arg1][address(arg3)].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][address(arg3)].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
                    if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(7 * ceil32(return_data.size)) + 164] = this.address
                        mem[(7 * ceil32(return_data.size)) + 196] = arg2
                        mem[(7 * ceil32(return_data.size)) + 96] = 100
                        mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(7 * ceil32(return_data.size)) + 228] = 32
                        mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(7 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                                if not mem[(7 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(7 * ceil32(return_data.size)) + 100] = arg3
                        mem[(7 * ceil32(return_data.size)) + 132] = userInfo[arg1][address(arg3)].field_0
                        require ext_code.size(address(poolInfo[arg1].field_1024))
                        call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args address(arg3), userInfo[arg1][address(arg3)].field_0
                        mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[(8 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(8 * ceil32(return_data.size)) + 164] = this.address
                        mem[(8 * ceil32(return_data.size)) + 196] = arg2
                        mem[(8 * ceil32(return_data.size)) + 96] = 100
                        mem[(8 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(8 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(8 * ceil32(return_data.size)) + 228] = 32
                        mem[(8 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(8 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(8 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(8 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(8 * ceil32(return_data.size)) + 324] == bool(mem[(8 * ceil32(return_data.size)) + 324])
                                if not mem[(8 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require ext_code.size(address(poolInfo[arg1].field_0))
                staticcall address(poolInfo[arg1].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
                    if poolInfo[arg1].field_256 and 1 > -1 / poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[arg1].field_256 < poolInfo[arg1].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[arg1].field_256 - poolInfo[arg1].field_1792
                    poolInfo[arg1].field_1792 = poolInfo[arg1].field_256
                else:
                    if 1000000000000000000 * 10^18 > !(10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2):
                        revert with 0, 17
                    if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[arg1].field_256 and (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 > -1 / poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17) < poolInfo[arg1].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17) - poolInfo[arg1].field_1792
                    poolInfo[arg1].field_1792 = poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17
                poolInfo[arg1].field_512 = block.timestamp
                mem[(4 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 160] = poolInfo[arg1].field_768
                emit UpdatePool(block.timestamp, ext_call.return_data[0], poolInfo[arg1].field_768, arg1);
                if not userInfo[arg1][address(arg3)].field_0:
                    if userInfo[arg1][address(arg3)].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_0 += arg2
                    mem[(4 * ceil32(return_data.size)) + 100] = arg3
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args arg3
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][address(arg3)].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                        else:
                            userInfo[arg1][address(arg3)].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][address(arg3)].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
                    if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(6 * ceil32(return_data.size)) + 164] = this.address
                        mem[(6 * ceil32(return_data.size)) + 196] = arg2
                        mem[(6 * ceil32(return_data.size)) + 96] = 100
                        mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(6 * ceil32(return_data.size)) + 228] = 32
                        mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(6 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                                if not mem[(6 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(6 * ceil32(return_data.size)) + 100] = arg3
                        mem[(6 * ceil32(return_data.size)) + 132] = userInfo[arg1][address(arg3)].field_0
                        require ext_code.size(address(poolInfo[arg1].field_1024))
                        call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args address(arg3), userInfo[arg1][address(arg3)].field_0
                        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(7 * ceil32(return_data.size)) + 164] = this.address
                        mem[(7 * ceil32(return_data.size)) + 196] = arg2
                        mem[(7 * ceil32(return_data.size)) + 96] = 100
                        mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(7 * ceil32(return_data.size)) + 228] = 32
                        mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(7 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                                if not mem[(7 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    if (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][address(arg3)]:
                        revert with 0, 17
                    if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] < userInfo[arg1][address(arg3)].field_256:
                        revert with 0, 17
                    sub_8b4d83a3[arg1][address(arg3)] = 0
                    mem[(4 * ceil32(return_data.size)) + 100] = this.address
                    require ext_code.size(sub_6af66772Address)
                    staticcall sub_6af66772Address.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'No tokens to distribute'
                    mem[(6 * ceil32(return_data.size)) + 100] = arg3
                    if ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256 <= ext_call.return_data[0]:
                        mem[(6 * ceil32(return_data.size)) + 132] = ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                        require ext_code.size(sub_6af66772Address)
                        call sub_6af66772Address.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg3), ((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256
                        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        emit Harvest((((userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][address(arg3)] - userInfo[arg1][address(arg3)].field_256), arg3, arg1);
                    else:
                        mem[(6 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
                        require ext_code.size(sub_6af66772Address)
                        call sub_6af66772Address.0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg3), ext_call.return_data[0]
                        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        emit Harvest(ext_call.return_data[0], arg3, arg1);
                    if userInfo[arg1][address(arg3)].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_0 += arg2
                    mem[(7 * ceil32(return_data.size)) + 100] = arg3
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args arg3
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][address(arg3)].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][address(arg3)].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][address(arg3)].field_512
                        else:
                            userInfo[arg1][address(arg3)].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][address(arg3)].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][address(arg3)].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][address(arg3)].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][address(arg3)].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][address(arg3)].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][address(arg3)].field_512
                    if userInfo[arg1][address(arg3)].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][address(arg3)].field_512:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg3)].field_0:
                        revert with 0, 17
                    if userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][address(arg3)].field_256 = (userInfo[arg1][address(arg3)].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][address(arg3)].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(8 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(8 * ceil32(return_data.size)) + 164] = this.address
                        mem[(8 * ceil32(return_data.size)) + 196] = arg2
                        mem[(8 * ceil32(return_data.size)) + 96] = 100
                        mem[(8 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(8 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(8 * ceil32(return_data.size)) + 228] = 32
                        mem[(8 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(8 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(8 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(8 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(8 * ceil32(return_data.size)) + 324] == bool(mem[(8 * ceil32(return_data.size)) + 324])
                                if not mem[(8 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(8 * ceil32(return_data.size)) + 100] = arg3
                        mem[(8 * ceil32(return_data.size)) + 132] = userInfo[arg1][address(arg3)].field_0
                        require ext_code.size(address(poolInfo[arg1].field_1024))
                        call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args address(arg3), userInfo[arg1][address(arg3)].field_0
                        mem[(8 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[(10 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(10 * ceil32(return_data.size)) + 164] = this.address
                        mem[(10 * ceil32(return_data.size)) + 196] = arg2
                        mem[(10 * ceil32(return_data.size)) + 96] = 100
                        mem[(10 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(10 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(10 * ceil32(return_data.size)) + 228] = 32
                        mem[(10 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(10 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(10 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(10 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(10 * ceil32(return_data.size)) + 324] == bool(mem[(10 * ceil32(return_data.size)) + 324])
                                if not mem[(10 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    emit 0x16f3fbfd: arg2, arg3, arg1
    stor101 = 1
}

function deposit(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    if stor151:
        revert with 0, 'Pausable: paused'
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if block.timestamp <= poolInfo[arg1].field_512:
        if not userInfo[arg1][msg.sender].field_0:
            if userInfo[arg1][msg.sender].field_0 > !arg2:
                revert with 0, 17
            userInfo[arg1][msg.sender].field_0 += arg2
            mem[100] = msg.sender
            require ext_code.size(sub_82c780a1Address)
            staticcall sub_82c780a1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args msg.sender
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                    userInfo[arg1][msg.sender].field_512 = 0
                    if poolInfo[arg1].field_1280 > -1:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                else:
                    userInfo[arg1][msg.sender].field_512 = 1
                    if poolInfo[arg1].field_1280 > -2:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
            else:
                if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                    revert with 0, 17
                s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                while s < t:
                    if not s:
                        revert with 0, 18
                    if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                        revert with 0, 17
                    s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                    t = s
                    continue 
                userInfo[arg1][msg.sender].field_512 = t
                if poolInfo[arg1].field_1280 > !t:
                    revert with 0, 17
                if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
            if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                revert with 0, 17
            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
            if arg1 >= poolInfo.length:
                revert with 0, 50
            if not address(poolInfo[arg1].field_1024):
                mem[ceil32(return_data.size) + 132] = msg.sender
                mem[ceil32(return_data.size) + 164] = this.address
                mem[ceil32(return_data.size) + 196] = arg2
                mem[ceil32(return_data.size) + 96] = 100
                mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[ceil32(return_data.size) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[ceil32(return_data.size) + 228] = 32
                mem[ceil32(return_data.size) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[ceil32(return_data.size) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                        if not uint32(msg.sender), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[ceil32(return_data.size) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[ceil32(return_data.size) + 324] == bool(mem[ceil32(return_data.size) + 324])
                        if not mem[ceil32(return_data.size) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                emit Deposit(arg2, msg.sender, arg1);
                stor101 = 1
                return 0
            mem[ceil32(return_data.size) + 100] = msg.sender
            mem[ceil32(return_data.size) + 132] = userInfo[arg1][msg.sender].field_0
            require ext_code.size(address(poolInfo[arg1].field_1024))
            call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                 gas gas_remaining wei
                args msg.sender, userInfo[arg1][msg.sender].field_0
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(2 * ceil32(return_data.size)) + 132] = msg.sender
            mem[(2 * ceil32(return_data.size)) + 164] = this.address
            mem[(2 * ceil32(return_data.size)) + 196] = arg2
            mem[(2 * ceil32(return_data.size)) + 96] = 100
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
            mem[(2 * ceil32(return_data.size)) + 228] = 32
            mem[(2 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
            if not ext_code.size(address(poolInfo[arg1].field_0)):
                revert with 0, 'Address: call to non-contract'
            mem[(2 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
            mem[(2 * ceil32(return_data.size)) + 392] = 0
            call address(poolInfo[arg1].field_0) with:
               funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                 gas gas_remaining wei
                args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(msg.sender), mem[132 len 28] == bool(uint32(msg.sender), mem[132 len 28])
                    if not uint32(msg.sender), mem[132 len 28]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[(2 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 324] == bool(mem[(2 * ceil32(return_data.size)) + 324])
                    if not mem[(2 * ceil32(return_data.size)) + 324]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            emit Deposit(arg2, msg.sender, arg1);
            stor101 = 1
            return 0, ext_call.return_data[0]
        if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
            revert with 0, 17
        if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
            revert with 0, 17
        if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
            revert with 0, 17
        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][msg.sender]:
            revert with 0, 17
        if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] < userInfo[arg1][msg.sender].field_256:
            revert with 0, 17
        sub_8b4d83a3[arg1][msg.sender] = 0
        mem[100] = this.address
        require ext_code.size(sub_6af66772Address)
        staticcall sub_6af66772Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            revert with 0, 'No tokens to distribute'
        mem[ceil32(return_data.size) + 100] = msg.sender
        if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
            mem[ceil32(return_data.size) + 132] = ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
            require ext_code.size(sub_6af66772Address)
            call sub_6af66772Address.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            emit Harvest((((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256), msg.sender, arg1);
            if userInfo[arg1][msg.sender].field_0 > !arg2:
                revert with 0, 17
            userInfo[arg1][msg.sender].field_0 += arg2
            mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
            require ext_code.size(sub_82c780a1Address)
            staticcall sub_82c780a1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args msg.sender
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                    userInfo[arg1][msg.sender].field_512 = 0
                    if poolInfo[arg1].field_1280 > -1:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                else:
                    userInfo[arg1][msg.sender].field_512 = 1
                    if poolInfo[arg1].field_1280 > -2:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
            else:
                if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                    revert with 0, 17
                s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                while s < t:
                    if not s:
                        revert with 0, 18
                    if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                        revert with 0, 17
                    s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                    t = s
                    continue 
                userInfo[arg1][msg.sender].field_512 = t
                if poolInfo[arg1].field_1280 > !t:
                    revert with 0, 17
                if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
            if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                revert with 0, 17
            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
            if arg1 >= poolInfo.length:
                revert with 0, 50
            if not address(poolInfo[arg1].field_1024):
                mem[(4 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(4 * ceil32(return_data.size)) + 164] = this.address
                mem[(4 * ceil32(return_data.size)) + 196] = arg2
                mem[(4 * ceil32(return_data.size)) + 96] = 100
                mem[(4 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(4 * ceil32(return_data.size)) + 228] = 32
                mem[(4 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(4 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(4 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(4 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(4 * ceil32(return_data.size)) + 324] == bool(mem[(4 * ceil32(return_data.size)) + 324])
                        if not mem[(4 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                emit Deposit(arg2, msg.sender, arg1);
                stor101 = 1
                return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                       0
            mem[(4 * ceil32(return_data.size)) + 100] = msg.sender
            mem[(4 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
            require ext_code.size(address(poolInfo[arg1].field_1024))
            call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                 gas gas_remaining wei
                args msg.sender, userInfo[arg1][msg.sender].field_0
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
            mem[(6 * ceil32(return_data.size)) + 164] = this.address
            mem[(6 * ceil32(return_data.size)) + 196] = arg2
            mem[(6 * ceil32(return_data.size)) + 96] = 100
            mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
            mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
            mem[(6 * ceil32(return_data.size)) + 228] = 32
            mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
            if not ext_code.size(address(poolInfo[arg1].field_0)):
                revert with 0, 'Address: call to non-contract'
            mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
            mem[(6 * ceil32(return_data.size)) + 392] = 0
            call address(poolInfo[arg1].field_0) with:
               funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                 gas gas_remaining wei
                args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                    if not uint32(this.address), mem[132 len 28]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                    if not mem[(6 * ceil32(return_data.size)) + 324]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            emit Deposit(arg2, msg.sender, arg1);
            stor101 = 1
            return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                   ext_call.return_data[0]
        mem[ceil32(return_data.size) + 132] = ext_call.return_data[0]
        require ext_code.size(sub_6af66772Address)
        call sub_6af66772Address.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, ext_call.return_data[0]
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        emit Harvest(ext_call.return_data[0], msg.sender, arg1);
        if userInfo[arg1][msg.sender].field_0 > !arg2:
            revert with 0, 17
        userInfo[arg1][msg.sender].field_0 += arg2
        mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
        require ext_code.size(sub_82c780a1Address)
        staticcall sub_82c780a1Address.0x70a08231 with:
                gas gas_remaining wei
               args msg.sender
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
            revert with 0, 17
        if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
            if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                userInfo[arg1][msg.sender].field_512 = 0
                if poolInfo[arg1].field_1280 > -1:
                    revert with 0, 17
                if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
            else:
                userInfo[arg1][msg.sender].field_512 = 1
                if poolInfo[arg1].field_1280 > -2:
                    revert with 0, 17
                if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
        else:
            if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                revert with 0, 17
            s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
            t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
            while s < t:
                if not s:
                    revert with 0, 18
                if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                    revert with 0, 17
                s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                t = s
                continue 
            userInfo[arg1][msg.sender].field_512 = t
            if poolInfo[arg1].field_1280 > !t:
                revert with 0, 17
            if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                revert with 0, 17
            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
        if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
            revert with 0, 17
        if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
            revert with 0, 17
        if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
            revert with 0, 17
        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
        if arg1 >= poolInfo.length:
            revert with 0, 50
        if not address(poolInfo[arg1].field_1024):
            mem[(4 * ceil32(return_data.size)) + 132] = msg.sender
            mem[(4 * ceil32(return_data.size)) + 164] = this.address
            mem[(4 * ceil32(return_data.size)) + 196] = arg2
            mem[(4 * ceil32(return_data.size)) + 96] = 100
            mem[(4 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
            mem[(4 * ceil32(return_data.size)) + 228] = 32
            mem[(4 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
            if not ext_code.size(address(poolInfo[arg1].field_0)):
                revert with 0, 'Address: call to non-contract'
            mem[(4 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
            mem[(4 * ceil32(return_data.size)) + 392] = 0
            call address(poolInfo[arg1].field_0) with:
               funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                 gas gas_remaining wei
                args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                    if not uint32(this.address), mem[132 len 28]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[(4 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[(4 * ceil32(return_data.size)) + 324] == bool(mem[(4 * ceil32(return_data.size)) + 324])
                    if not mem[(4 * ceil32(return_data.size)) + 324]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            emit Deposit(arg2, msg.sender, arg1);
            stor101 = 1
            return ext_call.return_data[0], 0
        mem[(4 * ceil32(return_data.size)) + 100] = msg.sender
        mem[(4 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
        require ext_code.size(address(poolInfo[arg1].field_1024))
        call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
             gas gas_remaining wei
            args msg.sender, userInfo[arg1][msg.sender].field_0
        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
        mem[(6 * ceil32(return_data.size)) + 164] = this.address
        mem[(6 * ceil32(return_data.size)) + 196] = arg2
        mem[(6 * ceil32(return_data.size)) + 96] = 100
        mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
        mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
        mem[(6 * ceil32(return_data.size)) + 228] = 32
        mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
        if not ext_code.size(address(poolInfo[arg1].field_0)):
            revert with 0, 'Address: call to non-contract'
        mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
        mem[(6 * ceil32(return_data.size)) + 392] = 0
        call address(poolInfo[arg1].field_0) with:
           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
             gas gas_remaining wei
            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                if not uint32(this.address), mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                if not mem[(6 * ceil32(return_data.size)) + 324]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[100] = this.address
        require ext_code.size(address(poolInfo[arg1].field_0))
        staticcall address(poolInfo[arg1].field_0).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[arg1].field_512 = block.timestamp
            if not userInfo[arg1][msg.sender].field_0:
                if userInfo[arg1][msg.sender].field_0 > !arg2:
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_0 += arg2
                mem[ceil32(return_data.size) + 100] = msg.sender
                require ext_code.size(sub_82c780a1Address)
                staticcall sub_82c780a1Address.0x70a08231 with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                    if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                        userInfo[arg1][msg.sender].field_512 = 0
                        if poolInfo[arg1].field_1280 > -1:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                    else:
                        userInfo[arg1][msg.sender].field_512 = 1
                        if poolInfo[arg1].field_1280 > -2:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                else:
                    if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                        revert with 0, 17
                    s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                    t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                    while s < t:
                        if not s:
                            revert with 0, 18
                        if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                        t = s
                        continue 
                    userInfo[arg1][msg.sender].field_512 = t
                    if poolInfo[arg1].field_1280 > !t:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                if arg1 >= poolInfo.length:
                    revert with 0, 50
                if not address(poolInfo[arg1].field_1024):
                    mem[(2 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(2 * ceil32(return_data.size)) + 164] = this.address
                    mem[(2 * ceil32(return_data.size)) + 196] = arg2
                    mem[(2 * ceil32(return_data.size)) + 96] = 100
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(2 * ceil32(return_data.size)) + 228] = 32
                    mem[(2 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(2 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(2 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(2 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 324] == bool(mem[(2 * ceil32(return_data.size)) + 324])
                            if not mem[(2 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return 0
                mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                mem[(2 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                require ext_code.size(address(poolInfo[arg1].field_1024))
                call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, userInfo[arg1][msg.sender].field_0
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(4 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(4 * ceil32(return_data.size)) + 164] = this.address
                mem[(4 * ceil32(return_data.size)) + 196] = arg2
                mem[(4 * ceil32(return_data.size)) + 96] = 100
                mem[(4 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(4 * ceil32(return_data.size)) + 228] = 32
                mem[(4 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(4 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(4 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(4 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(4 * ceil32(return_data.size)) + 324] == bool(mem[(4 * ceil32(return_data.size)) + 324])
                        if not mem[(4 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                emit Deposit(arg2, msg.sender, arg1);
                stor101 = 1
                return 0, ext_call.return_data[0]
            if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                revert with 0, 17
            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][msg.sender]:
                revert with 0, 17
            if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] < userInfo[arg1][msg.sender].field_256:
                revert with 0, 17
            sub_8b4d83a3[arg1][msg.sender] = 0
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(sub_6af66772Address)
            staticcall sub_6af66772Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= 0:
                revert with 0, 'No tokens to distribute'
            mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
            if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + 132] = ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                emit Harvest((((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256), msg.sender, arg1);
                if userInfo[arg1][msg.sender].field_0 > !arg2:
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_0 += arg2
                mem[(4 * ceil32(return_data.size)) + 100] = msg.sender
                require ext_code.size(sub_82c780a1Address)
                staticcall sub_82c780a1Address.0x70a08231 with:
                        gas gas_remaining wei
                       args msg.sender
                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                    if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                        userInfo[arg1][msg.sender].field_512 = 0
                        if poolInfo[arg1].field_1280 > -1:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                    else:
                        userInfo[arg1][msg.sender].field_512 = 1
                        if poolInfo[arg1].field_1280 > -2:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                else:
                    if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                        revert with 0, 17
                    s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                    t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                    while s < t:
                        if not s:
                            revert with 0, 18
                        if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                        t = s
                        continue 
                    userInfo[arg1][msg.sender].field_512 = t
                    if poolInfo[arg1].field_1280 > !t:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                if arg1 >= poolInfo.length:
                    revert with 0, 50
                if not address(poolInfo[arg1].field_1024):
                    mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(6 * ceil32(return_data.size)) + 164] = this.address
                    mem[(6 * ceil32(return_data.size)) + 196] = arg2
                    mem[(6 * ceil32(return_data.size)) + 96] = 100
                    mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(6 * ceil32(return_data.size)) + 228] = 32
                    mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(6 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                            if not mem[(6 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                           0
                mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
                mem[(6 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                require ext_code.size(address(poolInfo[arg1].field_1024))
                call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, userInfo[arg1][msg.sender].field_0
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(7 * ceil32(return_data.size)) + 164] = this.address
                mem[(7 * ceil32(return_data.size)) + 196] = arg2
                mem[(7 * ceil32(return_data.size)) + 96] = 100
                mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(7 * ceil32(return_data.size)) + 228] = 32
                mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(7 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                        if not mem[(7 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                emit Deposit(arg2, msg.sender, arg1);
                stor101 = 1
                return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                       ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
            require ext_code.size(sub_6af66772Address)
            call sub_6af66772Address.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            emit Harvest(ext_call.return_data[0], msg.sender, arg1);
            if userInfo[arg1][msg.sender].field_0 > !arg2:
                revert with 0, 17
            userInfo[arg1][msg.sender].field_0 += arg2
            mem[(4 * ceil32(return_data.size)) + 100] = msg.sender
            require ext_code.size(sub_82c780a1Address)
            staticcall sub_82c780a1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args msg.sender
            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                    userInfo[arg1][msg.sender].field_512 = 0
                    if poolInfo[arg1].field_1280 > -1:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                else:
                    userInfo[arg1][msg.sender].field_512 = 1
                    if poolInfo[arg1].field_1280 > -2:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
            else:
                if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                    revert with 0, 17
                s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                while s < t:
                    if not s:
                        revert with 0, 18
                    if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                        revert with 0, 17
                    s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                    t = s
                    continue 
                userInfo[arg1][msg.sender].field_512 = t
                if poolInfo[arg1].field_1280 > !t:
                    revert with 0, 17
                if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
            if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                revert with 0, 17
            if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                revert with 0, 17
            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
            if arg1 >= poolInfo.length:
                revert with 0, 50
            if not address(poolInfo[arg1].field_1024):
                mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(6 * ceil32(return_data.size)) + 164] = this.address
                mem[(6 * ceil32(return_data.size)) + 196] = arg2
                mem[(6 * ceil32(return_data.size)) + 96] = 100
                mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(6 * ceil32(return_data.size)) + 228] = 32
                mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(6 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                        if not mem[(6 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                emit Deposit(arg2, msg.sender, arg1);
                stor101 = 1
                return ext_call.return_data[0], 0
            mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
            mem[(6 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
            require ext_code.size(address(poolInfo[arg1].field_1024))
            call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                 gas gas_remaining wei
                args msg.sender, userInfo[arg1][msg.sender].field_0
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
            mem[(7 * ceil32(return_data.size)) + 164] = this.address
            mem[(7 * ceil32(return_data.size)) + 196] = arg2
            mem[(7 * ceil32(return_data.size)) + 96] = 100
            mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
            mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
            mem[(7 * ceil32(return_data.size)) + 228] = 32
            mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
            if not ext_code.size(address(poolInfo[arg1].field_0)):
                revert with 0, 'Address: call to non-contract'
            mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
            mem[(7 * ceil32(return_data.size)) + 392] = 0
            call address(poolInfo[arg1].field_0) with:
               funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                 gas gas_remaining wei
                args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                    if not uint32(this.address), mem[132 len 28]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                    if not mem[(7 * ceil32(return_data.size)) + 324]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            if block.timestamp < poolInfo[arg1].field_512:
                revert with 0, 17
            if block.timestamp - poolInfo[arg1].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[arg1].field_512:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2) and poolInfo[arg1].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[arg1].field_512 * sub_9702d3e2):
                revert with 0, 17
            if not sub_91ea1d68:
                revert with 0, 18
            if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                revert with 0, 17
            if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
                revert with 0, 17
            if not 1000 * ext_call.return_data[0]:
                revert with 0, 18
            if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]):
                revert with 0, 17
            poolInfo[arg1].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * ext_call.return_data[0]
            if not poolInfo[arg1].field_1280:
                poolInfo[arg1].field_1536 = 0
            else:
                if poolInfo[arg1].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[arg1].field_1280:
                    revert with 0, 18
                if poolInfo[arg1].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280):
                    revert with 0, 17
                poolInfo[arg1].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[arg1].field_1792) - (poolInfo[arg1].field_512 * sub_9702d3e2 * poolInfo[arg1].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[arg1].field_1280
            require ext_code.size(address(poolInfo[arg1].field_0))
            staticcall address(poolInfo[arg1].field_0).0x705727b5 with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                if poolInfo[arg1].field_256 and 833333333333333333 > -1 / poolInfo[arg1].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(833333333333333333 * poolInfo[arg1].field_256):
                    revert with 0, 17
                if sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) < poolInfo[arg1].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[arg1].field_256) - poolInfo[arg1].field_1792
                poolInfo[arg1].field_1792 = 833333333333333333 * poolInfo[arg1].field_256
                poolInfo[arg1].field_512 = block.timestamp
                mem[(2 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 160] = poolInfo[arg1].field_768
                emit UpdatePool(block.timestamp, ext_call.return_data[0], poolInfo[arg1].field_768, arg1);
                if not userInfo[arg1][msg.sender].field_0:
                    if userInfo[arg1][msg.sender].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_0 += arg2
                    mem[(2 * ceil32(return_data.size)) + 100] = msg.sender
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][msg.sender].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                        else:
                            userInfo[arg1][msg.sender].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][msg.sender].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                    if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(4 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(4 * ceil32(return_data.size)) + 164] = this.address
                        mem[(4 * ceil32(return_data.size)) + 196] = arg2
                        mem[(4 * ceil32(return_data.size)) + 96] = 100
                        mem[(4 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(4 * ceil32(return_data.size)) + 228] = 32
                        mem[(4 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(4 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(4 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(4 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(4 * ceil32(return_data.size)) + 324] == bool(mem[(4 * ceil32(return_data.size)) + 324])
                                if not mem[(4 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        emit Deposit(arg2, msg.sender, arg1);
                        stor101 = 1
                        return 0
                    mem[(4 * ceil32(return_data.size)) + 100] = msg.sender
                    mem[(4 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                    require ext_code.size(address(poolInfo[arg1].field_1024))
                    call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, userInfo[arg1][msg.sender].field_0
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(6 * ceil32(return_data.size)) + 164] = this.address
                    mem[(6 * ceil32(return_data.size)) + 196] = arg2
                    mem[(6 * ceil32(return_data.size)) + 96] = 100
                    mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(6 * ceil32(return_data.size)) + 228] = 32
                    mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(6 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                            if not mem[(6 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return 0, ext_call.return_data[0]
                if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][msg.sender]:
                    revert with 0, 17
                if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] < userInfo[arg1][msg.sender].field_256:
                    revert with 0, 17
                sub_8b4d83a3[arg1][msg.sender] = 0
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(sub_6af66772Address)
                staticcall sub_6af66772Address.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'No tokens to distribute'
                mem[(4 * ceil32(return_data.size)) + 100] = msg.sender
                if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                    mem[(4 * ceil32(return_data.size)) + 132] = ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
                    require ext_code.size(sub_6af66772Address)
                    call sub_6af66772Address.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    emit Harvest((((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256), msg.sender, arg1);
                    if userInfo[arg1][msg.sender].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_0 += arg2
                    mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][msg.sender].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                        else:
                            userInfo[arg1][msg.sender].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][msg.sender].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                    if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(7 * ceil32(return_data.size)) + 164] = this.address
                        mem[(7 * ceil32(return_data.size)) + 196] = arg2
                        mem[(7 * ceil32(return_data.size)) + 96] = 100
                        mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(7 * ceil32(return_data.size)) + 228] = 32
                        mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(7 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                                if not mem[(7 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        emit Deposit(arg2, msg.sender, arg1);
                        stor101 = 1
                        return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                               0
                    mem[(7 * ceil32(return_data.size)) + 100] = msg.sender
                    mem[(7 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                    require ext_code.size(address(poolInfo[arg1].field_1024))
                    call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, userInfo[arg1][msg.sender].field_0
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(8 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(8 * ceil32(return_data.size)) + 164] = this.address
                    mem[(8 * ceil32(return_data.size)) + 196] = arg2
                    mem[(8 * ceil32(return_data.size)) + 96] = 100
                    mem[(8 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(8 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(8 * ceil32(return_data.size)) + 228] = 32
                    mem[(8 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(8 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(8 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(8 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(8 * ceil32(return_data.size)) + 324] == bool(mem[(8 * ceil32(return_data.size)) + 324])
                            if not mem[(8 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                           ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                emit Harvest(ext_call.return_data[0], msg.sender, arg1);
                if userInfo[arg1][msg.sender].field_0 > !arg2:
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_0 += arg2
                mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
                require ext_code.size(sub_82c780a1Address)
                staticcall sub_82c780a1Address.0x70a08231 with:
                        gas gas_remaining wei
                       args msg.sender
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                    if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                        userInfo[arg1][msg.sender].field_512 = 0
                        if poolInfo[arg1].field_1280 > -1:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                    else:
                        userInfo[arg1][msg.sender].field_512 = 1
                        if poolInfo[arg1].field_1280 > -2:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                else:
                    if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                        revert with 0, 17
                    s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                    t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                    while s < t:
                        if not s:
                            revert with 0, 18
                        if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                        t = s
                        continue 
                    userInfo[arg1][msg.sender].field_512 = t
                    if poolInfo[arg1].field_1280 > !t:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                if arg1 >= poolInfo.length:
                    revert with 0, 50
                if not address(poolInfo[arg1].field_1024):
                    mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(7 * ceil32(return_data.size)) + 164] = this.address
                    mem[(7 * ceil32(return_data.size)) + 196] = arg2
                    mem[(7 * ceil32(return_data.size)) + 96] = 100
                    mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(7 * ceil32(return_data.size)) + 228] = 32
                    mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(7 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                            if not mem[(7 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return ext_call.return_data[0], 0
                mem[(7 * ceil32(return_data.size)) + 100] = msg.sender
                mem[(7 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                require ext_code.size(address(poolInfo[arg1].field_1024))
                call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, userInfo[arg1][msg.sender].field_0
                mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(8 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(8 * ceil32(return_data.size)) + 164] = this.address
                mem[(8 * ceil32(return_data.size)) + 196] = arg2
                mem[(8 * ceil32(return_data.size)) + 96] = 100
                mem[(8 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(8 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(8 * ceil32(return_data.size)) + 228] = 32
                mem[(8 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(8 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(8 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(8 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(8 * ceil32(return_data.size)) + 324] == bool(mem[(8 * ceil32(return_data.size)) + 324])
                        if not mem[(8 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                require ext_code.size(address(poolInfo[arg1].field_0))
                staticcall address(poolInfo[arg1].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
                    if poolInfo[arg1].field_256 and 1 > -1 / poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[arg1].field_256 < poolInfo[arg1].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[arg1].field_256 - poolInfo[arg1].field_1792
                    poolInfo[arg1].field_1792 = poolInfo[arg1].field_256
                else:
                    if 1000000000000000000 * 10^18 > !(10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2):
                        revert with 0, 17
                    if not 10^18 * ext_call.return_data[0] / ext_call.return_data[0]:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[arg1].field_256 and (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 > -1 / poolInfo[arg1].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17) < poolInfo[arg1].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17) - poolInfo[arg1].field_1792
                    poolInfo[arg1].field_1792 = poolInfo[arg1].field_256 * (((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * ext_call.return_data[0] / ext_call.return_data[0] / 2) + 1000000000000000000 * 10^18 / 10^18 * ext_call.return_data[0] / ext_call.return_data[0]) + 2 * 10^17
                poolInfo[arg1].field_512 = block.timestamp
                mem[(4 * ceil32(return_data.size)) + 128] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 160] = poolInfo[arg1].field_768
                emit UpdatePool(block.timestamp, ext_call.return_data[0], poolInfo[arg1].field_768, arg1);
                if not userInfo[arg1][msg.sender].field_0:
                    if userInfo[arg1][msg.sender].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_0 += arg2
                    mem[(4 * ceil32(return_data.size)) + 100] = msg.sender
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][msg.sender].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                        else:
                            userInfo[arg1][msg.sender].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][msg.sender].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                    if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(6 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(6 * ceil32(return_data.size)) + 164] = this.address
                        mem[(6 * ceil32(return_data.size)) + 196] = arg2
                        mem[(6 * ceil32(return_data.size)) + 96] = 100
                        mem[(6 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(6 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(6 * ceil32(return_data.size)) + 228] = 32
                        mem[(6 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(6 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(6 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(6 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(6 * ceil32(return_data.size)) + 324] == bool(mem[(6 * ceil32(return_data.size)) + 324])
                                if not mem[(6 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        emit Deposit(arg2, msg.sender, arg1);
                        stor101 = 1
                        return 0
                    mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
                    mem[(6 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                    require ext_code.size(address(poolInfo[arg1].field_1024))
                    call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, userInfo[arg1][msg.sender].field_0
                    mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(7 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(7 * ceil32(return_data.size)) + 164] = this.address
                    mem[(7 * ceil32(return_data.size)) + 196] = arg2
                    mem[(7 * ceil32(return_data.size)) + 96] = 100
                    mem[(7 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(7 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(7 * ceil32(return_data.size)) + 228] = 32
                    mem[(7 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(7 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(7 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(7 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(7 * ceil32(return_data.size)) + 324] == bool(mem[(7 * ceil32(return_data.size)) + 324])
                            if not mem[(7 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return 0, ext_call.return_data[0]
                if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12 > !sub_8b4d83a3[arg1][msg.sender]:
                    revert with 0, 17
                if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] < userInfo[arg1][msg.sender].field_256:
                    revert with 0, 17
                sub_8b4d83a3[arg1][msg.sender] = 0
                mem[(4 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(sub_6af66772Address)
                staticcall sub_6af66772Address.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'No tokens to distribute'
                mem[(6 * ceil32(return_data.size)) + 100] = msg.sender
                if ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                    mem[(6 * ceil32(return_data.size)) + 132] = ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
                    require ext_code.size(sub_6af66772Address)
                    call sub_6af66772Address.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256
                    mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    emit Harvest((((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256), msg.sender, arg1);
                    if userInfo[arg1][msg.sender].field_0 > !arg2:
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_0 += arg2
                    mem[(7 * ceil32(return_data.size)) + 100] = msg.sender
                    require ext_code.size(sub_82c780a1Address)
                    staticcall sub_82c780a1Address.0x70a08231 with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                        if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                            userInfo[arg1][msg.sender].field_512 = 0
                            if poolInfo[arg1].field_1280 > -1:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                        else:
                            userInfo[arg1][msg.sender].field_512 = 1
                            if poolInfo[arg1].field_1280 > -2:
                                revert with 0, 17
                            if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                    else:
                        if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                        t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                        while s < t:
                            if not s:
                                revert with 0, 18
                            if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                                revert with 0, 17
                            s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                            t = s
                            continue 
                        userInfo[arg1][msg.sender].field_512 = t
                        if poolInfo[arg1].field_1280 > !t:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                    if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                        revert with 0, 17
                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                    if arg1 >= poolInfo.length:
                        revert with 0, 50
                    if not address(poolInfo[arg1].field_1024):
                        mem[(8 * ceil32(return_data.size)) + 132] = msg.sender
                        mem[(8 * ceil32(return_data.size)) + 164] = this.address
                        mem[(8 * ceil32(return_data.size)) + 196] = arg2
                        mem[(8 * ceil32(return_data.size)) + 96] = 100
                        mem[(8 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                        mem[(8 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                        mem[(8 * ceil32(return_data.size)) + 228] = 32
                        mem[(8 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                        if not ext_code.size(address(poolInfo[arg1].field_0)):
                            revert with 0, 'Address: call to non-contract'
                        mem[(8 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                        mem[(8 * ceil32(return_data.size)) + 392] = 0
                        call address(poolInfo[arg1].field_0) with:
                           funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                             gas gas_remaining wei
                            args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                        if not return_data.size:
                            if not ext_call.success:
                                if ext_call.return_data[0]:
                                    revert with memory
                                      from 128
                                       len ext_call.return_data[0]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                                if not uint32(this.address), mem[132 len 28]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[(8 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[(8 * ceil32(return_data.size)) + 324] == bool(mem[(8 * ceil32(return_data.size)) + 324])
                                if not mem[(8 * ceil32(return_data.size)) + 324]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        emit Deposit(arg2, msg.sender, arg1);
                        stor101 = 1
                        return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                               0
                    mem[(8 * ceil32(return_data.size)) + 100] = msg.sender
                    mem[(8 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                    require ext_code.size(address(poolInfo[arg1].field_1024))
                    call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, userInfo[arg1][msg.sender].field_0
                    mem[(8 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(10 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(10 * ceil32(return_data.size)) + 164] = this.address
                    mem[(10 * ceil32(return_data.size)) + 196] = arg2
                    mem[(10 * ceil32(return_data.size)) + 96] = 100
                    mem[(10 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(10 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(10 * ceil32(return_data.size)) + 228] = 32
                    mem[(10 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(10 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(10 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(10 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(10 * ceil32(return_data.size)) + 324] == bool(mem[(10 * ceil32(return_data.size)) + 324])
                            if not mem[(10 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return ((userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12) + sub_8b4d83a3[arg1][msg.sender] - userInfo[arg1][msg.sender].field_256, 
                           ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + 132] = ext_call.return_data[0]
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                emit Harvest(ext_call.return_data[0], msg.sender, arg1);
                if userInfo[arg1][msg.sender].field_0 > !arg2:
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_0 += arg2
                mem[(7 * ceil32(return_data.size)) + 100] = msg.sender
                require ext_code.size(sub_82c780a1Address)
                staticcall sub_82c780a1Address.0x70a08231 with:
                        gas gas_remaining wei
                       args msg.sender
                mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if userInfo[arg1][msg.sender].field_0 and ext_call.return_data[0] > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] <= 3:
                    if not userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]:
                        userInfo[arg1][msg.sender].field_512 = 0
                        if poolInfo[arg1].field_1280 > -1:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 -= userInfo[arg1][msg.sender].field_512
                    else:
                        userInfo[arg1][msg.sender].field_512 = 1
                        if poolInfo[arg1].field_1280 > -2:
                            revert with 0, 17
                        if poolInfo[arg1].field_1280 + 1 < userInfo[arg1][msg.sender].field_512:
                            revert with 0, 17
                        poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + -userInfo[arg1][msg.sender].field_512 + 1
                else:
                    if 1 > !(userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2):
                        revert with 0, 17
                    s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / 2) + 1
                    t = userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0]
                    while s < t:
                        if not s:
                            revert with 0, 18
                        if userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s > !s:
                            revert with 0, 17
                        s = (userInfo[arg1][msg.sender].field_0 * ext_call.return_data[0] / s) + s / 2
                        t = s
                        continue 
                    userInfo[arg1][msg.sender].field_512 = t
                    if poolInfo[arg1].field_1280 > !t:
                        revert with 0, 17
                    if poolInfo[arg1].field_1280 + t < userInfo[arg1][msg.sender].field_512:
                        revert with 0, 17
                    poolInfo[arg1].field_1280 = poolInfo[arg1].field_1280 + t - userInfo[arg1][msg.sender].field_512
                if userInfo[arg1][msg.sender].field_512 and poolInfo[arg1].field_1536 > -1 / userInfo[arg1][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768 > !(userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536):
                    revert with 0, 17
                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_512 * poolInfo[arg1].field_1536) / 10^12
                if arg1 >= poolInfo.length:
                    revert with 0, 50
                if not address(poolInfo[arg1].field_1024):
                    mem[(8 * ceil32(return_data.size)) + 132] = msg.sender
                    mem[(8 * ceil32(return_data.size)) + 164] = this.address
                    mem[(8 * ceil32(return_data.size)) + 196] = arg2
                    mem[(8 * ceil32(return_data.size)) + 96] = 100
                    mem[(8 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[(8 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                    mem[(8 * ceil32(return_data.size)) + 228] = 32
                    mem[(8 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                    if not ext_code.size(address(poolInfo[arg1].field_0)):
                        revert with 0, 'Address: call to non-contract'
                    mem[(8 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                    mem[(8 * ceil32(return_data.size)) + 392] = 0
                    call address(poolInfo[arg1].field_0) with:
                       funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                    if not return_data.size:
                        if not ext_call.success:
                            if ext_call.return_data[0]:
                                revert with memory
                                  from 128
                                   len ext_call.return_data[0]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                            if not uint32(this.address), mem[132 len 28]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[(8 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[(8 * ceil32(return_data.size)) + 324] == bool(mem[(8 * ceil32(return_data.size)) + 324])
                            if not mem[(8 * ceil32(return_data.size)) + 324]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    emit Deposit(arg2, msg.sender, arg1);
                    stor101 = 1
                    return ext_call.return_data[0], 0
                mem[(8 * ceil32(return_data.size)) + 100] = msg.sender
                mem[(8 * ceil32(return_data.size)) + 132] = userInfo[arg1][msg.sender].field_0
                require ext_code.size(address(poolInfo[arg1].field_1024))
                call address(poolInfo[arg1].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, userInfo[arg1][msg.sender].field_0
                mem[(8 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(10 * ceil32(return_data.size)) + 132] = msg.sender
                mem[(10 * ceil32(return_data.size)) + 164] = this.address
                mem[(10 * ceil32(return_data.size)) + 196] = arg2
                mem[(10 * ceil32(return_data.size)) + 96] = 100
                mem[(10 * ceil32(return_data.size)) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[(10 * ceil32(return_data.size)) + 128 len 4] = unknown_0x23b872dd(?????)
                mem[(10 * ceil32(return_data.size)) + 228] = 32
                mem[(10 * ceil32(return_data.size)) + 260] = 'SafeERC20: low-level call failed'
                if not ext_code.size(address(poolInfo[arg1].field_0)):
                    revert with 0, 'Address: call to non-contract'
                mem[(10 * ceil32(return_data.size)) + 292 len 128] = unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0
                mem[(10 * ceil32(return_data.size)) + 392] = 0
                call address(poolInfo[arg1].field_0) with:
                   funct Mask(32, 224, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(768, -544, unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2, 0) << 544)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
                        if not uint32(this.address), mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[(10 * ceil32(return_data.size)) + 324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(10 * ceil32(return_data.size)) + 324] == bool(mem[(10 * ceil32(return_data.size)) + 324])
                        if not mem[(10 * ceil32(return_data.size)) + 324]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    emit Deposit(arg2, msg.sender, arg1);
    stor101 = 1
    return ext_call.return_data[0], ext_call.return_data[0]
}

function multiClaim(uint256[] arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    s = 128
    idx = arg1 + 36
    while idx < arg1 + (32 * arg1.length) + 36:
        mem[s] = cd[idx]
        s = s + 32
        idx = idx + 32
        continue 
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    if stor151:
        revert with 0, 'Pausable: paused'
    if arg1.length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg1.length) + 97] = arg1.length
    if not arg1.length:
        if arg1.length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129] = arg1.length
        mem[64] = ceil32(32 * arg1.length) + (64 * arg1.length) + 161
        if not arg1.length:
            idx = 0
            s = 0
            while idx < arg1.length:
                if idx >= mem[96]:
                    revert with 0, 50
                _2056 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                mem[0] = 209
                if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2090 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2116 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2153 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2090].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2116][msg.sender]
                        require ext_code.size(address(poolInfo[_2090].field_1024))
                        call address(poolInfo[_2090].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2116][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2522 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2522]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2116][msg.sender] * poolInfo[_2090].field_768) + (stor2[('map', 'msg.sender', ('var', '_2116'))] * poolInfo[_2090].field_1536) / 10^12) + stor[_2153][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2116'))]
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[_2056].field_0))
                staticcall address(poolInfo[_2056].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2091 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2118 = mem[_2091]
                if not mem[_2091]:
                    poolInfo[_2056].field_512 = block.timestamp
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2176 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2195 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2211 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2176].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2195][msg.sender]
                        require ext_code.size(address(poolInfo[_2176].field_1024))
                        call address(poolInfo[_2176].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2195][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2554 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2554]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2195][msg.sender] * poolInfo[_2176].field_768) + (stor2[('map', 'msg.sender', ('var', '_2195'))] * poolInfo[_2176].field_1536) / 10^12) + stor[_2211][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2195'))]
                    continue 
                if block.timestamp < poolInfo[_2056].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[_2056].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_2056].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[_2056].field_512 * sub_9702d3e2) and poolInfo[_2056].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_2056].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_2091] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_2091]:
                    revert with 0, 18
                if poolInfo[_2056].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2091]):
                    revert with 0, 17
                poolInfo[_2056].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2091]
                if not poolInfo[_2056].field_1280:
                    poolInfo[_2056].field_1536 = 0
                    require ext_code.size(address(poolInfo[_2056].field_0))
                    staticcall address(poolInfo[_2056].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2494 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2502 = mem[_2494]
                    if not mem[_2494]:
                        if poolInfo[_2056].field_256 and 833333333333333333 > -1 / poolInfo[_2056].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2056].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[_2056].field_256) < poolInfo[_2056].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2056].field_256) - poolInfo[_2056].field_1792
                        poolInfo[_2056].field_1792 = 833333333333333333 * poolInfo[_2056].field_256
                        poolInfo[_2056].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _2118
                        mem[mem[64] + 64] = poolInfo[_2056].field_768
                        emit UpdatePool(block.timestamp, _2118, poolInfo[_2056].field_768, _2056);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2714 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2727 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2759 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg1.length) + 97]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if address(poolInfo[_2714].field_1024):
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor[_2727][msg.sender]
                            require ext_code.size(address(poolInfo[_2714].field_1024))
                            call address(poolInfo[_2714].field_1024).0xe26bdbfe with:
                                 gas gas_remaining wei
                                args msg.sender, stor[_2727][msg.sender]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3050 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                                revert with 0, 50
                            mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3050]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_2727][msg.sender] * poolInfo[_2714].field_768) + (stor2[('map', 'msg.sender', ('var', '_2727'))] * poolInfo[_2714].field_1536) / 10^12) + stor[_2759][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2727'))]
                        continue 
                    require ext_code.size(address(poolInfo[_2056].field_0))
                    staticcall address(poolInfo[_2056].field_0).0x961be391 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2526 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_2526] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not _2502:
                        revert with 0, 18
                    if not 10^18 * mem[_2526] / _2502:
                        if poolInfo[_2056].field_256 and 1 > -1 / poolInfo[_2056].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !poolInfo[_2056].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 + poolInfo[_2056].field_256 < poolInfo[_2056].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2056].field_256 - poolInfo[_2056].field_1792
                        poolInfo[_2056].field_1792 = poolInfo[_2056].field_256
                        poolInfo[_2056].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _2118
                        mem[mem[64] + 64] = poolInfo[_2056].field_768
                        emit UpdatePool(block.timestamp, _2118, poolInfo[_2056].field_768, _2056);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2610 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2623 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2639 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg1.length) + 97]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if address(poolInfo[_2610].field_1024):
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor[_2623][msg.sender]
                            require ext_code.size(address(poolInfo[_2610].field_1024))
                            call address(poolInfo[_2610].field_1024).0xe26bdbfe with:
                                 gas gas_remaining wei
                                args msg.sender, stor[_2623][msg.sender]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2903 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                                revert with 0, 50
                            mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2903]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_2623][msg.sender] * poolInfo[_2610].field_768) + (stor2[('map', 'msg.sender', ('var', '_2623'))] * poolInfo[_2610].field_1536) / 10^12) + stor[_2639][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2623'))]
                        continue 
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_2526] / _2502 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_2526] / _2502:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[_2056].field_256 and (((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17 > -1 / poolInfo[_2056].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[_2056].field_256 * (((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[_2056].field_256 * (((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17) < poolInfo[_2056].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2056].field_256 * (((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17) - poolInfo[_2056].field_1792
                    poolInfo[_2056].field_1792 = poolInfo[_2056].field_256 * (((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2526] / _2502 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2526] / _2502) + 2 * 10^17
                    poolInfo[_2056].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _2118
                    mem[mem[64] + 64] = poolInfo[_2056].field_768
                    emit UpdatePool(block.timestamp, _2118, poolInfo[_2056].field_768, _2056);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2782 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2797 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2824 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2782].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2797][msg.sender]
                        require ext_code.size(address(poolInfo[_2782].field_1024))
                        call address(poolInfo[_2782].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2797][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3091 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3091]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2797][msg.sender] * poolInfo[_2782].field_768) + (stor2[('map', 'msg.sender', ('var', '_2797'))] * poolInfo[_2782].field_1536) / 10^12) + stor[_2824][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2797'))]
                    continue 
                if poolInfo[_2056].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[_2056].field_1280:
                    revert with 0, 18
                if poolInfo[_2056].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2056].field_1280):
                    revert with 0, 17
                poolInfo[_2056].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2056].field_1792) - (poolInfo[_2056].field_512 * sub_9702d3e2 * poolInfo[_2056].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2056].field_1280
                require ext_code.size(address(poolInfo[_2056].field_0))
                staticcall address(poolInfo[_2056].field_0).0x705727b5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2574 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2578 = mem[_2574]
                if not mem[_2574]:
                    if poolInfo[_2056].field_256 and 833333333333333333 > -1 / poolInfo[_2056].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2056].field_256):
                        revert with 0, 17
                    if sub_91ea1d68 + (833333333333333333 * poolInfo[_2056].field_256) < poolInfo[_2056].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2056].field_256) - poolInfo[_2056].field_1792
                    poolInfo[_2056].field_1792 = 833333333333333333 * poolInfo[_2056].field_256
                    poolInfo[_2056].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _2118
                    mem[mem[64] + 64] = poolInfo[_2056].field_768
                    emit UpdatePool(block.timestamp, _2118, poolInfo[_2056].field_768, _2056);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2822 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2847 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2883 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2822].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2847][msg.sender]
                        require ext_code.size(address(poolInfo[_2822].field_1024))
                        call address(poolInfo[_2822].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2847][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3114 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3114]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2847][msg.sender] * poolInfo[_2822].field_768) + (stor2[('map', 'msg.sender', ('var', '_2847'))] * poolInfo[_2822].field_1536) / 10^12) + stor[_2883][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2847'))]
                    continue 
                require ext_code.size(address(poolInfo[_2056].field_0))
                staticcall address(poolInfo[_2056].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2590 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_2590] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _2578:
                    revert with 0, 18
                if not 10^18 * mem[_2590] / _2578:
                    if poolInfo[_2056].field_256 and 1 > -1 / poolInfo[_2056].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[_2056].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[_2056].field_256 < poolInfo[_2056].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2056].field_256 - poolInfo[_2056].field_1792
                    poolInfo[_2056].field_1792 = poolInfo[_2056].field_256
                    poolInfo[_2056].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _2118
                    mem[mem[64] + 64] = poolInfo[_2056].field_768
                    emit UpdatePool(block.timestamp, _2118, poolInfo[_2056].field_768, _2056);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2662 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2675 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2699 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2662].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2675][msg.sender]
                        require ext_code.size(address(poolInfo[_2662].field_1024))
                        call address(poolInfo[_2662].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2675][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3011 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3011]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2675][msg.sender] * poolInfo[_2662].field_768) + (stor2[('map', 'msg.sender', ('var', '_2675'))] * poolInfo[_2662].field_1536) / 10^12) + stor[_2699][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2675'))]
                    continue 
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_2590] / _2578 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_2590] / _2578:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[_2056].field_256 and (((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17 > -1 / poolInfo[_2056].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[_2056].field_256 * (((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[_2056].field_256 * (((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17) < poolInfo[_2056].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2056].field_256 * (((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17) - poolInfo[_2056].field_1792
                poolInfo[_2056].field_1792 = poolInfo[_2056].field_256 * (((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2590] / _2578 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2590] / _2578) + 2 * 10^17
                poolInfo[_2056].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2118
                mem[mem[64] + 64] = poolInfo[_2056].field_768
                emit UpdatePool(block.timestamp, _2118, poolInfo[_2056].field_768, _2056);
                if idx >= mem[96]:
                    revert with 0, 50
                _2942 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2955 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2971 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2942].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2955][msg.sender]
                    require ext_code.size(address(poolInfo[_2942].field_1024))
                    call address(poolInfo[_2942].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2955][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3138 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3138]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2955][msg.sender] * poolInfo[_2942].field_768) + (stor2[('map', 'msg.sender', ('var', '_2955'))] * poolInfo[_2942].field_1536) / 10^12) + stor[_2971][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2955'))]
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(sub_6af66772Address)
            staticcall sub_6af66772Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2066 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2082 = mem[_2066]
            if mem[_2066] <= 0:
                revert with 0, 'No tokens to distribute'
            mem[mem[64] + 4] = msg.sender
            if s <= mem[_2066]:
                mem[mem[64] + 36] = s
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, s
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2150 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_2150] == bool(mem[_2150])
                if s == s:
                    _3150 = mem[96]
                    idx = 0
                    while idx < _3150:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _3182 = mem[(32 * idx) + 128]
                        if idx >= mem[ceil32(32 * arg1.length) + 97]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                        emit Harvest(mem[mem[64]], msg.sender, _3182);
                        if idx == -1:
                            revert with 0, 17
                        _3150 = mem[96]
                        idx = idx + 1
                        continue 
                    stor101 = 1
                    _3222 = mem[64]
                    mem[mem[64]] = s
                    mem[mem[64] + 32] = 96
                    _3246 = mem[ceil32(32 * arg1.length) + 97]
                    mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
                    mem[mem[64] + 128 len 32 * _3246] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3246]
                    var55001 = _3246
                    mem[mem[64] + 64] = (32 * _3246) + 128
                    _3398 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                    mem[_3222 + (32 * _3246) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                    mem[_3222 + (32 * _3246) + 160 len 32 * _3398] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3398]
                    return memory
                      from mem[64]
                       len _3222 + (32 * _3246) + (32 * _3398) + -mem[64] + 160
                _3151 = mem[96]
                idx = 0
                while idx < _3151:
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    if s and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / s:
                        revert with 0, 17
                    if not s:
                        revert with 0, 18
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = s * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
                    if idx >= mem[96]:
                        revert with 0, 50
                    _3296 = mem[(32 * idx) + 128]
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    emit Harvest(mem[mem[64]], msg.sender, _3296);
                    if idx == -1:
                        revert with 0, 17
                    _3151 = mem[96]
                    idx = idx + 1
                    continue 
                stor101 = 1
                _3224 = mem[64]
                mem[mem[64]] = s
                mem[mem[64] + 32] = 96
                _3247 = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 128 len 32 * _3247] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3247]
                var55001 = _3247
                mem[mem[64] + 64] = (32 * _3247) + 128
                _3399 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3224 + (32 * _3247) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3224 + (32 * _3247) + 160 len 32 * _3399] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3399]
                return memory
                  from mem[64]
                   len _3224 + (32 * _3247) + (32 * _3399) + -mem[64] + 160
            mem[mem[64] + 36] = _2082
            require ext_code.size(sub_6af66772Address)
            call sub_6af66772Address.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _2082
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2151 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_2151] == bool(mem[_2151])
            if _2082 == s:
                _3152 = mem[96]
                idx = 0
                while idx < _3152:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _3185 = mem[(32 * idx) + 128]
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    emit Harvest(mem[mem[64]], msg.sender, _3185);
                    if idx == -1:
                        revert with 0, 17
                    _3152 = mem[96]
                    idx = idx + 1
                    continue 
                stor101 = 1
                _3225 = mem[64]
                mem[mem[64]] = _2082
                mem[mem[64] + 32] = 96
                _3248 = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 128 len 32 * _3248] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3248]
                var55001 = _3248
                mem[mem[64] + 64] = (32 * _3248) + 128
                _3400 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3225 + (32 * _3248) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3225 + (32 * _3248) + 160 len 32 * _3400] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3400]
                return memory
                  from mem[64]
                   len _3225 + (32 * _3248) + (32 * _3400) + -mem[64] + 160
            _3153 = mem[96]
            idx = 0
            while idx < _3153:
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                if _2082 and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / _2082:
                    revert with 0, 17
                if not s:
                    revert with 0, 18
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _2082 * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
                if idx >= mem[96]:
                    revert with 0, 50
                _3300 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                emit Harvest(mem[mem[64]], msg.sender, _3300);
                if idx == -1:
                    revert with 0, 17
                _3153 = mem[96]
                idx = idx + 1
                continue 
            stor101 = 1
            _3227 = mem[64]
            mem[mem[64]] = _2082
            mem[mem[64] + 32] = 96
            _3249 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 128 len 32 * _3249] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3249]
            var55001 = _3249
            mem[mem[64] + 64] = (32 * _3249) + 128
            _3401 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3227 + (32 * _3249) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3227 + (32 * _3249) + 160 len 32 * _3401] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3401]
            return memory
              from mem[64]
               len _3227 + (32 * _3249) + (32 * _3401) + -mem[64] + 160
        mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
        idx = 0
        s = 0
        while idx < arg1.length:
            if idx >= mem[96]:
                revert with 0, 50
            _2059 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            mem[0] = 209
            if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
                if idx >= mem[96]:
                    revert with 0, 50
                _2092 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2125 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2158 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2092].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2125][msg.sender]
                    require ext_code.size(address(poolInfo[_2092].field_1024))
                    call address(poolInfo[_2092].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2125][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2523 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2523]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2125][msg.sender] * poolInfo[_2092].field_768) + (stor2[('map', 'msg.sender', ('var', '_2125'))] * poolInfo[_2092].field_1536) / 10^12) + stor[_2158][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2125'))]
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(poolInfo[_2059].field_0))
            staticcall address(poolInfo[_2059].field_0).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2093 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2127 = mem[_2093]
            if not mem[_2093]:
                poolInfo[_2059].field_512 = block.timestamp
                if idx >= mem[96]:
                    revert with 0, 50
                _2179 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2198 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2214 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2179].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2198][msg.sender]
                    require ext_code.size(address(poolInfo[_2179].field_1024))
                    call address(poolInfo[_2179].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2198][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2555 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2555]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2198][msg.sender] * poolInfo[_2179].field_768) + (stor2[('map', 'msg.sender', ('var', '_2198'))] * poolInfo[_2179].field_1536) / 10^12) + stor[_2214][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2198'))]
                continue 
            if block.timestamp < poolInfo[_2059].field_512:
                revert with 0, 17
            if block.timestamp - poolInfo[_2059].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_2059].field_512:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2) - (poolInfo[_2059].field_512 * sub_9702d3e2) and poolInfo[_2059].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_2059].field_512 * sub_9702d3e2):
                revert with 0, 17
            if not sub_91ea1d68:
                revert with 0, 18
            if mem[_2093] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                revert with 0, 17
            if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68:
                revert with 0, 17
            if not 1000 * mem[_2093]:
                revert with 0, 18
            if poolInfo[_2059].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2093]):
                revert with 0, 17
            poolInfo[_2059].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2093]
            if not poolInfo[_2059].field_1280:
                poolInfo[_2059].field_1536 = 0
                require ext_code.size(address(poolInfo[_2059].field_0))
                staticcall address(poolInfo[_2059].field_0).0x705727b5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2495 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2503 = mem[_2495]
                if not mem[_2495]:
                    if poolInfo[_2059].field_256 and 833333333333333333 > -1 / poolInfo[_2059].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2059].field_256):
                        revert with 0, 17
                    if sub_91ea1d68 + (833333333333333333 * poolInfo[_2059].field_256) < poolInfo[_2059].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2059].field_256) - poolInfo[_2059].field_1792
                    poolInfo[_2059].field_1792 = 833333333333333333 * poolInfo[_2059].field_256
                    poolInfo[_2059].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _2127
                    mem[mem[64] + 64] = poolInfo[_2059].field_768
                    emit UpdatePool(block.timestamp, _2127, poolInfo[_2059].field_768, _2059);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2715 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2731 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2762 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2715].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2731][msg.sender]
                        require ext_code.size(address(poolInfo[_2715].field_1024))
                        call address(poolInfo[_2715].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2731][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3051 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3051]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2731][msg.sender] * poolInfo[_2715].field_768) + (stor2[('map', 'msg.sender', ('var', '_2731'))] * poolInfo[_2715].field_1536) / 10^12) + stor[_2762][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2731'))]
                    continue 
                require ext_code.size(address(poolInfo[_2059].field_0))
                staticcall address(poolInfo[_2059].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2527 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_2527] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _2503:
                    revert with 0, 18
                if not 10^18 * mem[_2527] / _2503:
                    if poolInfo[_2059].field_256 and 1 > -1 / poolInfo[_2059].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[_2059].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[_2059].field_256 < poolInfo[_2059].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2059].field_256 - poolInfo[_2059].field_1792
                    poolInfo[_2059].field_1792 = poolInfo[_2059].field_256
                    poolInfo[_2059].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _2127
                    mem[mem[64] + 64] = poolInfo[_2059].field_768
                    emit UpdatePool(block.timestamp, _2127, poolInfo[_2059].field_768, _2059);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2611 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2626 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2642 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2611].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2626][msg.sender]
                        require ext_code.size(address(poolInfo[_2611].field_1024))
                        call address(poolInfo[_2611].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2626][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2905 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2905]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2626][msg.sender] * poolInfo[_2611].field_768) + (stor2[('map', 'msg.sender', ('var', '_2626'))] * poolInfo[_2611].field_1536) / 10^12) + stor[_2642][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2626'))]
                    continue 
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_2527] / _2503 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_2527] / _2503:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[_2059].field_256 and (((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17 > -1 / poolInfo[_2059].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[_2059].field_256 * (((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[_2059].field_256 * (((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17) < poolInfo[_2059].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2059].field_256 * (((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17) - poolInfo[_2059].field_1792
                poolInfo[_2059].field_1792 = poolInfo[_2059].field_256 * (((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2527] / _2503 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2527] / _2503) + 2 * 10^17
                poolInfo[_2059].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2127
                mem[mem[64] + 64] = poolInfo[_2059].field_768
                emit UpdatePool(block.timestamp, _2127, poolInfo[_2059].field_768, _2059);
                if idx >= mem[96]:
                    revert with 0, 50
                _2783 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2802 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2828 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2783].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2802][msg.sender]
                    require ext_code.size(address(poolInfo[_2783].field_1024))
                    call address(poolInfo[_2783].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2802][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3093 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3093]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2802][msg.sender] * poolInfo[_2783].field_768) + (stor2[('map', 'msg.sender', ('var', '_2802'))] * poolInfo[_2783].field_1536) / 10^12) + stor[_2828][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2802'))]
                continue 
            if poolInfo[_2059].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                revert with 0, 17
            if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68:
                revert with 0, 17
            if not 1000 * poolInfo[_2059].field_1280:
                revert with 0, 18
            if poolInfo[_2059].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2059].field_1280):
                revert with 0, 17
            poolInfo[_2059].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2059].field_1792) - (poolInfo[_2059].field_512 * sub_9702d3e2 * poolInfo[_2059].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2059].field_1280
            require ext_code.size(address(poolInfo[_2059].field_0))
            staticcall address(poolInfo[_2059].field_0).0x705727b5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2575 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2579 = mem[_2575]
            if not mem[_2575]:
                if poolInfo[_2059].field_256 and 833333333333333333 > -1 / poolInfo[_2059].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2059].field_256):
                    revert with 0, 17
                if sub_91ea1d68 + (833333333333333333 * poolInfo[_2059].field_256) < poolInfo[_2059].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2059].field_256) - poolInfo[_2059].field_1792
                poolInfo[_2059].field_1792 = 833333333333333333 * poolInfo[_2059].field_256
                poolInfo[_2059].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2127
                mem[mem[64] + 64] = poolInfo[_2059].field_768
                emit UpdatePool(block.timestamp, _2127, poolInfo[_2059].field_768, _2059);
                if idx >= mem[96]:
                    revert with 0, 50
                _2826 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2851 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2886 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2826].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2851][msg.sender]
                    require ext_code.size(address(poolInfo[_2826].field_1024))
                    call address(poolInfo[_2826].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2851][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3115 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3115]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2851][msg.sender] * poolInfo[_2826].field_768) + (stor2[('map', 'msg.sender', ('var', '_2851'))] * poolInfo[_2826].field_1536) / 10^12) + stor[_2886][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2851'))]
                continue 
            require ext_code.size(address(poolInfo[_2059].field_0))
            staticcall address(poolInfo[_2059].field_0).0x961be391 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2591 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_2591] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                revert with 0, 17
            if not _2579:
                revert with 0, 18
            if not 10^18 * mem[_2591] / _2579:
                if poolInfo[_2059].field_256 and 1 > -1 / poolInfo[_2059].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !poolInfo[_2059].field_256:
                    revert with 0, 17
                if sub_91ea1d68 + poolInfo[_2059].field_256 < poolInfo[_2059].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2059].field_256 - poolInfo[_2059].field_1792
                poolInfo[_2059].field_1792 = poolInfo[_2059].field_256
                poolInfo[_2059].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2127
                mem[mem[64] + 64] = poolInfo[_2059].field_768
                emit UpdatePool(block.timestamp, _2127, poolInfo[_2059].field_768, _2059);
                if idx >= mem[96]:
                    revert with 0, 50
                _2663 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2678 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2703 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2663].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2678][msg.sender]
                    require ext_code.size(address(poolInfo[_2663].field_1024))
                    call address(poolInfo[_2663].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2678][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3013 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3013]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2678][msg.sender] * poolInfo[_2663].field_768) + (stor2[('map', 'msg.sender', ('var', '_2678'))] * poolInfo[_2663].field_1536) / 10^12) + stor[_2703][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2678'))]
                continue 
            if 1000000000000000000 * 10^18 > !(10^18 * mem[_2591] / _2579 / 2):
                revert with 0, 17
            if not 10^18 * mem[_2591] / _2579:
                revert with 0, 18
            if 2 * 10^17 > !((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579):
                revert with 0, 17
            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17 / 2):
                revert with 0, 17
            if not ((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17:
                revert with 0, 18
            if poolInfo[_2059].field_256 and (((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17 > -1 / poolInfo[_2059].field_256:
                revert with 0, 17
            if sub_91ea1d68 > !(poolInfo[_2059].field_256 * (((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17):
                revert with 0, 17
            if sub_91ea1d68 + (poolInfo[_2059].field_256 * (((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17) < poolInfo[_2059].field_1792:
                revert with 0, 17
            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2059].field_256 * (((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17) - poolInfo[_2059].field_1792
            poolInfo[_2059].field_1792 = poolInfo[_2059].field_256 * (((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2591] / _2579 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2591] / _2579) + 2 * 10^17
            poolInfo[_2059].field_512 = block.timestamp
            mem[mem[64]] = block.timestamp
            mem[mem[64] + 32] = _2127
            mem[mem[64] + 64] = poolInfo[_2059].field_768
            emit UpdatePool(block.timestamp, _2127, poolInfo[_2059].field_768, _2059);
            if idx >= mem[96]:
                revert with 0, 50
            _2943 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            if idx >= mem[96]:
                revert with 0, 50
            _2958 = sha3(mem[(32 * idx) + 128], 212)
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 212)
            if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            _2974 = sha3(mem[(32 * idx) + 128], 213)
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                revert with 0, 17
            if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                revert with 0, 17
            if idx >= mem[96]:
                revert with 0, 50
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 213)
            sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
            if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                revert with 0, 17
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
            if address(poolInfo[_2943].field_1024):
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2958][msg.sender]
                require ext_code.size(address(poolInfo[_2943].field_1024))
                call address(poolInfo[_2943].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2958][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3139 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3139]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((stor[_2958][msg.sender] * poolInfo[_2943].field_768) + (stor2[('map', 'msg.sender', ('var', '_2958'))] * poolInfo[_2943].field_1536) / 10^12) + stor[_2974][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2958'))]
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(sub_6af66772Address)
        staticcall sub_6af66772Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2068 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2084 = mem[_2068]
        if mem[_2068] <= 0:
            revert with 0, 'No tokens to distribute'
        mem[mem[64] + 4] = msg.sender
        if s <= mem[_2068]:
            mem[mem[64] + 36] = s
            require ext_code.size(sub_6af66772Address)
            call sub_6af66772Address.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, s
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2155 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_2155] == bool(mem[_2155])
            if s == s:
                _3154 = mem[96]
                idx = 0
                while idx < _3154:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _3188 = mem[(32 * idx) + 128]
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    emit Harvest(mem[mem[64]], msg.sender, _3188);
                    if idx == -1:
                        revert with 0, 17
                    _3154 = mem[96]
                    idx = idx + 1
                    continue 
                stor101 = 1
                _3228 = mem[64]
                mem[mem[64]] = s
                mem[mem[64] + 32] = 96
                _3250 = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 128 len 32 * _3250] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3250]
                mem[mem[64] + 64] = (32 * _3250) + 128
                _3402 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3228 + (32 * _3250) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3228 + (32 * _3250) + 160 len 32 * _3402] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3402]
                var61001 = _3402
                return memory
                  from mem[64]
                   len _3228 + (32 * _3250) + (32 * _3402) + -mem[64] + 160
            _3155 = mem[96]
            idx = 0
            while idx < _3155:
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                if s and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / s:
                    revert with 0, 17
                if not s:
                    revert with 0, 18
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = s * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
                if idx >= mem[96]:
                    revert with 0, 50
                _3304 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                emit Harvest(mem[mem[64]], msg.sender, _3304);
                if idx == -1:
                    revert with 0, 17
                _3155 = mem[96]
                idx = idx + 1
                continue 
            stor101 = 1
            _3230 = mem[64]
            mem[mem[64]] = s
            mem[mem[64] + 32] = 96
            _3251 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 128 len 32 * _3251] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3251]
            mem[mem[64] + 64] = (32 * _3251) + 128
            _3403 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3230 + (32 * _3251) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3230 + (32 * _3251) + 160 len 32 * _3403] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3403]
            var61001 = _3403
            return memory
              from mem[64]
               len _3230 + (32 * _3251) + (32 * _3403) + -mem[64] + 160
        mem[mem[64] + 36] = _2084
        require ext_code.size(sub_6af66772Address)
        call sub_6af66772Address.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, _2084
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2156 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_2156] == bool(mem[_2156])
        if _2084 == s:
            _3156 = mem[96]
            idx = 0
            while idx < _3156:
                if idx >= mem[96]:
                    revert with 0, 50
                _3191 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                emit Harvest(mem[mem[64]], msg.sender, _3191);
                if idx == -1:
                    revert with 0, 17
                _3156 = mem[96]
                idx = idx + 1
                continue 
            stor101 = 1
            _3231 = mem[64]
            mem[mem[64]] = _2084
            mem[mem[64] + 32] = 96
            _3252 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 128 len 32 * _3252] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3252]
            mem[mem[64] + 64] = (32 * _3252) + 128
            _3404 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3231 + (32 * _3252) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3231 + (32 * _3252) + 160 len 32 * _3404] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3404]
            var61001 = _3404
            return memory
              from mem[64]
               len _3231 + (32 * _3252) + (32 * _3404) + -mem[64] + 160
        _3157 = mem[96]
        idx = 0
        while idx < _3157:
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            if _2084 and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / _2084:
                revert with 0, 17
            if not s:
                revert with 0, 18
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _2084 * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
            if idx >= mem[96]:
                revert with 0, 50
            _3308 = mem[(32 * idx) + 128]
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            emit Harvest(mem[mem[64]], msg.sender, _3308);
            if idx == -1:
                revert with 0, 17
            _3157 = mem[96]
            idx = idx + 1
            continue 
        stor101 = 1
        _3233 = mem[64]
        mem[mem[64]] = _2084
        mem[mem[64] + 32] = 96
        _3253 = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 128 len 32 * _3253] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3253]
        mem[mem[64] + 64] = (32 * _3253) + 128
        _3405 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3233 + (32 * _3253) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3233 + (32 * _3253) + 160 len 32 * _3405] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3405]
        var61001 = _3405
        return memory
          from mem[64]
           len _3233 + (32 * _3253) + (32 * _3405) + -mem[64] + 160
    mem[ceil32(32 * arg1.length) + 129 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
    if arg1.length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129] = arg1.length
    mem[64] = ceil32(32 * arg1.length) + (64 * arg1.length) + 161
    if not arg1.length:
        idx = 0
        s = 0
        while idx < arg1.length:
            if idx >= mem[96]:
                revert with 0, 50
            _2062 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            mem[0] = 209
            if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
                if idx >= mem[96]:
                    revert with 0, 50
                _2094 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2134 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2163 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2094].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2134][msg.sender]
                    require ext_code.size(address(poolInfo[_2094].field_1024))
                    call address(poolInfo[_2094].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2134][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2524 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2524]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2134][msg.sender] * poolInfo[_2094].field_768) + (stor2[('map', 'msg.sender', ('var', '_2134'))] * poolInfo[_2094].field_1536) / 10^12) + stor[_2163][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2134'))]
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(poolInfo[_2062].field_0))
            staticcall address(poolInfo[_2062].field_0).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2095 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2136 = mem[_2095]
            if not mem[_2095]:
                poolInfo[_2062].field_512 = block.timestamp
                if idx >= mem[96]:
                    revert with 0, 50
                _2182 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2201 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2217 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2182].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2201][msg.sender]
                    require ext_code.size(address(poolInfo[_2182].field_1024))
                    call address(poolInfo[_2182].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2201][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2556 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2556]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2201][msg.sender] * poolInfo[_2182].field_768) + (stor2[('map', 'msg.sender', ('var', '_2201'))] * poolInfo[_2182].field_1536) / 10^12) + stor[_2217][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2201'))]
                continue 
            if block.timestamp < poolInfo[_2062].field_512:
                revert with 0, 17
            if block.timestamp - poolInfo[_2062].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_2062].field_512:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2) - (poolInfo[_2062].field_512 * sub_9702d3e2) and poolInfo[_2062].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_2062].field_512 * sub_9702d3e2):
                revert with 0, 17
            if not sub_91ea1d68:
                revert with 0, 18
            if mem[_2095] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                revert with 0, 17
            if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68:
                revert with 0, 17
            if not 1000 * mem[_2095]:
                revert with 0, 18
            if poolInfo[_2062].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2095]):
                revert with 0, 17
            poolInfo[_2062].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2095]
            if not poolInfo[_2062].field_1280:
                poolInfo[_2062].field_1536 = 0
                require ext_code.size(address(poolInfo[_2062].field_0))
                staticcall address(poolInfo[_2062].field_0).0x705727b5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2496 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2504 = mem[_2496]
                if not mem[_2496]:
                    if poolInfo[_2062].field_256 and 833333333333333333 > -1 / poolInfo[_2062].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2062].field_256):
                        revert with 0, 17
                    if sub_91ea1d68 + (833333333333333333 * poolInfo[_2062].field_256) < poolInfo[_2062].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2062].field_256) - poolInfo[_2062].field_1792
                    poolInfo[_2062].field_1792 = 833333333333333333 * poolInfo[_2062].field_256
                    poolInfo[_2062].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _2136
                    mem[mem[64] + 64] = poolInfo[_2062].field_768
                    emit UpdatePool(block.timestamp, _2136, poolInfo[_2062].field_768, _2062);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2716 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2735 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2765 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2716].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2735][msg.sender]
                        require ext_code.size(address(poolInfo[_2716].field_1024))
                        call address(poolInfo[_2716].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2735][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3052 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3052]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2735][msg.sender] * poolInfo[_2716].field_768) + (stor2[('map', 'msg.sender', ('var', '_2735'))] * poolInfo[_2716].field_1536) / 10^12) + stor[_2765][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2735'))]
                    continue 
                require ext_code.size(address(poolInfo[_2062].field_0))
                staticcall address(poolInfo[_2062].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2528 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_2528] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _2504:
                    revert with 0, 18
                if not 10^18 * mem[_2528] / _2504:
                    if poolInfo[_2062].field_256 and 1 > -1 / poolInfo[_2062].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[_2062].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[_2062].field_256 < poolInfo[_2062].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2062].field_256 - poolInfo[_2062].field_1792
                    poolInfo[_2062].field_1792 = poolInfo[_2062].field_256
                    poolInfo[_2062].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _2136
                    mem[mem[64] + 64] = poolInfo[_2062].field_768
                    emit UpdatePool(block.timestamp, _2136, poolInfo[_2062].field_768, _2062);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2612 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2629 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2645 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if address(poolInfo[_2612].field_1024):
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_2629][msg.sender]
                        require ext_code.size(address(poolInfo[_2612].field_1024))
                        call address(poolInfo[_2612].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_2629][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2907 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2907]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_2629][msg.sender] * poolInfo[_2612].field_768) + (stor2[('map', 'msg.sender', ('var', '_2629'))] * poolInfo[_2612].field_1536) / 10^12) + stor[_2645][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2629'))]
                    continue 
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_2528] / _2504 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_2528] / _2504:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[_2062].field_256 and (((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17 > -1 / poolInfo[_2062].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[_2062].field_256 * (((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[_2062].field_256 * (((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17) < poolInfo[_2062].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2062].field_256 * (((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17) - poolInfo[_2062].field_1792
                poolInfo[_2062].field_1792 = poolInfo[_2062].field_256 * (((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2528] / _2504 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2528] / _2504) + 2 * 10^17
                poolInfo[_2062].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2136
                mem[mem[64] + 64] = poolInfo[_2062].field_768
                emit UpdatePool(block.timestamp, _2136, poolInfo[_2062].field_768, _2062);
                if idx >= mem[96]:
                    revert with 0, 50
                _2784 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2807 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2832 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2784].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2807][msg.sender]
                    require ext_code.size(address(poolInfo[_2784].field_1024))
                    call address(poolInfo[_2784].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2807][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3095 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3095]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2807][msg.sender] * poolInfo[_2784].field_768) + (stor2[('map', 'msg.sender', ('var', '_2807'))] * poolInfo[_2784].field_1536) / 10^12) + stor[_2832][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2807'))]
                continue 
            if poolInfo[_2062].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                revert with 0, 17
            if (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                revert with 0, 17
            if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68:
                revert with 0, 17
            if not 1000 * poolInfo[_2062].field_1280:
                revert with 0, 18
            if poolInfo[_2062].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2062].field_1280):
                revert with 0, 17
            poolInfo[_2062].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2062].field_1792) - (poolInfo[_2062].field_512 * sub_9702d3e2 * poolInfo[_2062].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2062].field_1280
            require ext_code.size(address(poolInfo[_2062].field_0))
            staticcall address(poolInfo[_2062].field_0).0x705727b5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2576 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2580 = mem[_2576]
            if not mem[_2576]:
                if poolInfo[_2062].field_256 and 833333333333333333 > -1 / poolInfo[_2062].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2062].field_256):
                    revert with 0, 17
                if sub_91ea1d68 + (833333333333333333 * poolInfo[_2062].field_256) < poolInfo[_2062].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2062].field_256) - poolInfo[_2062].field_1792
                poolInfo[_2062].field_1792 = 833333333333333333 * poolInfo[_2062].field_256
                poolInfo[_2062].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2136
                mem[mem[64] + 64] = poolInfo[_2062].field_768
                emit UpdatePool(block.timestamp, _2136, poolInfo[_2062].field_768, _2062);
                if idx >= mem[96]:
                    revert with 0, 50
                _2830 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2855 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2889 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2830].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2855][msg.sender]
                    require ext_code.size(address(poolInfo[_2830].field_1024))
                    call address(poolInfo[_2830].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2855][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3116 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3116]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2855][msg.sender] * poolInfo[_2830].field_768) + (stor2[('map', 'msg.sender', ('var', '_2855'))] * poolInfo[_2830].field_1536) / 10^12) + stor[_2889][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2855'))]
                continue 
            require ext_code.size(address(poolInfo[_2062].field_0))
            staticcall address(poolInfo[_2062].field_0).0x961be391 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2592 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_2592] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                revert with 0, 17
            if not _2580:
                revert with 0, 18
            if not 10^18 * mem[_2592] / _2580:
                if poolInfo[_2062].field_256 and 1 > -1 / poolInfo[_2062].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !poolInfo[_2062].field_256:
                    revert with 0, 17
                if sub_91ea1d68 + poolInfo[_2062].field_256 < poolInfo[_2062].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2062].field_256 - poolInfo[_2062].field_1792
                poolInfo[_2062].field_1792 = poolInfo[_2062].field_256
                poolInfo[_2062].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2136
                mem[mem[64] + 64] = poolInfo[_2062].field_768
                emit UpdatePool(block.timestamp, _2136, poolInfo[_2062].field_768, _2062);
                if idx >= mem[96]:
                    revert with 0, 50
                _2664 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2681 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2707 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2664].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2681][msg.sender]
                    require ext_code.size(address(poolInfo[_2664].field_1024))
                    call address(poolInfo[_2664].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2681][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3015 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3015]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2681][msg.sender] * poolInfo[_2664].field_768) + (stor2[('map', 'msg.sender', ('var', '_2681'))] * poolInfo[_2664].field_1536) / 10^12) + stor[_2707][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2681'))]
                continue 
            if 1000000000000000000 * 10^18 > !(10^18 * mem[_2592] / _2580 / 2):
                revert with 0, 17
            if not 10^18 * mem[_2592] / _2580:
                revert with 0, 18
            if 2 * 10^17 > !((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580):
                revert with 0, 17
            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17 / 2):
                revert with 0, 17
            if not ((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17:
                revert with 0, 18
            if poolInfo[_2062].field_256 and (((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17 > -1 / poolInfo[_2062].field_256:
                revert with 0, 17
            if sub_91ea1d68 > !(poolInfo[_2062].field_256 * (((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17):
                revert with 0, 17
            if sub_91ea1d68 + (poolInfo[_2062].field_256 * (((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17) < poolInfo[_2062].field_1792:
                revert with 0, 17
            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2062].field_256 * (((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17) - poolInfo[_2062].field_1792
            poolInfo[_2062].field_1792 = poolInfo[_2062].field_256 * (((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2592] / _2580 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2592] / _2580) + 2 * 10^17
            poolInfo[_2062].field_512 = block.timestamp
            mem[mem[64]] = block.timestamp
            mem[mem[64] + 32] = _2136
            mem[mem[64] + 64] = poolInfo[_2062].field_768
            emit UpdatePool(block.timestamp, _2136, poolInfo[_2062].field_768, _2062);
            if idx >= mem[96]:
                revert with 0, 50
            _2944 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            if idx >= mem[96]:
                revert with 0, 50
            _2961 = sha3(mem[(32 * idx) + 128], 212)
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 212)
            if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            _2977 = sha3(mem[(32 * idx) + 128], 213)
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                revert with 0, 17
            if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                revert with 0, 17
            if idx >= mem[96]:
                revert with 0, 50
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 213)
            sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
            if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                revert with 0, 17
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
            if address(poolInfo[_2944].field_1024):
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2961][msg.sender]
                require ext_code.size(address(poolInfo[_2944].field_1024))
                call address(poolInfo[_2944].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2961][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3140 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3140]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((stor[_2961][msg.sender] * poolInfo[_2944].field_768) + (stor2[('map', 'msg.sender', ('var', '_2961'))] * poolInfo[_2944].field_1536) / 10^12) + stor[_2977][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2961'))]
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(sub_6af66772Address)
        staticcall sub_6af66772Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2070 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2086 = mem[_2070]
        if mem[_2070] <= 0:
            revert with 0, 'No tokens to distribute'
        mem[mem[64] + 4] = msg.sender
        if s <= mem[_2070]:
            mem[mem[64] + 36] = s
            require ext_code.size(sub_6af66772Address)
            call sub_6af66772Address.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, s
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2160 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_2160] == bool(mem[_2160])
            if s == s:
                _3158 = mem[96]
                idx = 0
                while idx < _3158:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _3194 = mem[(32 * idx) + 128]
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    emit Harvest(mem[mem[64]], msg.sender, _3194);
                    if idx == -1:
                        revert with 0, 17
                    _3158 = mem[96]
                    idx = idx + 1
                    continue 
                stor101 = 1
                _3234 = mem[64]
                mem[mem[64]] = s
                mem[mem[64] + 32] = 96
                _3254 = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
                mem[mem[64] + 128 len 32 * _3254] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3254]
                mem[mem[64] + 64] = (32 * _3254) + 128
                _3406 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3234 + (32 * _3254) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
                mem[_3234 + (32 * _3254) + 160 len 32 * _3406] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3406]
                var61001 = _3406
                return memory
                  from mem[64]
                   len _3234 + (32 * _3254) + (32 * _3406) + -mem[64] + 160
            _3159 = mem[96]
            idx = 0
            while idx < _3159:
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                if s and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / s:
                    revert with 0, 17
                if not s:
                    revert with 0, 18
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = s * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
                if idx >= mem[96]:
                    revert with 0, 50
                _3312 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                emit Harvest(mem[mem[64]], msg.sender, _3312);
                if idx == -1:
                    revert with 0, 17
                _3159 = mem[96]
                idx = idx + 1
                continue 
            stor101 = 1
            _3236 = mem[64]
            mem[mem[64]] = s
            mem[mem[64] + 32] = 96
            _3255 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 128 len 32 * _3255] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3255]
            mem[mem[64] + 64] = (32 * _3255) + 128
            _3407 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3236 + (32 * _3255) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3236 + (32 * _3255) + 160 len 32 * _3407] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3407]
            var61001 = _3407
            return memory
              from mem[64]
               len _3236 + (32 * _3255) + (32 * _3407) + -mem[64] + 160
        mem[mem[64] + 36] = _2086
        require ext_code.size(sub_6af66772Address)
        call sub_6af66772Address.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, _2086
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2161 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_2161] == bool(mem[_2161])
        if _2086 == s:
            _3160 = mem[96]
            idx = 0
            while idx < _3160:
                if idx >= mem[96]:
                    revert with 0, 50
                _3197 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                emit Harvest(mem[mem[64]], msg.sender, _3197);
                if idx == -1:
                    revert with 0, 17
                _3160 = mem[96]
                idx = idx + 1
                continue 
            stor101 = 1
            _3237 = mem[64]
            mem[mem[64]] = _2086
            mem[mem[64] + 32] = 96
            _3256 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 128 len 32 * _3256] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3256]
            mem[mem[64] + 64] = (32 * _3256) + 128
            _3408 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3237 + (32 * _3256) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3237 + (32 * _3256) + 160 len 32 * _3408] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3408]
            var61001 = _3408
            return memory
              from mem[64]
               len _3237 + (32 * _3256) + (32 * _3408) + -mem[64] + 160
        _3161 = mem[96]
        idx = 0
        while idx < _3161:
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            if _2086 and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / _2086:
                revert with 0, 17
            if not s:
                revert with 0, 18
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _2086 * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
            if idx >= mem[96]:
                revert with 0, 50
            _3316 = mem[(32 * idx) + 128]
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            emit Harvest(mem[mem[64]], msg.sender, _3316);
            if idx == -1:
                revert with 0, 17
            _3161 = mem[96]
            idx = idx + 1
            continue 
        stor101 = 1
        _3239 = mem[64]
        mem[mem[64]] = _2086
        mem[mem[64] + 32] = 96
        _3257 = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 128 len 32 * _3257] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3257]
        mem[mem[64] + 64] = (32 * _3257) + 128
        _3409 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3239 + (32 * _3257) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3239 + (32 * _3257) + 160 len 32 * _3409] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3409]
        var61001 = _3409
        return memory
          from mem[64]
           len _3239 + (32 * _3257) + (32 * _3409) + -mem[64] + 160
    mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
    idx = 0
    s = 0
    while idx < arg1.length:
        if idx >= mem[96]:
            revert with 0, 50
        _2065 = mem[(32 * idx) + 128]
        if mem[(32 * idx) + 128] >= poolInfo.length:
            revert with 0, 50
        mem[0] = 209
        if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
            if idx >= mem[96]:
                revert with 0, 50
            _2096 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            if idx >= mem[96]:
                revert with 0, 50
            _2143 = sha3(mem[(32 * idx) + 128], 212)
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 212)
            if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            _2168 = sha3(mem[(32 * idx) + 128], 213)
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                revert with 0, 17
            if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                revert with 0, 17
            if idx >= mem[96]:
                revert with 0, 50
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 213)
            sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
            if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                revert with 0, 17
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
            if address(poolInfo[_2096].field_1024):
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2143][msg.sender]
                require ext_code.size(address(poolInfo[_2096].field_1024))
                call address(poolInfo[_2096].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2143][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2525 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2525]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((stor[_2143][msg.sender] * poolInfo[_2096].field_768) + (stor2[('map', 'msg.sender', ('var', '_2143'))] * poolInfo[_2096].field_1536) / 10^12) + stor[_2168][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2143'))]
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(poolInfo[_2065].field_0))
        staticcall address(poolInfo[_2065].field_0).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2097 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2145 = mem[_2097]
        if not mem[_2097]:
            poolInfo[_2065].field_512 = block.timestamp
            if idx >= mem[96]:
                revert with 0, 50
            _2185 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            if idx >= mem[96]:
                revert with 0, 50
            _2204 = sha3(mem[(32 * idx) + 128], 212)
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 212)
            if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            _2220 = sha3(mem[(32 * idx) + 128], 213)
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                revert with 0, 17
            if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                revert with 0, 17
            if idx >= mem[96]:
                revert with 0, 50
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 213)
            sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
            if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                revert with 0, 17
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
            if address(poolInfo[_2185].field_1024):
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2204][msg.sender]
                require ext_code.size(address(poolInfo[_2185].field_1024))
                call address(poolInfo[_2185].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2204][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2557 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2557]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((stor[_2204][msg.sender] * poolInfo[_2185].field_768) + (stor2[('map', 'msg.sender', ('var', '_2204'))] * poolInfo[_2185].field_1536) / 10^12) + stor[_2220][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2204'))]
            continue 
        if block.timestamp < poolInfo[_2065].field_512:
            revert with 0, 17
        if block.timestamp - poolInfo[_2065].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_2065].field_512:
            revert with 0, 17
        if (block.timestamp * sub_9702d3e2) - (poolInfo[_2065].field_512 * sub_9702d3e2) and poolInfo[_2065].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_2065].field_512 * sub_9702d3e2):
            revert with 0, 17
        if not sub_91ea1d68:
            revert with 0, 18
        if mem[_2097] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
            revert with 0, 17
        if (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
            revert with 0, 17
        if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68:
            revert with 0, 17
        if not 1000 * mem[_2097]:
            revert with 0, 18
        if poolInfo[_2065].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2097]):
            revert with 0, 17
        poolInfo[_2065].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_2097]
        if not poolInfo[_2065].field_1280:
            poolInfo[_2065].field_1536 = 0
            require ext_code.size(address(poolInfo[_2065].field_0))
            staticcall address(poolInfo[_2065].field_0).0x705727b5 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2497 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2505 = mem[_2497]
            if not mem[_2497]:
                if poolInfo[_2065].field_256 and 833333333333333333 > -1 / poolInfo[_2065].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2065].field_256):
                    revert with 0, 17
                if sub_91ea1d68 + (833333333333333333 * poolInfo[_2065].field_256) < poolInfo[_2065].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2065].field_256) - poolInfo[_2065].field_1792
                poolInfo[_2065].field_1792 = 833333333333333333 * poolInfo[_2065].field_256
                poolInfo[_2065].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2145
                mem[mem[64] + 64] = poolInfo[_2065].field_768
                emit UpdatePool(block.timestamp, _2145, poolInfo[_2065].field_768, _2065);
                if idx >= mem[96]:
                    revert with 0, 50
                _2717 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2739 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2768 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2717].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2739][msg.sender]
                    require ext_code.size(address(poolInfo[_2717].field_1024))
                    call address(poolInfo[_2717].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2739][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3053 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3053]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2739][msg.sender] * poolInfo[_2717].field_768) + (stor2[('map', 'msg.sender', ('var', '_2739'))] * poolInfo[_2717].field_1536) / 10^12) + stor[_2768][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2739'))]
                continue 
            require ext_code.size(address(poolInfo[_2065].field_0))
            staticcall address(poolInfo[_2065].field_0).0x961be391 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2529 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_2529] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                revert with 0, 17
            if not _2505:
                revert with 0, 18
            if not 10^18 * mem[_2529] / _2505:
                if poolInfo[_2065].field_256 and 1 > -1 / poolInfo[_2065].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !poolInfo[_2065].field_256:
                    revert with 0, 17
                if sub_91ea1d68 + poolInfo[_2065].field_256 < poolInfo[_2065].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2065].field_256 - poolInfo[_2065].field_1792
                poolInfo[_2065].field_1792 = poolInfo[_2065].field_256
                poolInfo[_2065].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _2145
                mem[mem[64] + 64] = poolInfo[_2065].field_768
                emit UpdatePool(block.timestamp, _2145, poolInfo[_2065].field_768, _2065);
                if idx >= mem[96]:
                    revert with 0, 50
                _2613 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2632 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2648 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if address(poolInfo[_2613].field_1024):
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_2632][msg.sender]
                    require ext_code.size(address(poolInfo[_2613].field_1024))
                    call address(poolInfo[_2613].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_2632][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2909 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_2909]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2632][msg.sender] * poolInfo[_2613].field_768) + (stor2[('map', 'msg.sender', ('var', '_2632'))] * poolInfo[_2613].field_1536) / 10^12) + stor[_2648][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2632'))]
                continue 
            if 1000000000000000000 * 10^18 > !(10^18 * mem[_2529] / _2505 / 2):
                revert with 0, 17
            if not 10^18 * mem[_2529] / _2505:
                revert with 0, 18
            if 2 * 10^17 > !((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505):
                revert with 0, 17
            if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17 / 2):
                revert with 0, 17
            if not ((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17:
                revert with 0, 18
            if poolInfo[_2065].field_256 and (((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17 > -1 / poolInfo[_2065].field_256:
                revert with 0, 17
            if sub_91ea1d68 > !(poolInfo[_2065].field_256 * (((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17):
                revert with 0, 17
            if sub_91ea1d68 + (poolInfo[_2065].field_256 * (((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17) < poolInfo[_2065].field_1792:
                revert with 0, 17
            sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2065].field_256 * (((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17) - poolInfo[_2065].field_1792
            poolInfo[_2065].field_1792 = poolInfo[_2065].field_256 * (((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2529] / _2505 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2529] / _2505) + 2 * 10^17
            poolInfo[_2065].field_512 = block.timestamp
            mem[mem[64]] = block.timestamp
            mem[mem[64] + 32] = _2145
            mem[mem[64] + 64] = poolInfo[_2065].field_768
            emit UpdatePool(block.timestamp, _2145, poolInfo[_2065].field_768, _2065);
            if idx >= mem[96]:
                revert with 0, 50
            _2785 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            if idx >= mem[96]:
                revert with 0, 50
            _2812 = sha3(mem[(32 * idx) + 128], 212)
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 212)
            if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            _2836 = sha3(mem[(32 * idx) + 128], 213)
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                revert with 0, 17
            if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                revert with 0, 17
            if idx >= mem[96]:
                revert with 0, 50
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 213)
            sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
            if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                revert with 0, 17
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
            if address(poolInfo[_2785].field_1024):
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2812][msg.sender]
                require ext_code.size(address(poolInfo[_2785].field_1024))
                call address(poolInfo[_2785].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2812][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3097 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3097]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((stor[_2812][msg.sender] * poolInfo[_2785].field_768) + (stor2[('map', 'msg.sender', ('var', '_2812'))] * poolInfo[_2785].field_1536) / 10^12) + stor[_2836][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2812'))]
            continue 
        if poolInfo[_2065].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
            revert with 0, 17
        if (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
            revert with 0, 17
        if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68:
            revert with 0, 17
        if not 1000 * poolInfo[_2065].field_1280:
            revert with 0, 18
        if poolInfo[_2065].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2065].field_1280):
            revert with 0, 17
        poolInfo[_2065].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_2065].field_1792) - (poolInfo[_2065].field_512 * sub_9702d3e2 * poolInfo[_2065].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_2065].field_1280
        require ext_code.size(address(poolInfo[_2065].field_0))
        staticcall address(poolInfo[_2065].field_0).0x705727b5 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2577 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2581 = mem[_2577]
        if not mem[_2577]:
            if poolInfo[_2065].field_256 and 833333333333333333 > -1 / poolInfo[_2065].field_256:
                revert with 0, 17
            if sub_91ea1d68 > !(833333333333333333 * poolInfo[_2065].field_256):
                revert with 0, 17
            if sub_91ea1d68 + (833333333333333333 * poolInfo[_2065].field_256) < poolInfo[_2065].field_1792:
                revert with 0, 17
            sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_2065].field_256) - poolInfo[_2065].field_1792
            poolInfo[_2065].field_1792 = 833333333333333333 * poolInfo[_2065].field_256
            poolInfo[_2065].field_512 = block.timestamp
            mem[mem[64]] = block.timestamp
            mem[mem[64] + 32] = _2145
            mem[mem[64] + 64] = poolInfo[_2065].field_768
            emit UpdatePool(block.timestamp, _2145, poolInfo[_2065].field_768, _2065);
            if idx >= mem[96]:
                revert with 0, 50
            _2834 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            if idx >= mem[96]:
                revert with 0, 50
            _2859 = sha3(mem[(32 * idx) + 128], 212)
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 212)
            if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            _2892 = sha3(mem[(32 * idx) + 128], 213)
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                revert with 0, 17
            if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                revert with 0, 17
            if idx >= mem[96]:
                revert with 0, 50
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 213)
            sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
            if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                revert with 0, 17
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
            if address(poolInfo[_2834].field_1024):
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2859][msg.sender]
                require ext_code.size(address(poolInfo[_2834].field_1024))
                call address(poolInfo[_2834].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2859][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3117 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3117]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((stor[_2859][msg.sender] * poolInfo[_2834].field_768) + (stor2[('map', 'msg.sender', ('var', '_2859'))] * poolInfo[_2834].field_1536) / 10^12) + stor[_2892][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2859'))]
            continue 
        require ext_code.size(address(poolInfo[_2065].field_0))
        staticcall address(poolInfo[_2065].field_0).0x961be391 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2593 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_2593] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
            revert with 0, 17
        if not _2581:
            revert with 0, 18
        if not 10^18 * mem[_2593] / _2581:
            if poolInfo[_2065].field_256 and 1 > -1 / poolInfo[_2065].field_256:
                revert with 0, 17
            if sub_91ea1d68 > !poolInfo[_2065].field_256:
                revert with 0, 17
            if sub_91ea1d68 + poolInfo[_2065].field_256 < poolInfo[_2065].field_1792:
                revert with 0, 17
            sub_91ea1d68 = sub_91ea1d68 + poolInfo[_2065].field_256 - poolInfo[_2065].field_1792
            poolInfo[_2065].field_1792 = poolInfo[_2065].field_256
            poolInfo[_2065].field_512 = block.timestamp
            mem[mem[64]] = block.timestamp
            mem[mem[64] + 32] = _2145
            mem[mem[64] + 64] = poolInfo[_2065].field_768
            emit UpdatePool(block.timestamp, _2145, poolInfo[_2065].field_768, _2065);
            if idx >= mem[96]:
                revert with 0, 50
            _2665 = mem[(32 * idx) + 128]
            if mem[(32 * idx) + 128] >= poolInfo.length:
                revert with 0, 50
            if idx >= mem[96]:
                revert with 0, 50
            _2684 = sha3(mem[(32 * idx) + 128], 212)
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 212)
            if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            _2711 = sha3(mem[(32 * idx) + 128], 213)
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                revert with 0, 17
            if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                revert with 0, 17
            if idx >= mem[96]:
                revert with 0, 50
            mem[0] = msg.sender
            mem[32] = sha3(mem[(32 * idx) + 128], 213)
            sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                revert with 0, 17
            if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                revert with 0, 17
            userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
            if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                revert with 0, 17
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
            if address(poolInfo[_2665].field_1024):
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2684][msg.sender]
                require ext_code.size(address(poolInfo[_2665].field_1024))
                call address(poolInfo[_2665].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2684][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3017 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3017]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((stor[_2684][msg.sender] * poolInfo[_2665].field_768) + (stor2[('map', 'msg.sender', ('var', '_2684'))] * poolInfo[_2665].field_1536) / 10^12) + stor[_2711][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2684'))]
            continue 
        if 1000000000000000000 * 10^18 > !(10^18 * mem[_2593] / _2581 / 2):
            revert with 0, 17
        if not 10^18 * mem[_2593] / _2581:
            revert with 0, 18
        if 2 * 10^17 > !((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581):
            revert with 0, 17
        if 1000000000000000000 * 10^18 > !(((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17 / 2):
            revert with 0, 17
        if not ((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17:
            revert with 0, 18
        if poolInfo[_2065].field_256 and (((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17 > -1 / poolInfo[_2065].field_256:
            revert with 0, 17
        if sub_91ea1d68 > !(poolInfo[_2065].field_256 * (((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17):
            revert with 0, 17
        if sub_91ea1d68 + (poolInfo[_2065].field_256 * (((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17) < poolInfo[_2065].field_1792:
            revert with 0, 17
        sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_2065].field_256 * (((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17) - poolInfo[_2065].field_1792
        poolInfo[_2065].field_1792 = poolInfo[_2065].field_256 * (((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_2593] / _2581 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_2593] / _2581) + 2 * 10^17
        poolInfo[_2065].field_512 = block.timestamp
        mem[mem[64]] = block.timestamp
        mem[mem[64] + 32] = _2145
        mem[mem[64] + 64] = poolInfo[_2065].field_768
        emit UpdatePool(block.timestamp, _2145, poolInfo[_2065].field_768, _2065);
        if idx >= mem[96]:
            revert with 0, 50
        _2945 = mem[(32 * idx) + 128]
        if mem[(32 * idx) + 128] >= poolInfo.length:
            revert with 0, 50
        if idx >= mem[96]:
            revert with 0, 50
        _2964 = sha3(mem[(32 * idx) + 128], 212)
        mem[0] = msg.sender
        mem[32] = sha3(mem[(32 * idx) + 128], 212)
        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s
            continue 
        if idx >= mem[96]:
            revert with 0, 50
        _2980 = sha3(mem[(32 * idx) + 128], 213)
        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
            revert with 0, 17
        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
            revert with 0, 17
        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
            revert with 0, 17
        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
            revert with 0, 17
        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
            revert with 0, 17
        if idx >= mem[96]:
            revert with 0, 50
        mem[0] = msg.sender
        mem[32] = sha3(mem[(32 * idx) + 128], 213)
        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
            revert with 0, 17
        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
            revert with 0, 17
        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
            revert with 0, 17
        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
            revert with 0, 17
        if idx >= mem[ceil32(32 * arg1.length) + 97]:
            revert with 0, 50
        mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
        if address(poolInfo[_2945].field_1024):
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = stor[_2964][msg.sender]
            require ext_code.size(address(poolInfo[_2945].field_1024))
            call address(poolInfo[_2945].field_1024).0xe26bdbfe with:
                 gas gas_remaining wei
                args msg.sender, stor[_2964][msg.sender]
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3141 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if idx >= mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + (32 * arg1.length) + 161] = mem[_3141]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + ((stor[_2964][msg.sender] * poolInfo[_2945].field_768) + (stor2[('map', 'msg.sender', ('var', '_2964'))] * poolInfo[_2945].field_1536) / 10^12) + stor[_2980][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2964'))]
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(sub_6af66772Address)
    staticcall sub_6af66772Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _2072 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2088 = mem[_2072]
    if mem[_2072] <= 0:
        revert with 0, 'No tokens to distribute'
    mem[mem[64] + 4] = msg.sender
    if s <= mem[_2072]:
        mem[mem[64] + 36] = s
        require ext_code.size(sub_6af66772Address)
        call sub_6af66772Address.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, s
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2165 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_2165] == bool(mem[_2165])
        if s == s:
            _3162 = mem[96]
            idx = 0
            while idx < _3162:
                if idx >= mem[96]:
                    revert with 0, 50
                _3200 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                emit Harvest(mem[mem[64]], msg.sender, _3200);
                if idx == -1:
                    revert with 0, 17
                _3162 = mem[96]
                idx = idx + 1
                continue 
            stor101 = 1
            _3240 = mem[64]
            mem[mem[64]] = s
            mem[mem[64] + 32] = 96
            _3258 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 128 len 32 * _3258] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3258]
            mem[mem[64] + 64] = (32 * _3258) + 128
            _3410 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3240 + (32 * _3258) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
            mem[_3240 + (32 * _3258) + 160 len 32 * _3410] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3410]
            var62001 = _3410
            return memory
              from mem[64]
               len _3240 + (32 * _3258) + (32 * _3410) + -mem[64] + 160
        _3163 = mem[96]
        idx = 0
        while idx < _3163:
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            if s and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / s:
                revert with 0, 17
            if not s:
                revert with 0, 18
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = s * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
            if idx >= mem[96]:
                revert with 0, 50
            _3320 = mem[(32 * idx) + 128]
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            emit Harvest(mem[mem[64]], msg.sender, _3320);
            if idx == -1:
                revert with 0, 17
            _3163 = mem[96]
            idx = idx + 1
            continue 
        stor101 = 1
        _3242 = mem[64]
        mem[mem[64]] = s
        mem[mem[64] + 32] = 96
        _3259 = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 128 len 32 * _3259] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3259]
        mem[mem[64] + 64] = (32 * _3259) + 128
        _3411 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3242 + (32 * _3259) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3242 + (32 * _3259) + 160 len 32 * _3411] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3411]
        var62001 = _3411
        return memory
          from mem[64]
           len _3242 + (32 * _3259) + (32 * _3411) + -mem[64] + 160
    mem[mem[64] + 36] = _2088
    require ext_code.size(sub_6af66772Address)
    call sub_6af66772Address.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, _2088
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _2166 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_2166] == bool(mem[_2166])
    if _2088 == s:
        _3164 = mem[96]
        idx = 0
        while idx < _3164:
            if idx >= mem[96]:
                revert with 0, 50
            _3203 = mem[(32 * idx) + 128]
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            emit Harvest(mem[mem[64]], msg.sender, _3203);
            if idx == -1:
                revert with 0, 17
            _3164 = mem[96]
            idx = idx + 1
            continue 
        stor101 = 1
        _3243 = mem[64]
        mem[mem[64]] = _2088
        mem[mem[64] + 32] = 96
        _3260 = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 128 len 32 * _3260] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3260]
        mem[mem[64] + 64] = (32 * _3260) + 128
        _3412 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3243 + (32 * _3260) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
        mem[_3243 + (32 * _3260) + 160 len 32 * _3412] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3412]
        var62001 = _3412
        return memory
          from mem[64]
           len _3243 + (32 * _3260) + (32 * _3412) + -mem[64] + 160
    _3165 = mem[96]
    idx = 0
    while idx < _3165:
        if idx >= mem[ceil32(32 * arg1.length) + 97]:
            revert with 0, 50
        if _2088 and mem[(32 * idx) + ceil32(32 * arg1.length) + 129] > -1 / _2088:
            revert with 0, 17
        if not s:
            revert with 0, 18
        if idx >= mem[ceil32(32 * arg1.length) + 97]:
            revert with 0, 50
        mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _2088 * mem[(32 * idx) + ceil32(32 * arg1.length) + 129] / s
        if idx >= mem[96]:
            revert with 0, 50
        _3324 = mem[(32 * idx) + 128]
        if idx >= mem[ceil32(32 * arg1.length) + 97]:
            revert with 0, 50
        mem[mem[64]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
        emit Harvest(mem[mem[64]], msg.sender, _3324);
        if idx == -1:
            revert with 0, 17
        _3165 = mem[96]
        idx = idx + 1
        continue 
    stor101 = 1
    _3245 = mem[64]
    mem[mem[64]] = _2088
    mem[mem[64] + 32] = 96
    _3261 = mem[ceil32(32 * arg1.length) + 97]
    mem[mem[64] + 96] = mem[ceil32(32 * arg1.length) + 97]
    mem[mem[64] + 128 len 32 * _3261] = mem[ceil32(32 * arg1.length) + 129 len 32 * _3261]
    mem[mem[64] + 64] = (32 * _3261) + 128
    _3413 = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
    mem[_3245 + (32 * _3261) + 128] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 129]
    mem[_3245 + (32 * _3261) + 160 len 32 * _3413] = mem[ceil32(32 * arg1.length) + (32 * arg1.length) + 161 len 32 * _3413]
    var62001 = _3413
    return memory
      from mem[64]
       len _3245 + (32 * _3261) + (32 * _3413) + -mem[64] + 160
}

function migrate(uint256[] arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    if not sub_01126816Address:
        revert with 0, 'to where?'
    mem[96] = arg1.length
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    if arg1.length > test266151307():
        revert with 0, 65
    mem[(32 * arg1.length) + 128] = arg1.length
    if not arg1.length:
        if arg1.length > test266151307():
            revert with 0, 65
        mem[(64 * arg1.length) + 160] = arg1.length
        mem[64] = (98 * arg1.length) + 192
        if not arg1.length:
            idx = 0
            s = 0
            while idx < arg1.length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1094 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                mem[0] = 209
                if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1128 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1154 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1191 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1154][msg.sender]
                    require ext_code.size(address(poolInfo[_1128].field_1024))
                    call address(poolInfo[_1128].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1154][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1640 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1640]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1154][msg.sender] * poolInfo[_1128].field_768) + (stor2[('map', 'msg.sender', ('var', '_1154'))] * poolInfo[_1128].field_1536) / 10^12) + stor[_1191][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1154'))]
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[_1094].field_0))
                staticcall address(poolInfo[_1094].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1129 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1156 = mem[_1129]
                if not mem[_1129]:
                    poolInfo[_1094].field_512 = block.timestamp
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1214 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1233 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1249 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1233][msg.sender]
                    require ext_code.size(address(poolInfo[_1214].field_1024))
                    call address(poolInfo[_1214].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1233][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1672 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1672]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1233][msg.sender] * poolInfo[_1214].field_768) + (stor2[('map', 'msg.sender', ('var', '_1233'))] * poolInfo[_1214].field_1536) / 10^12) + stor[_1249][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1233'))]
                    continue 
                if block.timestamp < poolInfo[_1094].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[_1094].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_1094].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[_1094].field_512 * sub_9702d3e2) and poolInfo[_1094].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_1094].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_1129] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_1129]:
                    revert with 0, 18
                if poolInfo[_1094].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1129]):
                    revert with 0, 17
                poolInfo[_1094].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1129]
                if not poolInfo[_1094].field_1280:
                    poolInfo[_1094].field_1536 = 0
                    require ext_code.size(address(poolInfo[_1094].field_0))
                    staticcall address(poolInfo[_1094].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1612 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1620 = mem[_1612]
                    if not mem[_1612]:
                        if poolInfo[_1094].field_256 and 833333333333333333 > -1 / poolInfo[_1094].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1094].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[_1094].field_256) < poolInfo[_1094].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1094].field_256) - poolInfo[_1094].field_1792
                        poolInfo[_1094].field_1792 = 833333333333333333 * poolInfo[_1094].field_256
                        poolInfo[_1094].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1156
                        mem[mem[64] + 64] = poolInfo[_1094].field_768
                        emit UpdatePool(block.timestamp, _1156, poolInfo[_1094].field_768, _1094);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1832 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1845 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1877 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1845][msg.sender]
                        require ext_code.size(address(poolInfo[_1832].field_1024))
                        call address(poolInfo[_1832].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1845][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2168 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2168]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1845][msg.sender] * poolInfo[_1832].field_768) + (stor2[('map', 'msg.sender', ('var', '_1845'))] * poolInfo[_1832].field_1536) / 10^12) + stor[_1877][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1845'))]
                        continue 
                    require ext_code.size(address(poolInfo[_1094].field_0))
                    staticcall address(poolInfo[_1094].field_0).0x961be391 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1644 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1644] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not _1620:
                        revert with 0, 18
                    if not 10^18 * mem[_1644] / _1620:
                        if poolInfo[_1094].field_256 and 1 > -1 / poolInfo[_1094].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !poolInfo[_1094].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 + poolInfo[_1094].field_256 < poolInfo[_1094].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1094].field_256 - poolInfo[_1094].field_1792
                        poolInfo[_1094].field_1792 = poolInfo[_1094].field_256
                        poolInfo[_1094].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1156
                        mem[mem[64] + 64] = poolInfo[_1094].field_768
                        emit UpdatePool(block.timestamp, _1156, poolInfo[_1094].field_768, _1094);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1728 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1741 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1757 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1741][msg.sender]
                        require ext_code.size(address(poolInfo[_1728].field_1024))
                        call address(poolInfo[_1728].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1741][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2021 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2021]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1741][msg.sender] * poolInfo[_1728].field_768) + (stor2[('map', 'msg.sender', ('var', '_1741'))] * poolInfo[_1728].field_1536) / 10^12) + stor[_1757][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1741'))]
                        continue 
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_1644] / _1620 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_1644] / _1620:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[_1094].field_256 and (((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17 > -1 / poolInfo[_1094].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[_1094].field_256 * (((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[_1094].field_256 * (((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17) < poolInfo[_1094].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1094].field_256 * (((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17) - poolInfo[_1094].field_1792
                    poolInfo[_1094].field_1792 = poolInfo[_1094].field_256 * (((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1644] / _1620 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1644] / _1620) + 2 * 10^17
                    poolInfo[_1094].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1156
                    mem[mem[64] + 64] = poolInfo[_1094].field_768
                    emit UpdatePool(block.timestamp, _1156, poolInfo[_1094].field_768, _1094);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1900 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1915 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1942 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1915][msg.sender]
                    require ext_code.size(address(poolInfo[_1900].field_1024))
                    call address(poolInfo[_1900].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1915][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2209 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2209]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1915][msg.sender] * poolInfo[_1900].field_768) + (stor2[('map', 'msg.sender', ('var', '_1915'))] * poolInfo[_1900].field_1536) / 10^12) + stor[_1942][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1915'))]
                    continue 
                if poolInfo[_1094].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[_1094].field_1280:
                    revert with 0, 18
                if poolInfo[_1094].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1094].field_1280):
                    revert with 0, 17
                poolInfo[_1094].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1094].field_1792) - (poolInfo[_1094].field_512 * sub_9702d3e2 * poolInfo[_1094].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1094].field_1280
                require ext_code.size(address(poolInfo[_1094].field_0))
                staticcall address(poolInfo[_1094].field_0).0x705727b5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1692 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1696 = mem[_1692]
                if not mem[_1692]:
                    if poolInfo[_1094].field_256 and 833333333333333333 > -1 / poolInfo[_1094].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1094].field_256):
                        revert with 0, 17
                    if sub_91ea1d68 + (833333333333333333 * poolInfo[_1094].field_256) < poolInfo[_1094].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1094].field_256) - poolInfo[_1094].field_1792
                    poolInfo[_1094].field_1792 = 833333333333333333 * poolInfo[_1094].field_256
                    poolInfo[_1094].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1156
                    mem[mem[64] + 64] = poolInfo[_1094].field_768
                    emit UpdatePool(block.timestamp, _1156, poolInfo[_1094].field_768, _1094);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1940 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1965 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2001 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1965][msg.sender]
                    require ext_code.size(address(poolInfo[_1940].field_1024))
                    call address(poolInfo[_1940].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1965][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2232 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2232]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1965][msg.sender] * poolInfo[_1940].field_768) + (stor2[('map', 'msg.sender', ('var', '_1965'))] * poolInfo[_1940].field_1536) / 10^12) + stor[_2001][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1965'))]
                    continue 
                require ext_code.size(address(poolInfo[_1094].field_0))
                staticcall address(poolInfo[_1094].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1708 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1708] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _1696:
                    revert with 0, 18
                if not 10^18 * mem[_1708] / _1696:
                    if poolInfo[_1094].field_256 and 1 > -1 / poolInfo[_1094].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[_1094].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[_1094].field_256 < poolInfo[_1094].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1094].field_256 - poolInfo[_1094].field_1792
                    poolInfo[_1094].field_1792 = poolInfo[_1094].field_256
                    poolInfo[_1094].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1156
                    mem[mem[64] + 64] = poolInfo[_1094].field_768
                    emit UpdatePool(block.timestamp, _1156, poolInfo[_1094].field_768, _1094);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1780 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1793 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1817 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1793][msg.sender]
                    require ext_code.size(address(poolInfo[_1780].field_1024))
                    call address(poolInfo[_1780].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1793][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2129 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2129]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1793][msg.sender] * poolInfo[_1780].field_768) + (stor2[('map', 'msg.sender', ('var', '_1793'))] * poolInfo[_1780].field_1536) / 10^12) + stor[_1817][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1793'))]
                    continue 
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_1708] / _1696 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_1708] / _1696:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[_1094].field_256 and (((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17 > -1 / poolInfo[_1094].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[_1094].field_256 * (((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[_1094].field_256 * (((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17) < poolInfo[_1094].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1094].field_256 * (((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17) - poolInfo[_1094].field_1792
                poolInfo[_1094].field_1792 = poolInfo[_1094].field_256 * (((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1708] / _1696 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1708] / _1696) + 2 * 10^17
                poolInfo[_1094].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _1156
                mem[mem[64] + 64] = poolInfo[_1094].field_768
                emit UpdatePool(block.timestamp, _1156, poolInfo[_1094].field_768, _1094);
                if idx >= mem[96]:
                    revert with 0, 50
                _2060 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2073 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2089 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[(32 * arg1.length) + 128]:
                    revert with 0, 50
                mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    continue 
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2073][msg.sender]
                require ext_code.size(address(poolInfo[_2060].field_1024))
                call address(poolInfo[_2060].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2073][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2256 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[(64 * arg1.length) + 160]:
                    revert with 0, 50
                mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2256]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2073][msg.sender] * poolInfo[_2060].field_768) + (stor2[('map', 'msg.sender', ('var', '_2073'))] * poolInfo[_2060].field_1536) / 10^12) + stor[_2089][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2073'))]
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(sub_6af66772Address)
            staticcall sub_6af66772Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1104 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1120 = mem[_1104]
            if mem[_1104] <= 0:
                revert with 0, 'No tokens to distribute'
            mem[mem[64] + 4] = msg.sender
            if s <= mem[_1104]:
                mem[mem[64] + 36] = s
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, s
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1188 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1188] == bool(mem[_1188])
                if s == s:
                    _2268 = mem[96]
                    idx = 0
                    while idx < _2268:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2300 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2300);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2660 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2660] == bool(mem[_2660])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2269 = mem[96]
                    idx = 0
                    while idx < _2269:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if s and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / s:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = s * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2446 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2446);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2661 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2661] == bool(mem[_2661])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
            else:
                mem[mem[64] + 36] = _1120
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _1120
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1189 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1189] == bool(mem[_1189])
                if _1120 == s:
                    _2270 = mem[96]
                    idx = 0
                    while idx < _2270:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2303 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2303);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2662 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2662] == bool(mem[_2662])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2271 = mem[96]
                    idx = 0
                    while idx < _2271:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if _1120 and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / _1120:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = _1120 * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2450 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2450);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2663 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2663] == bool(mem[_2663])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
        else:
            mem[(64 * arg1.length) + 192 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
            idx = 0
            s = 0
            while idx < arg1.length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1097 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                mem[0] = 209
                if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1130 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1163 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1196 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1163][msg.sender]
                    require ext_code.size(address(poolInfo[_1130].field_1024))
                    call address(poolInfo[_1130].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1163][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1641 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1641]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1163][msg.sender] * poolInfo[_1130].field_768) + (stor2[('map', 'msg.sender', ('var', '_1163'))] * poolInfo[_1130].field_1536) / 10^12) + stor[_1196][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1163'))]
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[_1097].field_0))
                staticcall address(poolInfo[_1097].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1131 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1165 = mem[_1131]
                if not mem[_1131]:
                    poolInfo[_1097].field_512 = block.timestamp
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1217 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1236 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1252 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1236][msg.sender]
                    require ext_code.size(address(poolInfo[_1217].field_1024))
                    call address(poolInfo[_1217].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1236][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1673 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1673]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1236][msg.sender] * poolInfo[_1217].field_768) + (stor2[('map', 'msg.sender', ('var', '_1236'))] * poolInfo[_1217].field_1536) / 10^12) + stor[_1252][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1236'))]
                    continue 
                if block.timestamp < poolInfo[_1097].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[_1097].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_1097].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[_1097].field_512 * sub_9702d3e2) and poolInfo[_1097].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_1097].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_1131] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_1131]:
                    revert with 0, 18
                if poolInfo[_1097].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1131]):
                    revert with 0, 17
                poolInfo[_1097].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1131]
                if not poolInfo[_1097].field_1280:
                    poolInfo[_1097].field_1536 = 0
                    require ext_code.size(address(poolInfo[_1097].field_0))
                    staticcall address(poolInfo[_1097].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1613 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1621 = mem[_1613]
                    if not mem[_1613]:
                        if poolInfo[_1097].field_256 and 833333333333333333 > -1 / poolInfo[_1097].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1097].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[_1097].field_256) < poolInfo[_1097].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1097].field_256) - poolInfo[_1097].field_1792
                        poolInfo[_1097].field_1792 = 833333333333333333 * poolInfo[_1097].field_256
                        poolInfo[_1097].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1165
                        mem[mem[64] + 64] = poolInfo[_1097].field_768
                        emit UpdatePool(block.timestamp, _1165, poolInfo[_1097].field_768, _1097);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1833 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1849 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1880 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1849][msg.sender]
                        require ext_code.size(address(poolInfo[_1833].field_1024))
                        call address(poolInfo[_1833].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1849][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2169 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2169]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1849][msg.sender] * poolInfo[_1833].field_768) + (stor2[('map', 'msg.sender', ('var', '_1849'))] * poolInfo[_1833].field_1536) / 10^12) + stor[_1880][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1849'))]
                        continue 
                    require ext_code.size(address(poolInfo[_1097].field_0))
                    staticcall address(poolInfo[_1097].field_0).0x961be391 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1645 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1645] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not _1621:
                        revert with 0, 18
                    if not 10^18 * mem[_1645] / _1621:
                        if poolInfo[_1097].field_256 and 1 > -1 / poolInfo[_1097].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !poolInfo[_1097].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 + poolInfo[_1097].field_256 < poolInfo[_1097].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1097].field_256 - poolInfo[_1097].field_1792
                        poolInfo[_1097].field_1792 = poolInfo[_1097].field_256
                        poolInfo[_1097].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1165
                        mem[mem[64] + 64] = poolInfo[_1097].field_768
                        emit UpdatePool(block.timestamp, _1165, poolInfo[_1097].field_768, _1097);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1729 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1744 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1760 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1744][msg.sender]
                        require ext_code.size(address(poolInfo[_1729].field_1024))
                        call address(poolInfo[_1729].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1744][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2023 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2023]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1744][msg.sender] * poolInfo[_1729].field_768) + (stor2[('map', 'msg.sender', ('var', '_1744'))] * poolInfo[_1729].field_1536) / 10^12) + stor[_1760][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1744'))]
                        continue 
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_1645] / _1621 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_1645] / _1621:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[_1097].field_256 and (((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17 > -1 / poolInfo[_1097].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[_1097].field_256 * (((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[_1097].field_256 * (((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17) < poolInfo[_1097].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1097].field_256 * (((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17) - poolInfo[_1097].field_1792
                    poolInfo[_1097].field_1792 = poolInfo[_1097].field_256 * (((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1645] / _1621 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1645] / _1621) + 2 * 10^17
                    poolInfo[_1097].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1165
                    mem[mem[64] + 64] = poolInfo[_1097].field_768
                    emit UpdatePool(block.timestamp, _1165, poolInfo[_1097].field_768, _1097);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1901 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1920 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1946 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1920][msg.sender]
                    require ext_code.size(address(poolInfo[_1901].field_1024))
                    call address(poolInfo[_1901].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1920][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2211 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2211]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1920][msg.sender] * poolInfo[_1901].field_768) + (stor2[('map', 'msg.sender', ('var', '_1920'))] * poolInfo[_1901].field_1536) / 10^12) + stor[_1946][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1920'))]
                    continue 
                if poolInfo[_1097].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[_1097].field_1280:
                    revert with 0, 18
                if poolInfo[_1097].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1097].field_1280):
                    revert with 0, 17
                poolInfo[_1097].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1097].field_1792) - (poolInfo[_1097].field_512 * sub_9702d3e2 * poolInfo[_1097].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1097].field_1280
                require ext_code.size(address(poolInfo[_1097].field_0))
                staticcall address(poolInfo[_1097].field_0).0x705727b5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1693 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1697 = mem[_1693]
                if not mem[_1693]:
                    if poolInfo[_1097].field_256 and 833333333333333333 > -1 / poolInfo[_1097].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1097].field_256):
                        revert with 0, 17
                    if sub_91ea1d68 + (833333333333333333 * poolInfo[_1097].field_256) < poolInfo[_1097].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1097].field_256) - poolInfo[_1097].field_1792
                    poolInfo[_1097].field_1792 = 833333333333333333 * poolInfo[_1097].field_256
                    poolInfo[_1097].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1165
                    mem[mem[64] + 64] = poolInfo[_1097].field_768
                    emit UpdatePool(block.timestamp, _1165, poolInfo[_1097].field_768, _1097);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1944 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1969 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2004 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1969][msg.sender]
                    require ext_code.size(address(poolInfo[_1944].field_1024))
                    call address(poolInfo[_1944].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1969][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2233 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2233]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1969][msg.sender] * poolInfo[_1944].field_768) + (stor2[('map', 'msg.sender', ('var', '_1969'))] * poolInfo[_1944].field_1536) / 10^12) + stor[_2004][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1969'))]
                    continue 
                require ext_code.size(address(poolInfo[_1097].field_0))
                staticcall address(poolInfo[_1097].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1709 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1709] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _1697:
                    revert with 0, 18
                if not 10^18 * mem[_1709] / _1697:
                    if poolInfo[_1097].field_256 and 1 > -1 / poolInfo[_1097].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[_1097].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[_1097].field_256 < poolInfo[_1097].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1097].field_256 - poolInfo[_1097].field_1792
                    poolInfo[_1097].field_1792 = poolInfo[_1097].field_256
                    poolInfo[_1097].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1165
                    mem[mem[64] + 64] = poolInfo[_1097].field_768
                    emit UpdatePool(block.timestamp, _1165, poolInfo[_1097].field_768, _1097);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1781 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1796 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1821 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1796][msg.sender]
                    require ext_code.size(address(poolInfo[_1781].field_1024))
                    call address(poolInfo[_1781].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1796][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2131 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2131]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1796][msg.sender] * poolInfo[_1781].field_768) + (stor2[('map', 'msg.sender', ('var', '_1796'))] * poolInfo[_1781].field_1536) / 10^12) + stor[_1821][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1796'))]
                    continue 
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_1709] / _1697 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_1709] / _1697:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[_1097].field_256 and (((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17 > -1 / poolInfo[_1097].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[_1097].field_256 * (((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[_1097].field_256 * (((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17) < poolInfo[_1097].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1097].field_256 * (((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17) - poolInfo[_1097].field_1792
                poolInfo[_1097].field_1792 = poolInfo[_1097].field_256 * (((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1709] / _1697 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1709] / _1697) + 2 * 10^17
                poolInfo[_1097].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _1165
                mem[mem[64] + 64] = poolInfo[_1097].field_768
                emit UpdatePool(block.timestamp, _1165, poolInfo[_1097].field_768, _1097);
                if idx >= mem[96]:
                    revert with 0, 50
                _2061 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2076 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2092 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[(32 * arg1.length) + 128]:
                    revert with 0, 50
                mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    continue 
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2076][msg.sender]
                require ext_code.size(address(poolInfo[_2061].field_1024))
                call address(poolInfo[_2061].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2076][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2257 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[(64 * arg1.length) + 160]:
                    revert with 0, 50
                mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2257]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2076][msg.sender] * poolInfo[_2061].field_768) + (stor2[('map', 'msg.sender', ('var', '_2076'))] * poolInfo[_2061].field_1536) / 10^12) + stor[_2092][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2076'))]
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(sub_6af66772Address)
            staticcall sub_6af66772Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1106 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1122 = mem[_1106]
            if mem[_1106] <= 0:
                revert with 0, 'No tokens to distribute'
            mem[mem[64] + 4] = msg.sender
            if s <= mem[_1106]:
                mem[mem[64] + 36] = s
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, s
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1193 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1193] == bool(mem[_1193])
                if s == s:
                    _2272 = mem[96]
                    idx = 0
                    while idx < _2272:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2306 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2306);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2664 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2664] == bool(mem[_2664])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2273 = mem[96]
                    idx = 0
                    while idx < _2273:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if s and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / s:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = s * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2454 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2454);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2665 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2665] == bool(mem[_2665])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
            else:
                mem[mem[64] + 36] = _1122
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _1122
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1194 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1194] == bool(mem[_1194])
                if _1122 == s:
                    _2274 = mem[96]
                    idx = 0
                    while idx < _2274:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2309 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2309);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2666 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2666] == bool(mem[_2666])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2275 = mem[96]
                    idx = 0
                    while idx < _2275:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if _1122 and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / _1122:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = _1122 * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2458 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2458);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2667 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2667] == bool(mem[_2667])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
    else:
        mem[(32 * arg1.length) + 160 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
        if arg1.length > test266151307():
            revert with 0, 65
        mem[(64 * arg1.length) + 160] = arg1.length
        mem[64] = (98 * arg1.length) + 192
        if not arg1.length:
            idx = 0
            s = 0
            while idx < arg1.length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1100 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                mem[0] = 209
                if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1132 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1172 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1201 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1172][msg.sender]
                    require ext_code.size(address(poolInfo[_1132].field_1024))
                    call address(poolInfo[_1132].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1172][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1642 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1642]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1172][msg.sender] * poolInfo[_1132].field_768) + (stor2[('map', 'msg.sender', ('var', '_1172'))] * poolInfo[_1132].field_1536) / 10^12) + stor[_1201][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1172'))]
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[_1100].field_0))
                staticcall address(poolInfo[_1100].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1133 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1174 = mem[_1133]
                if not mem[_1133]:
                    poolInfo[_1100].field_512 = block.timestamp
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1220 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1239 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1255 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1239][msg.sender]
                    require ext_code.size(address(poolInfo[_1220].field_1024))
                    call address(poolInfo[_1220].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1239][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1674 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1674]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1239][msg.sender] * poolInfo[_1220].field_768) + (stor2[('map', 'msg.sender', ('var', '_1239'))] * poolInfo[_1220].field_1536) / 10^12) + stor[_1255][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1239'))]
                    continue 
                if block.timestamp < poolInfo[_1100].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[_1100].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_1100].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[_1100].field_512 * sub_9702d3e2) and poolInfo[_1100].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_1100].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_1133] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_1133]:
                    revert with 0, 18
                if poolInfo[_1100].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1133]):
                    revert with 0, 17
                poolInfo[_1100].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1133]
                if not poolInfo[_1100].field_1280:
                    poolInfo[_1100].field_1536 = 0
                    require ext_code.size(address(poolInfo[_1100].field_0))
                    staticcall address(poolInfo[_1100].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1614 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1622 = mem[_1614]
                    if not mem[_1614]:
                        if poolInfo[_1100].field_256 and 833333333333333333 > -1 / poolInfo[_1100].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1100].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[_1100].field_256) < poolInfo[_1100].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1100].field_256) - poolInfo[_1100].field_1792
                        poolInfo[_1100].field_1792 = 833333333333333333 * poolInfo[_1100].field_256
                        poolInfo[_1100].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1174
                        mem[mem[64] + 64] = poolInfo[_1100].field_768
                        emit UpdatePool(block.timestamp, _1174, poolInfo[_1100].field_768, _1100);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1834 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1853 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1883 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1853][msg.sender]
                        require ext_code.size(address(poolInfo[_1834].field_1024))
                        call address(poolInfo[_1834].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1853][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2170 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2170]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1853][msg.sender] * poolInfo[_1834].field_768) + (stor2[('map', 'msg.sender', ('var', '_1853'))] * poolInfo[_1834].field_1536) / 10^12) + stor[_1883][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1853'))]
                        continue 
                    require ext_code.size(address(poolInfo[_1100].field_0))
                    staticcall address(poolInfo[_1100].field_0).0x961be391 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1646 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1646] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not _1622:
                        revert with 0, 18
                    if not 10^18 * mem[_1646] / _1622:
                        if poolInfo[_1100].field_256 and 1 > -1 / poolInfo[_1100].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !poolInfo[_1100].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 + poolInfo[_1100].field_256 < poolInfo[_1100].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1100].field_256 - poolInfo[_1100].field_1792
                        poolInfo[_1100].field_1792 = poolInfo[_1100].field_256
                        poolInfo[_1100].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1174
                        mem[mem[64] + 64] = poolInfo[_1100].field_768
                        emit UpdatePool(block.timestamp, _1174, poolInfo[_1100].field_768, _1100);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1730 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1747 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1763 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1747][msg.sender]
                        require ext_code.size(address(poolInfo[_1730].field_1024))
                        call address(poolInfo[_1730].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1747][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2025 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2025]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1747][msg.sender] * poolInfo[_1730].field_768) + (stor2[('map', 'msg.sender', ('var', '_1747'))] * poolInfo[_1730].field_1536) / 10^12) + stor[_1763][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1747'))]
                        continue 
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_1646] / _1622 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_1646] / _1622:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[_1100].field_256 and (((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17 > -1 / poolInfo[_1100].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[_1100].field_256 * (((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[_1100].field_256 * (((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17) < poolInfo[_1100].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1100].field_256 * (((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17) - poolInfo[_1100].field_1792
                    poolInfo[_1100].field_1792 = poolInfo[_1100].field_256 * (((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1646] / _1622 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1646] / _1622) + 2 * 10^17
                    poolInfo[_1100].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1174
                    mem[mem[64] + 64] = poolInfo[_1100].field_768
                    emit UpdatePool(block.timestamp, _1174, poolInfo[_1100].field_768, _1100);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1902 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1925 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1950 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1925][msg.sender]
                    require ext_code.size(address(poolInfo[_1902].field_1024))
                    call address(poolInfo[_1902].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1925][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2213 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2213]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1925][msg.sender] * poolInfo[_1902].field_768) + (stor2[('map', 'msg.sender', ('var', '_1925'))] * poolInfo[_1902].field_1536) / 10^12) + stor[_1950][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1925'))]
                    continue 
                if poolInfo[_1100].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[_1100].field_1280:
                    revert with 0, 18
                if poolInfo[_1100].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1100].field_1280):
                    revert with 0, 17
                poolInfo[_1100].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1100].field_1792) - (poolInfo[_1100].field_512 * sub_9702d3e2 * poolInfo[_1100].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1100].field_1280
                require ext_code.size(address(poolInfo[_1100].field_0))
                staticcall address(poolInfo[_1100].field_0).0x705727b5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1694 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1698 = mem[_1694]
                if not mem[_1694]:
                    if poolInfo[_1100].field_256 and 833333333333333333 > -1 / poolInfo[_1100].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1100].field_256):
                        revert with 0, 17
                    if sub_91ea1d68 + (833333333333333333 * poolInfo[_1100].field_256) < poolInfo[_1100].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1100].field_256) - poolInfo[_1100].field_1792
                    poolInfo[_1100].field_1792 = 833333333333333333 * poolInfo[_1100].field_256
                    poolInfo[_1100].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1174
                    mem[mem[64] + 64] = poolInfo[_1100].field_768
                    emit UpdatePool(block.timestamp, _1174, poolInfo[_1100].field_768, _1100);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1948 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1973 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2007 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1973][msg.sender]
                    require ext_code.size(address(poolInfo[_1948].field_1024))
                    call address(poolInfo[_1948].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1973][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2234 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2234]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1973][msg.sender] * poolInfo[_1948].field_768) + (stor2[('map', 'msg.sender', ('var', '_1973'))] * poolInfo[_1948].field_1536) / 10^12) + stor[_2007][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1973'))]
                    continue 
                require ext_code.size(address(poolInfo[_1100].field_0))
                staticcall address(poolInfo[_1100].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1710 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1710] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _1698:
                    revert with 0, 18
                if not 10^18 * mem[_1710] / _1698:
                    if poolInfo[_1100].field_256 and 1 > -1 / poolInfo[_1100].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[_1100].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[_1100].field_256 < poolInfo[_1100].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1100].field_256 - poolInfo[_1100].field_1792
                    poolInfo[_1100].field_1792 = poolInfo[_1100].field_256
                    poolInfo[_1100].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1174
                    mem[mem[64] + 64] = poolInfo[_1100].field_768
                    emit UpdatePool(block.timestamp, _1174, poolInfo[_1100].field_768, _1100);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1782 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1799 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1825 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1799][msg.sender]
                    require ext_code.size(address(poolInfo[_1782].field_1024))
                    call address(poolInfo[_1782].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1799][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2133 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2133]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1799][msg.sender] * poolInfo[_1782].field_768) + (stor2[('map', 'msg.sender', ('var', '_1799'))] * poolInfo[_1782].field_1536) / 10^12) + stor[_1825][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1799'))]
                    continue 
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_1710] / _1698 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_1710] / _1698:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[_1100].field_256 and (((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17 > -1 / poolInfo[_1100].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[_1100].field_256 * (((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[_1100].field_256 * (((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17) < poolInfo[_1100].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1100].field_256 * (((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17) - poolInfo[_1100].field_1792
                poolInfo[_1100].field_1792 = poolInfo[_1100].field_256 * (((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1710] / _1698 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1710] / _1698) + 2 * 10^17
                poolInfo[_1100].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _1174
                mem[mem[64] + 64] = poolInfo[_1100].field_768
                emit UpdatePool(block.timestamp, _1174, poolInfo[_1100].field_768, _1100);
                if idx >= mem[96]:
                    revert with 0, 50
                _2062 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2079 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2095 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[(32 * arg1.length) + 128]:
                    revert with 0, 50
                mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    continue 
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2079][msg.sender]
                require ext_code.size(address(poolInfo[_2062].field_1024))
                call address(poolInfo[_2062].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2079][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2258 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[(64 * arg1.length) + 160]:
                    revert with 0, 50
                mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2258]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2079][msg.sender] * poolInfo[_2062].field_768) + (stor2[('map', 'msg.sender', ('var', '_2079'))] * poolInfo[_2062].field_1536) / 10^12) + stor[_2095][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2079'))]
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(sub_6af66772Address)
            staticcall sub_6af66772Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1108 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1124 = mem[_1108]
            if mem[_1108] <= 0:
                revert with 0, 'No tokens to distribute'
            mem[mem[64] + 4] = msg.sender
            if s <= mem[_1108]:
                mem[mem[64] + 36] = s
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, s
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1198 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1198] == bool(mem[_1198])
                if s == s:
                    _2276 = mem[96]
                    idx = 0
                    while idx < _2276:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2312 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2312);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2668 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2668] == bool(mem[_2668])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2277 = mem[96]
                    idx = 0
                    while idx < _2277:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if s and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / s:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = s * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2462 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2462);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2669 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2669] == bool(mem[_2669])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
            else:
                mem[mem[64] + 36] = _1124
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _1124
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1199 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1199] == bool(mem[_1199])
                if _1124 == s:
                    _2278 = mem[96]
                    idx = 0
                    while idx < _2278:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2315 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2315);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2670 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2670] == bool(mem[_2670])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2279 = mem[96]
                    idx = 0
                    while idx < _2279:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if _1124 and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / _1124:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = _1124 * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2466 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2466);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2671 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2671] == bool(mem[_2671])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
        else:
            mem[(64 * arg1.length) + 192 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
            idx = 0
            s = 0
            while idx < arg1.length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1103 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                mem[0] = 209
                if block.timestamp <= poolInfo[mem[(32 * idx) + 128]].field_512:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1134 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1181 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1206 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1181][msg.sender]
                    require ext_code.size(address(poolInfo[_1134].field_1024))
                    call address(poolInfo[_1134].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1181][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1643 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1643]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1181][msg.sender] * poolInfo[_1134].field_768) + (stor2[('map', 'msg.sender', ('var', '_1181'))] * poolInfo[_1134].field_1536) / 10^12) + stor[_1206][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1181'))]
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(poolInfo[_1103].field_0))
                staticcall address(poolInfo[_1103].field_0).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1135 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1183 = mem[_1135]
                if not mem[_1135]:
                    poolInfo[_1103].field_512 = block.timestamp
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1223 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1242 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1258 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1242][msg.sender]
                    require ext_code.size(address(poolInfo[_1223].field_1024))
                    call address(poolInfo[_1223].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1242][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1675 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_1675]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1242][msg.sender] * poolInfo[_1223].field_768) + (stor2[('map', 'msg.sender', ('var', '_1242'))] * poolInfo[_1223].field_1536) / 10^12) + stor[_1258][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1242'))]
                    continue 
                if block.timestamp < poolInfo[_1103].field_512:
                    revert with 0, 17
                if block.timestamp - poolInfo[_1103].field_512 and sub_9702d3e2 > -1 / block.timestamp - poolInfo[_1103].field_512:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2) - (poolInfo[_1103].field_512 * sub_9702d3e2) and poolInfo[_1103].field_1792 > -1 / (block.timestamp * sub_9702d3e2) - (poolInfo[_1103].field_512 * sub_9702d3e2):
                    revert with 0, 17
                if not sub_91ea1d68:
                    revert with 0, 18
                if mem[_1135] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 and sub_05ed1de4 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * mem[_1135]:
                    revert with 0, 18
                if poolInfo[_1103].field_768 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1135]):
                    revert with 0, 17
                poolInfo[_1103].field_768 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 * sub_05ed1de4 / 1000 * mem[_1135]
                if not poolInfo[_1103].field_1280:
                    poolInfo[_1103].field_1536 = 0
                    require ext_code.size(address(poolInfo[_1103].field_0))
                    staticcall address(poolInfo[_1103].field_0).0x705727b5 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1615 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1623 = mem[_1615]
                    if not mem[_1615]:
                        if poolInfo[_1103].field_256 and 833333333333333333 > -1 / poolInfo[_1103].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1103].field_256):
                            revert with 0, 17
                        if sub_91ea1d68 + (833333333333333333 * poolInfo[_1103].field_256) < poolInfo[_1103].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1103].field_256) - poolInfo[_1103].field_1792
                        poolInfo[_1103].field_1792 = 833333333333333333 * poolInfo[_1103].field_256
                        poolInfo[_1103].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1183
                        mem[mem[64] + 64] = poolInfo[_1103].field_768
                        emit UpdatePool(block.timestamp, _1183, poolInfo[_1103].field_768, _1103);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1835 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1857 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1886 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1857][msg.sender]
                        require ext_code.size(address(poolInfo[_1835].field_1024))
                        call address(poolInfo[_1835].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1857][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2171 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2171]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1857][msg.sender] * poolInfo[_1835].field_768) + (stor2[('map', 'msg.sender', ('var', '_1857'))] * poolInfo[_1835].field_1536) / 10^12) + stor[_1886][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1857'))]
                        continue 
                    require ext_code.size(address(poolInfo[_1103].field_0))
                    staticcall address(poolInfo[_1103].field_0).0x961be391 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1647 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1647] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                        revert with 0, 17
                    if not _1623:
                        revert with 0, 18
                    if not 10^18 * mem[_1647] / _1623:
                        if poolInfo[_1103].field_256 and 1 > -1 / poolInfo[_1103].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 > !poolInfo[_1103].field_256:
                            revert with 0, 17
                        if sub_91ea1d68 + poolInfo[_1103].field_256 < poolInfo[_1103].field_1792:
                            revert with 0, 17
                        sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1103].field_256 - poolInfo[_1103].field_1792
                        poolInfo[_1103].field_1792 = poolInfo[_1103].field_256
                        poolInfo[_1103].field_512 = block.timestamp
                        mem[mem[64]] = block.timestamp
                        mem[mem[64] + 32] = _1183
                        mem[mem[64] + 64] = poolInfo[_1103].field_768
                        emit UpdatePool(block.timestamp, _1183, poolInfo[_1103].field_768, _1103);
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1731 = mem[(32 * idx) + 128]
                        if mem[(32 * idx) + 128] >= poolInfo.length:
                            revert with 0, 50
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1750 = sha3(mem[(32 * idx) + 128], 212)
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 212)
                        if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s
                            continue 
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1766 = sha3(mem[(32 * idx) + 128], 213)
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                            revert with 0, 17
                        if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                            revert with 0, 17
                        if idx >= mem[96]:
                            revert with 0, 50
                        mem[0] = msg.sender
                        mem[32] = sha3(mem[(32 * idx) + 128], 213)
                        sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                            revert with 0, 17
                        if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                            revert with 0, 17
                        userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                        if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                            revert with 0, 17
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                            continue 
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor[_1750][msg.sender]
                        require ext_code.size(address(poolInfo[_1731].field_1024))
                        call address(poolInfo[_1731].field_1024).0xe26bdbfe with:
                             gas gas_remaining wei
                            args msg.sender, stor[_1750][msg.sender]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2027 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if idx >= mem[(64 * arg1.length) + 160]:
                            revert with 0, 50
                        mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2027]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((stor[_1750][msg.sender] * poolInfo[_1731].field_768) + (stor2[('map', 'msg.sender', ('var', '_1750'))] * poolInfo[_1731].field_1536) / 10^12) + stor[_1766][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1750'))]
                        continue 
                    if 1000000000000000000 * 10^18 > !(10^18 * mem[_1647] / _1623 / 2):
                        revert with 0, 17
                    if not 10^18 * mem[_1647] / _1623:
                        revert with 0, 18
                    if 2 * 10^17 > !((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623):
                        revert with 0, 17
                    if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17 / 2):
                        revert with 0, 17
                    if not ((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17:
                        revert with 0, 18
                    if poolInfo[_1103].field_256 and (((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17 > -1 / poolInfo[_1103].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(poolInfo[_1103].field_256 * (((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17):
                        revert with 0, 17
                    if sub_91ea1d68 + (poolInfo[_1103].field_256 * (((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17) < poolInfo[_1103].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1103].field_256 * (((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17) - poolInfo[_1103].field_1792
                    poolInfo[_1103].field_1792 = poolInfo[_1103].field_256 * (((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1647] / _1623 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1647] / _1623) + 2 * 10^17
                    poolInfo[_1103].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1183
                    mem[mem[64] + 64] = poolInfo[_1103].field_768
                    emit UpdatePool(block.timestamp, _1183, poolInfo[_1103].field_768, _1103);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1903 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1930 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1954 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1930][msg.sender]
                    require ext_code.size(address(poolInfo[_1903].field_1024))
                    call address(poolInfo[_1903].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1930][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2215 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2215]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1930][msg.sender] * poolInfo[_1903].field_768) + (stor2[('map', 'msg.sender', ('var', '_1930'))] * poolInfo[_1903].field_1536) / 10^12) + stor[_1954][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1930'))]
                    continue 
                if poolInfo[_1103].field_1280 > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 > 0x119799812dea11197f27f0f6e885c8ba7eb31f476caf7411a863387:
                    revert with 0, 17
                if 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 and sub_f87bbc56 > -1 / 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68:
                    revert with 0, 17
                if not 1000 * poolInfo[_1103].field_1280:
                    revert with 0, 18
                if poolInfo[_1103].field_1536 > !(10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1103].field_1280):
                    revert with 0, 17
                poolInfo[_1103].field_1536 += 10^12 * (block.timestamp * sub_9702d3e2 * poolInfo[_1103].field_1792) - (poolInfo[_1103].field_512 * sub_9702d3e2 * poolInfo[_1103].field_1792) / sub_91ea1d68 * sub_f87bbc56 / 1000 * poolInfo[_1103].field_1280
                require ext_code.size(address(poolInfo[_1103].field_0))
                staticcall address(poolInfo[_1103].field_0).0x705727b5 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1695 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1699 = mem[_1695]
                if not mem[_1695]:
                    if poolInfo[_1103].field_256 and 833333333333333333 > -1 / poolInfo[_1103].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !(833333333333333333 * poolInfo[_1103].field_256):
                        revert with 0, 17
                    if sub_91ea1d68 + (833333333333333333 * poolInfo[_1103].field_256) < poolInfo[_1103].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + (833333333333333333 * poolInfo[_1103].field_256) - poolInfo[_1103].field_1792
                    poolInfo[_1103].field_1792 = 833333333333333333 * poolInfo[_1103].field_256
                    poolInfo[_1103].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1183
                    mem[mem[64] + 64] = poolInfo[_1103].field_768
                    emit UpdatePool(block.timestamp, _1183, poolInfo[_1103].field_768, _1103);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1952 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1977 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _2010 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1977][msg.sender]
                    require ext_code.size(address(poolInfo[_1952].field_1024))
                    call address(poolInfo[_1952].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1977][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2235 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2235]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1977][msg.sender] * poolInfo[_1952].field_768) + (stor2[('map', 'msg.sender', ('var', '_1977'))] * poolInfo[_1952].field_1536) / 10^12) + stor[_2010][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1977'))]
                    continue 
                require ext_code.size(address(poolInfo[_1103].field_0))
                staticcall address(poolInfo[_1103].field_0).0x961be391 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1711 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1711] > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
                    revert with 0, 17
                if not _1699:
                    revert with 0, 18
                if not 10^18 * mem[_1711] / _1699:
                    if poolInfo[_1103].field_256 and 1 > -1 / poolInfo[_1103].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 > !poolInfo[_1103].field_256:
                        revert with 0, 17
                    if sub_91ea1d68 + poolInfo[_1103].field_256 < poolInfo[_1103].field_1792:
                        revert with 0, 17
                    sub_91ea1d68 = sub_91ea1d68 + poolInfo[_1103].field_256 - poolInfo[_1103].field_1792
                    poolInfo[_1103].field_1792 = poolInfo[_1103].field_256
                    poolInfo[_1103].field_512 = block.timestamp
                    mem[mem[64]] = block.timestamp
                    mem[mem[64] + 32] = _1183
                    mem[mem[64] + 64] = poolInfo[_1103].field_768
                    emit UpdatePool(block.timestamp, _1183, poolInfo[_1103].field_768, _1103);
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1783 = mem[(32 * idx) + 128]
                    if mem[(32 * idx) + 128] >= poolInfo.length:
                        revert with 0, 50
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1802 = sha3(mem[(32 * idx) + 128], 212)
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 212)
                    if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1829 = sha3(mem[(32 * idx) + 128], 213)
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                        revert with 0, 17
                    if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                        revert with 0, 17
                    if idx >= mem[96]:
                        revert with 0, 50
                    mem[0] = msg.sender
                    mem[32] = sha3(mem[(32 * idx) + 128], 213)
                    sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                        revert with 0, 17
                    if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                        revert with 0, 17
                    userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                    if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                        revert with 0, 17
                    if idx >= mem[(32 * arg1.length) + 128]:
                        revert with 0, 50
                    mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                        continue 
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor[_1802][msg.sender]
                    require ext_code.size(address(poolInfo[_1783].field_1024))
                    call address(poolInfo[_1783].field_1024).0xe26bdbfe with:
                         gas gas_remaining wei
                        args msg.sender, stor[_1802][msg.sender]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2135 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if idx >= mem[(64 * arg1.length) + 160]:
                        revert with 0, 50
                    mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2135]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((stor[_1802][msg.sender] * poolInfo[_1783].field_768) + (stor2[('map', 'msg.sender', ('var', '_1802'))] * poolInfo[_1783].field_1536) / 10^12) + stor[_1829][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_1802'))]
                    continue 
                if 1000000000000000000 * 10^18 > !(10^18 * mem[_1711] / _1699 / 2):
                    revert with 0, 17
                if not 10^18 * mem[_1711] / _1699:
                    revert with 0, 18
                if 2 * 10^17 > !((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699):
                    revert with 0, 17
                if 1000000000000000000 * 10^18 > !(((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17 / 2):
                    revert with 0, 17
                if not ((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17:
                    revert with 0, 18
                if poolInfo[_1103].field_256 and (((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17 > -1 / poolInfo[_1103].field_256:
                    revert with 0, 17
                if sub_91ea1d68 > !(poolInfo[_1103].field_256 * (((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17):
                    revert with 0, 17
                if sub_91ea1d68 + (poolInfo[_1103].field_256 * (((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17) < poolInfo[_1103].field_1792:
                    revert with 0, 17
                sub_91ea1d68 = sub_91ea1d68 + (poolInfo[_1103].field_256 * (((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17) - poolInfo[_1103].field_1792
                poolInfo[_1103].field_1792 = poolInfo[_1103].field_256 * (((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17 / 2) + 1000000000000000000 * 10^18 / ((10^18 * mem[_1711] / _1699 / 2) + 1000000000000000000 * 10^18 / 10^18 * mem[_1711] / _1699) + 2 * 10^17
                poolInfo[_1103].field_512 = block.timestamp
                mem[mem[64]] = block.timestamp
                mem[mem[64] + 32] = _1183
                mem[mem[64] + 64] = poolInfo[_1103].field_768
                emit UpdatePool(block.timestamp, _1183, poolInfo[_1103].field_768, _1103);
                if idx >= mem[96]:
                    revert with 0, 50
                _2063 = mem[(32 * idx) + 128]
                if mem[(32 * idx) + 128] >= poolInfo.length:
                    revert with 0, 50
                if idx >= mem[96]:
                    revert with 0, 50
                _2082 = sha3(mem[(32 * idx) + 128], 212)
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 212)
                if not userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _2098 = sha3(mem[(32 * idx) + 128], 213)
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                if (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12 > !sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)]:
                    revert with 0, 17
                if ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] < userInfo[mem[(32 * idx) + 128]][msg.sender].field_256:
                    revert with 0, 17
                if idx >= mem[96]:
                    revert with 0, 50
                mem[0] = msg.sender
                mem[32] = sha3(mem[(32 * idx) + 128], 213)
                sub_8b4d83a3[mem[(32 * idx) + 128]][msg.sender] = 0
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 and poolInfo[mem[(32 * idx) + 128]].field_1536 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_512:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 and poolInfo[mem[(32 * idx) + 128]].field_768 > -1 / userInfo[mem[(32 * idx) + 128]][msg.sender].field_0:
                    revert with 0, 17
                if userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768 > !(userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536):
                    revert with 0, 17
                userInfo[mem[(32 * idx) + 128]][msg.sender].field_256 = (userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12
                if s > !(((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256):
                    revert with 0, 17
                if idx >= mem[(32 * arg1.length) + 128]:
                    revert with 0, 50
                mem[(32 * idx) + (32 * arg1.length) + 160] = ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                if not address(poolInfo[mem[(32 * idx) + 128]].field_1024):
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((userInfo[mem[(32 * idx) + 128]][msg.sender].field_0 * poolInfo[mem[(32 * idx) + 128]].field_768) + (userInfo[mem[(32 * idx) + 128]][msg.sender].field_512 * poolInfo[mem[(32 * idx) + 128]].field_1536) / 10^12) + sub_8b4d83a3[mem[(32 * idx) + 128]][address(msg.sender)] - userInfo[mem[(32 * idx) + 128]][msg.sender].field_256
                    continue 
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor[_2082][msg.sender]
                require ext_code.size(address(poolInfo[_2063].field_1024))
                call address(poolInfo[_2063].field_1024).0xe26bdbfe with:
                     gas gas_remaining wei
                    args msg.sender, stor[_2082][msg.sender]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2259 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[(64 * arg1.length) + 160]:
                    revert with 0, 50
                mem[(32 * idx) + (64 * arg1.length) + 192] = mem[_2259]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((stor[_2082][msg.sender] * poolInfo[_2063].field_768) + (stor2[('map', 'msg.sender', ('var', '_2082'))] * poolInfo[_2063].field_1536) / 10^12) + stor[_2098][address(msg.sender)] - stor1[('map', 'msg.sender', ('var', '_2082'))]
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(sub_6af66772Address)
            staticcall sub_6af66772Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1110 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1126 = mem[_1110]
            if mem[_1110] <= 0:
                revert with 0, 'No tokens to distribute'
            mem[mem[64] + 4] = msg.sender
            if s <= mem[_1110]:
                mem[mem[64] + 36] = s
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, s
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1203 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1203] == bool(mem[_1203])
                if s == s:
                    _2280 = mem[96]
                    idx = 0
                    while idx < _2280:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2318 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2318);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2672 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2672] == bool(mem[_2672])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2281 = mem[96]
                    idx = 0
                    while idx < _2281:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if s and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / s:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = s * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2470 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2470);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2673 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2673] == bool(mem[_2673])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
            else:
                mem[mem[64] + 36] = _1126
                require ext_code.size(sub_6af66772Address)
                call sub_6af66772Address.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _1126
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1204 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1204] == bool(mem[_1204])
                if _1126 == s:
                    _2282 = mem[96]
                    idx = 0
                    while idx < _2282:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2321 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2321);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2674 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2674] == bool(mem[_2674])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                else:
                    _2283 = mem[96]
                    idx = 0
                    while idx < _2283:
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        if _1126 and mem[(32 * idx) + (32 * arg1.length) + 160] > -1 / _1126:
                            revert with 0, 17
                        if not s:
                            revert with 0, 18
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[(32 * idx) + (32 * arg1.length) + 160] = _1126 * mem[(32 * idx) + (32 * arg1.length) + 160] / s
                        if idx >= mem[96]:
                            revert with 0, 50
                        _2474 = mem[(32 * idx) + 128]
                        if idx >= mem[(32 * arg1.length) + 128]:
                            revert with 0, 50
                        mem[mem[64]] = mem[(32 * idx) + (32 * arg1.length) + 160]
                        emit Harvest(mem[mem[64]], msg.sender, _2474);
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < arg1.length:
                        mem[0] = msg.sender
                        mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                        if userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0:
                            if cd[((32 * idx) + arg1 + 36)] >= poolInfo.length:
                                revert with 0, 50
                            mem[0] = 209
                            mem[mem[64] + 4] = sub_01126816Address
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            require ext_code.size(address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0))
                            call address(poolInfo[cd[((32 * idx) + arg1 + 36)]].field_0).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args sub_01126816Address, userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2675 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_2675] == bool(mem[_2675])
                            mem[mem[64]] = 0x90210d7e00000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = cd[((32 * idx) + arg1 + 36)]
                            mem[mem[64] + 36] = userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0
                            mem[mem[64] + 68] = msg.sender
                            require ext_code.size(sub_01126816Address)
                            call sub_01126816Address.0x90210d7e with:
                                 gas gas_remaining wei
                                args cd[((32 * idx) + arg1 + 36)], userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0, msg.sender
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 < userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512:
                                revert with 0, 17
                            poolInfo[cd[((32 * idx) + arg1 + 36)]].field_1280 -= userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512
                            mem[0] = msg.sender
                            mem[32] = sha3(cd[((32 * idx) + arg1 + 36)], 212)
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_0 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_256 = 0
                            userInfo[cd[((32 * idx) + arg1 + 36)]][msg.sender].field_512 = 0
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
    stor101 = 1
}



}
